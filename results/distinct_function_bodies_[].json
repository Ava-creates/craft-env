{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      # Try to pick up the ingredient if not enough in inventory\n      actions += pickup_item(env, ingredients[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 78}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Sort ingredients by distance to current position for efficient picking up\n  sorted_ingredients = sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - get_item_position(env._current_state.grid, x[0])), reverse=True)\n\n  for ingredient_index, count in sorted_ingredients:\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 43}
{"function_body": "  def get_primitive_costs(goal):\n    recipe = env.world.recipes.get(goal, {})\n    costs = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isdigit():\n        primitive_index = int(ingredient)\n        if primitive_index not in costs:\n          # Get the cost of the primitive resource\n          primitive_costs = env.world.primitives_for(primitive_index)\n          costs[primitive_index] = primitive_costs\n      else:\n        raise ValueError(\"Invalid ingredient type\")\n    return costs\n\n  def craft_step(current_item, target_item):\n    if current_item == target_item:\n      return []\n    cost = get_primitive_costs(target_item)\n    actions = []\n    for primitive, count in cost.items():\n      while env.world.inventory[primitive] > 0 and count > 0:\n        actions.append(env.world.index.get(primitive))\n        env.world.inventory[primitive] -= 1\n        count -= 1\n    return actions + craft_step(current_item, target_item) if count > 0 else []\n\n  start_item = item\n  initial_actions = craft_step(start_item, start_item)\n  return initial_actions", "occurrence_count": 42}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 30}
{"function_body": "  def get_component_indices():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.primitives_for(goal)\n    component_indices = []\n    for component, count in recipe.items():\n      if component < len(env.non_grabbable_indices):\n        component_index = list(env.non_grabbable_indices).index(component)\n        for _ in range(count):\n          if not env.next_to(component_index):\n            direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n            component_indices.append((component_index, direction))\n    return component_indices\n  \n  def get_actions():\n    actions = []\n    for component_index, direction in get_component_indices():\n      if not env.next_to(component_index):\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n    return actions\n  \n  return get_actions()", "occurrence_count": 29}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 28}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 27}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(env._current_state.pos)\n        pickup()\n  return actions", "occurrence_count": 24}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 19}
{"function_body": "  def find_and_use(count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count):\n      # If the item is not immediately available, try to move towards it\n      if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n        actions.append(0)  # Move up\n      elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n        actions.append(1)  # Move down\n      elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n        actions.append(2)  # Move left\n      elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n        actions.append(3)  # Move right\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 15}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  inventory = env._current_state.inventory\n  for ingredient_index, count in ingredients.items():\n    while not inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 14}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      actions.append(env.world.grabbable_indices.index(required_item))\n      actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 14}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 12}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 12}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 12}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[item_idx] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 10}
{"function_body": "  # Your implementation here\n  return []", "occurrence_count": 9}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      pick_up_item(item_idx)\n      count -= 1\n    use_item_for_crafting(item_idx)\n  \n  return actions", "occurrence_count": 9}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0:\n      if inventory[item_idx] < count:\n        pick_up_item(item_idx)\n      else:\n        use_item_for_crafting(item_idx)\n      count -= 1\n  \n  return actions", "occurrence_count": 9}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 9}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 9}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 9}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 8}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      actions.append(4)  # USE\n      \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 8}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        actions += move_to_item(env._current_state.pos, target_pos)\n        \n        while available_count < count:\n          actions += [4]  # USE action\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 8}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    ingredient_idx = None\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = i\n    \n    return (closest_pos, ingredient_idx) if closest_pos is not None else (None, None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft the final product\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 7}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        requirements[current] = env.world.cookbook.primitives_for(current)\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 6}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      for index in indices:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      for _ in range(count):\n        actions.append(4)  # USE action to use the primitive to craft the item\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 6}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 6}
{"function_body": "  def find_ingredient(env, ingredient_index):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        x = env._current_state.pos[0] + dx\n        y = env._current_state.pos[1] + dy\n        if 0 <= x < env._current_state.grid.shape[0] and 0 <= y < env._current_state.grid.shape[1]:\n          cell = env._current_state.grid[x, y, :]\n          for i in range(env.world.n_kinds):\n            if cell[i] == ingredient_index and i not in env.non_grabbable_indices:\n              return (x, y)\n    return None\n\n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      _, arg = parse_fexp(ingredient)\n      ingredient_index = env.world.cookbook.index[arg]\n      \n      while count > 0 and env._current_state.inventory[ingredient_index] > 0:\n        actions.append(USE)\n        env._current_state.inventory[ingredient_index] -= 1\n        count -= 1\n      \n      found = False\n      for _ in range(count):\n        ingredient_pos = find_ingredient(env, ingredient_index)\n        if ingredient_pos:\n          actions.append(MOVE_TO(*ingredient_pos))\n          env._current_state.pos = ingredient_pos\n          found = True\n          break\n      \n      if not found and count > 0:\n        actions.append(USE)\n        count -= 1\n  \n  return actions", "occurrence_count": 6}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n\n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n\n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = get_required_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Sort ingredients by distance to current position for efficient picking up\n  sorted_ingredients = sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - get_item_position(env._current_state.grid, x[0])), reverse=True)\n\n  for ingredient_index, count in sorted_ingredients:\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 5}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 5}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    actions.extend([env.world.grabbable_indices.index(ingredient) for ingredient, count in reversed(list(recipe.items()))])\n    inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      actions.append(4)  # USE\n      \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            found = True\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 5}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    return ingredient_indices\n  \n  def pickup_ingredients(env, ingredient_indices):\n    actions = []\n    inventory = env._current_state.inventory\n    for index in ingredient_indices:\n      while inventory[index] < recipe[index]:\n        actions += pickup_item(env, index)\n    return actions\n  \n  def use_ingredients(env, ingredient_indices):\n    actions = []\n    for index in ingredient_indices:\n      action = use_item(env, index)\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices)\n  actions += use_ingredients(env, ingredient_indices)\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  def get_recipe(item):\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index.get(item)\n    if goal_index is None:\n      raise ValueError(\"Item not found in cookbook\")\n    return cookbook.recipes.get(goal_index)\n  \n  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      # Try to pick up the ingredient if not enough in inventory\n      actions += pickup_item(env, ingredients[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 5}
{"function_body": "  def get_ingredients():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.recipes.get(goal, {})\n    ingredients = {}\n    for ingredient_name, count in recipe.items():\n      if isinstance(ingredient_name, int):  # Ensure it's an index\n        ingredient_index = ingredient_name\n        required_count = count\n        actual_count = env.inventory[ingredient_index]\n        delta = required_count - actual_count\n        if delta > 0:\n          ingredients[ingredient_index] = delta\n    return ingredients\n  \n  def get_actions():\n    actions = []\n    ingredients = get_ingredients()\n    for ingredient_index, count in ingredients.items():\n      while not env.next_to(ingredient_index) and count > 0:\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == ingredient_index)\n        actions.append(direction)\n        count -= 1\n      if count > 0:\n        # If we still need more of this ingredient and are not next to it, pick up the ingredient first\n        actions.append(4)  # USE to craft the item if possible\n    return actions\n  \n  return get_actions()", "occurrence_count": 5}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[arg] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    if inventory[int(item)] >= count:\n      use_item_for_crafting(item)\n    else:\n      pick_up_item(int(item))\n      use_item_for_crafting(item)\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_item_in_inventory(item):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    return next((ing for ing, count in inventory.items() if ing == item), None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    found = False\n    for ing, count in list(zip(ingredients, counts)):\n      if count > 0 and find_item_in_inventory(ing):\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n        found = True\n    \n    if not found:\n      break\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def craft_item(item_idx):\n    actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      # Try to pick up the required items if they are available\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      count -= 1\n    # Craft the item after ensuring we have enough of each required ingredient\n    craft_item(item_idx)\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Sort the items in the recipe by their current quantity in the inventory, from high to low\n  sorted_ingredients = sorted(recipe.items(), key=lambda x: -x[1])\n\n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    # Find the most abundant ingredients first and craft them\n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        # After crafting the ingredients, we need to re-sort the recipe based on the updated inventory\n        sorted_ingredients = sorted(recipe.items(), key=lambda x: -x[1])\n        crafted = True\n        break\n    if not crafted:\n      break  # If no more items can be crafted, we stop crafting\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = [(ingredient, env._current_state.next_to(ingredient)) for ingredient, count in needed_items.items()]\n    \n    while any(count > 0 for _, count in available_items):\n      for i, (ingredient, next_to) in enumerate(available_items):\n        if next_to:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          available_items[i] = (ingredient, False)  # Mark as used\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Sort ingredients by the amount in inventory, descending\n  sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n  \n  for ingredient in sorted_ingredients:\n    while inventory[ingredient] > 0 and recipe[ingredient] > 0:\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n      recipe[ingredient] -= 1\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Find and collect all ingredients required by the current recipe\n    for ingredient_index in ingredient_indices:\n      position = find_item(env.grid, ingredient_index)\n      if position is None: \n        raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n      \n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      while dx != 0 or dy != 0:\n        if dx < 0: \n          actions.append(2)  # LEFT\n          dx += 1\n        elif dx > 0: \n          actions.append(3)  # RIGHT\n          dx -= 1\n        elif dy < 0: \n          actions.append(1)  # UP\n          dy += 1\n        elif dy > 0: \n          actions.append(0)  # DOWN\n          dy -= 1\n      if position != env.pos: actions.append(4)  # USE to pick up the ingredient if not already at its location\n    \n    # Update the recipe for the next iteration, now that we have collected this ingredient\n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def find_and_use(count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  def move_to_ingredient():\n    if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n      actions.append(0)  # Move up\n    elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n      actions.append(1)  # Move down\n    elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n      actions.append(2)  # Move left\n    elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n      actions.append(3)  # Move right\n    else:\n      raise ValueError(\"Ingredient not found in the grid.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count):\n      move_to_ingredient()\n\n  return actions", "occurrence_count": 4}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check inventory before taking action to avoid unnecessary actions\n        inventory = env._current_state.inventory\n        if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          # Check again after picking up to see if it can be used for crafting\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n    \n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    # Check if the component is a primitive (not an environment entity)\n    if component < len(env.non_grabbable_indices):\n      # Find the index of the component in the environment's non-grabbable indices\n      component_index = list(env.non_grabbable_indices).index(component)\n      \n      # Add actions to pick up and use the component until the required count is reached\n      for _ in range(count):\n        if not env.next_to(component_index):\n          direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n          actions.append(direction)\n        actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  def get_ingredient_indices(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    return [ingredient_index for ingredient_index in recipe if ingredient_index != \"_key\"]\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  ingredient_indices = get_ingredient_indices(goal_index)\n  actions = [env.grabbable_indices.index(i) for i in ingredient_indices]\n  \n  return actions", "occurrence_count": 4}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  needed_items = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and its index/argument\n      _, arg = parse_fexp(ingredient)\n      needed_items[arg] = count\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  for item, count in needed_items.items():\n    # Find the items in the inventory that are required for crafting\n    if inventory[item] >= count:\n      # If we have enough of the item, use it up to the count required\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n    else:\n      # Otherwise, try to pick up more items if they are available and not already in inventory\n      item_idx = env.world.cookbook.index.get_by_name(str(item))\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n        # After picking up the item, use it for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n      else:\n        # If we can't pick up or don't have enough items, do nothing for this required item\n        pass\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    craftable = True\n    for ingredient, count in recipe.items():\n      if inventory[ingredient] < count:\n        craftable = False\n        break\n    if not craftable:\n      break\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def find_and_craft(goal):\n    recipe = get_recipe(goal)\n    inventory = env._current_state.inventory\n    actions = []\n    \n    while sum(inventory[i] for i in recipe) > 0:\n      crafted = False\n      for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n        if inventory[ingredient] >= count:\n          actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n          crafted = True\n          break\n      if not crafted:\n        # Try to find and craft the item directly from the environment\n        for i in range(len(inventory)):\n          if inventory[i] > 0 and env.world.cookbook.index.get(i) == goal:\n            actions.append(env.world.grabbable_indices.index(i))\n            break\n      inventory = env._current_state.inventory\n    \n    return actions\n  \n  # Find the recipe for the desired item and craft it\n  return find_and_craft(item)", "occurrence_count": 3}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Sort the items in the recipe by their current quantity in the inventory, from high to low\n  sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n\n  while sum(inventory[i] for i in recipe) > 0:\n    # Find the most abundant ingredients first and craft them\n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        # After crafting the ingredients, we need to re-sort the recipe based on the updated inventory\n        sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n        crafted = True\n        break\n    if not crafted:\n      break  # If no more items can be crafted, we stop crafting\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Sort ingredients by the amount in inventory, descending\n  sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n  \n  for ingredient in sorted_ingredients:\n    while inventory[ingredient] >= recipe[ingredient]:\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def craft_item(item_idx):\n    actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx in needed_items:\n    while needed_items[item_idx] > 0 and inventory[item_idx] < needed_items[item_idx]:\n      # Try to pick up the required items if they are available\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      needed_items[item_idx] -= 1\n    # Craft the item after ensuring we have enough of each required ingredient\n    craft_item(item_idx)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  # Your code here!\n  return []", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    most_available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    most_available_items.sort(key=lambda x: -x[1])\n    \n    while len(most_available_items) > 0 and most_available_items[0][1] > 0:\n      ingredient, count = most_available_items[0]\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n      most_available_items = [(i, inventory[i]) for i in recipe if inventory[i] > 0]\n      most_available_items.sort(key=lambda x: -x[1])\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_ingredients():\n    goal_idx = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  actions = []\n  ingredients = get_ingredients()\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    ingredients.remove(ingredient_idx)\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  inventory = env._current_state.inventory\n  for ingredient_index, count in ingredients.items():\n    while not inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while not craftable(inventory, get_recipe(item)) and sum(inventory[i] for i in get_recipe(item)) > 0:\n    recipe = get_recipe(item)\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    # Sort by the least available first (ascending order of availability)\n    for ingredient, count in sorted(missing.items(), key=lambda x: env._current_state.inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    \n    # Craft the item if possible after acquiring all necessary ingredients\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to indices list to check their requirements recursively.\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 3}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_postate[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(env._current_state.pos)\n        pickup()\n  return actions", "occurrence_count": 3}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos, ingredient_index) in positions:\n        move_to(positions[(env._current_state.pos, ingredient_index)])\n        pickup()\n  return actions", "occurrence_count": 3}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices, ingredient_counts = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices, ingredient_counts)\n  actions += use_ingredients(env, ingredient_indices, ingredient_counts)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      while len(indices) > 0:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(indices[0]))  # Find the actual pickup action based on index\n        inventory[primitive] -= 1\n        indices = np.where(inventory[primitive] > 0)[0]  # Update indices after using one\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def find_and_use_item(env, item_index):\n    # Find all instances of the item in the inventory.\n    indices = np.where(env._current_state.inventory[item_index] > 0)[0]\n    \n    for index in indices:\n      actions = []\n      while env._current_state.inventory[item_index] >= recipe[index]:\n        # Use the item to craft other items if necessary\n        actions.append(4)  # USE action to use the item\n        env._current_state.inventory[item_index] -= 1\n      return actions\n    return []\n\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  if not recipe:\n    return []\n\n  actions = []\n  \n  for primitive, count in recipe.items():\n    # Find all instances of the primitive in the inventory.\n    indices = np.where(env._current_state.inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to use the primitive to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # If it can, add 'USE' actions for each count of the ingredient found\n        for _ in range(count):\n          actions.append(4)  # USE action index\n        break\n      else:\n        found = True\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 3}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = get_item_count(index)\n      \n      if available_count >= count:\n        actions += [4] * count  # USE action\n      else:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count and not (target_pos == pos).all():\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = get_item_count(index)\n        \n        if available_count >= count:\n          actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n  \n  def find_item_in_inventory(env, index):\n    inventory = env._current_state.inventory\n    available_count = inventory[index]\n    if available_count > 0:\n      return True\n    return False\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      while not find_item_in_inventory(env, index):\n        pos = env._current_state.pos\n        target_pos = get_item_index(name)\n        actions += move_to_item(pos, target_pos)\n        \n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      for _ in range(min(available_count, count)):\n        actions += [4]  # USE action\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(env.action_index['use'])  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def check_if_can_craft(inventory, recipe):\n    for item, _ in recipe.items():\n      if inventory[item] == 0:\n        return False\n    return True\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  while check_if_can_craft(env._current_state.inventory, recipe):\n    craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      pickup_action = pickup_item(env, ingredients[i])\n      if pickup_action:\n        actions.append(pickup_action)\n      inventory = env._current_state.inventory  # Update the inventory after potential pickup\n    \n    use_action = use_item(env, ingredients[i], counts[i])\n    if use_action is not None:\n      actions.append(use_action)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  def get_component_indices():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.primitives_for(goal)\n    component_indices = []\n    for component, count in recipe.items():\n      if component < len(env.non_grabbable_indices):\n        component_index = list(env.non_grabbable_indices).index(component)\n        for _ in range(count):\n          actions = [4]  # Use action to pick up the component\n          if not env.next_to(component_index):\n            direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n            actions.insert(0, direction)\n          component_indices.append((component_index, actions))\n    return component_indices\n  \n  def get_actions():\n    actions = []\n    for component_index, use_action in get_component_indices():\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.insert(0, direction)  # Insert at the beginning to maintain order\n      actions.append(use_action)  # Always use the final action to pick up the component\n    return actions\n  \n  return get_actions()", "occurrence_count": 3}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index[item]\n  \n  # Retrieve the recipe for this goal\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  # Initialize an empty list to hold actions\n  actions = []\n  \n  # Iterate over the ingredients in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 3}
{"function_body": "  # Your code here!\n  \n  return []", "occurrence_count": 2}
{"function_body": "  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_item_in_inventory(inventory, item):\n    idx = env.world.cookbook.index.get_by_name(str(item))\n    if inventory[idx] >= 1:\n      return True\n    return False\n  \n  recipe = env.world.cookbook.recipes[item]\n  needed_items = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and its index/argument\n      _, arg = parse_fexp(ingredient)\n      needed_items[arg] = count\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  for item, count in needed_items.items():\n    # Find the items in the inventory that are required for crafting\n    if find_item_in_inventory(inventory, item):\n      # If we have enough of the item, use it up to the count required\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n    else:\n      # Otherwise, try to pick up more items if they are available and not already in inventory\n      item_idx = env.world.cookbook.index.get_by_name(str(item))\n      if env._current_state.next_to(item_idx) and not find_item_in_inventory(inventory, item):\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n        # After picking up the item, use it for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n      else:\n        # If we can't pick up or don't have enough items, do nothing for this required item\n        pass\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n\n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n\n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = get_required_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        # Find the action to use the item from the inventory\n        action = env.world.cookbook.index.contents[ing]\n        actions.append(action)\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    if available_count >= count:\n      # If we do, use the item (craft it) by adding a USE action for each count\n      actions += [4] * count\n    else:\n      # Otherwise, find out how many are needed and craft them one by one until enough is available\n      needed = count - available_count\n      while needed > 0:\n        # Find the next most abundant primitive resource that we have at least some of\n        for idx in needed_indices:\n          if env.world.inventory[idx] > 0:\n            actions.append(env.world.cookbook.index.getitem(str(idx)))\n            needed -= 1\n            break\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = {ingredient: count for ingredient, count in needed_items.items() if env._current_state.next_to(ingredient)}\n    \n    while sum(available_items.values()) > 0:\n      for ingredient, count in available_items.items():\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n        available_items[ingredient] -= 1\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    found_items = find_items_in_inventory(ingredients)\n    if not found_items:\n      break\n    \n    for ing, count in found_items:\n      actions.append(ing)\n      counts[ingredients.index(ing)] -= 1\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    # Sort the ingredients by their availability in inventory, starting from the most abundant\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    \n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        crafted = True\n        break  # Only one ingredient should be used at a time to craft the item\n    \n    if not crafted:\n      break  # If no ingredients can be used, stop crafting\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(item):\n    inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n    items = [ing for ing, count in inventory.items() if ing == item]\n    return items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  \n  while any(counts):\n    found = False\n    for ing, count in list(zip(ingredients, counts)):\n      items_in_inventory = find_items_in_inventory(ing)\n      if len(items_in_inventory) >= count and all(items_in_inventory):\n        actions.extend([env.world.cookbook.index.contents[ing]] * min(counts))\n        counts = [max(0, c - 1) for c in counts]\n        found = True\n    \n    if not found:\n      break\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in sorted(missing.items(), key=lambda x: env._current_state.inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    \n    # Craft the item\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      item = next((inv for inv in inventory if inv == ing), None)\n      if item:\n        found_items.append(item)\n    return found_items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    used_items = find_items_in_inventory(ingredients)\n    for ing, count in list(zip(used_items, counts)):\n      actions.append(ing)\n      counts[used_items.index(ing)] -= 1\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while not craftable(inventory, get_recipe(item)):\n    if sum(inventory[i] for i in get_recipe(item)) == 0:\n      break\n    recipe = get_recipe(item)\n    for ingredient, count in reversed(list(recipe.items())):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def most_abundant_resource(needed_resources):\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  # Extract indices and counts for crafting from the recipe\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for _, count in needed_resources:\n    while env.world.inventory[needed_resources[0][0]] < count:\n      most_abundant = most_abundant_resource(needed_resources)\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not most_abundant:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      idx, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[needed_resources[0][0]]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_resources():\n    recipe = env.world.cookbook.recipes[item]\n    needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n    return needed_indices\n  \n  actions = []\n  resources_needed = find_resources()\n  \n  # Check inventory and perform necessary actions to acquire or use them\n  for idx in resources_needed:\n    available_count = env.world.inventory[idx]\n    \n    while available_count < 1:\n      # Find the next most abundant primitive resource that we have at least some of\n      for ridx in resources_needed:\n        if env.world.inventory[ridx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(ridx)))\n          available_count += 1\n          break\n      \n      # If no more resources are available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if available_count < 1:\n        break\n    \n    # Use the item (craft it) by adding a USE action for each count\n    actions.append(4)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_closest_ingredient(env, goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    if not recipe:\n      return None\n    \n    for ingredient_index, count in recipe.items():\n      if ingredient_index not in env.state.inventory or env.state.inventory[ingredient_index] == 0:\n        positions = np.argwhere(env.state.grid == ingredient_index)\n        if len(positions) > 0:\n          distances = np.linalg.norm(positions - env.state.pos, axis=1)\n          closest_pos = positions[np.argmin(distances)]\n          rel_pos = closest_pos - env.state.pos\n          return (ingredient_index, rel_pos)\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  while True:\n    ingredient = get_closest_ingredient(env, goal_idx)\n    if ingredient is None:\n      break\n    \n    ingredient_index, rel_pos = ingredient\n    direction = np.argmax(np.abs(rel_pos))\n    actions += [direction] * abs(rel_pos[direction])\n    \n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredient():\n    for idx in env.world.kinds:\n      if idx in env.state.inventory and not any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient()\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while count > 0 and inventory[item] < count:\n      pick_up_item(item)\n      count -= 1\n    use_item_for_crafting(item)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    # Sort ingredients by the amount in inventory, descending\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n    for ingredient in sorted_ingredients:\n      while inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, np.argwhere(env.state.grid == i)[0]) for i in recipe if env.state.inventory[i] == 0]\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_closest_ingredient_pos(ingredients):\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    closest_pos = get_closest_ingredient_pos(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_closest_ingredient():\n    ingredients = [ingredient for ingredient in env.world.cookbook.index if recipe.get(ingredient, None)]\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, ingredients[0] if ingredients else None\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    closest_pos, next_ingredient = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(next_ingredient)\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  recipe = get_recipe(goal_idx)\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Check if we can use the ingredient for crafting and it's available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n      recipe = get_recipe(goal_idx)  # Update the recipe since inventory might have changed\n      if not recipe:\n        break\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the recipe for the desired item.\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    current = [item]\n    while len(current) > 0:\n      next_item = current.pop()\n      if next_item not in requirements:\n        reqs = env.world.cookbook.primitives_for(next_item)\n        if reqs:\n          requirements[next_item] = reqs\n          # Add the required components to the current list to check their requirements recursively.\n          for k, v in reqs.items():\n            current += [k] * v\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos_pos:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(env._current_state.pos)\n        pickup()\n  return actions", "occurrence_count": 2}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Find and collect all ingredients required by the current recipe\n    for ingredient_index in ingredient_indices:\n      position = find_item(env, ingredient_index)\n      if position is None: \n        raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n      \n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      if position != env.pos: actions.append(4)  # USE to pick up the ingredient if not already at its location\n    \n    # Update the recipe for the next iteration, now that we have collected this ingredient\n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    current = [item]\n    while len(current) > 0:\n      next_item = current.pop()\n      if next_item not in requirements:\n        reqs = env.world.cookbook.primitives_for(next_item)\n        if reqs:\n          requirements[next_item] = reqs\n          # Add the required components to the current list to check their requirements recursively.\n          for k, v in reqs.items():\n            current += [k] * v\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  def find_all_primitives(item):\n    all_prims = set()\n    for k, v in env.world.cookbook.primitives_for(item).items():\n      all_prims.add(k)\n      all_prims |= find_all_primitives(k)\n    return all_prims\n\n  def craft_sequence_with_priorities(item, requirements):\n    actions = []\n    for key in sorted(requirements.keys(), key=lambda x: len(env.world.cookbook.primitives_for(x))):\n      if not all(env.world.cookbook.primitives_for(key).values()):\n        value = requirements[key]\n        actions += [env.world.non_grabbable_indices.index] * value + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence_with_priorities(item, requirements)\n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 2}
{"function_body": "  # Your implementation goes here.\n  return []", "occurrence_count": 2}
{"function_body": "  def get_requirements(item):\n    reqs = env.world.cookbook.primitives_for(item)\n    if not reqs:\n      return {}\n    requirements = {item: reqs}\n    for k, v in reqs.items():\n      sub_reqs = get_requirements(k)\n      if sub_reqs:\n        requirements[k] = sub_reqs\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n    for ingredient in sorted_ingredients:\n      if inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      for index in indices:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while count > 0 and np.any(inventory[primitive] > 0):\n        actions.append(4)  # USE action to use the primitive to craft the item\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_and_pickup(ingredient_index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == ingredient_index) and env.world.cookbook.reverse_contents[ingredient_index] not in env.non_grabbable_indices:\n          dx = x - env.pos[0]\n          dy = y - env.pos[1]\n          if dx < 0: return 2  # LEFT\n          elif dx > 0: return 3  # RIGHT\n          elif dy < 0: return 1  # UP\n          elif dy > 0: return 0  # DOWN\n          else: return 4  # USE\n    return None\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  while any(isinstance(value, dict) for value in recipe.values()):\n    found = False\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        for sub_ingredient_index, sub_count in count.items():\n          if not found:\n            action = find_and_pickup(sub_ingredient_index)\n            if action is not None:\n              actions.append(action)\n              found = True\n      else:\n        if not found:\n          action = find_and_pickup(ingredient_index)\n          if action is not None:\n            actions.append(action)\n            found = True\n    recipe = env.world.cookbook.recipes[ingredient_index]\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count and env._current_state.next_to(ingredient):\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(env._current_state.pos)\n        pickup()\n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredient():\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if env.grid[x, y, ingredient_index] == 1:\n          return (x, y)\n    raise ValueError(\"Ingredient not found in the grid.\")\n\n  def move_to_position(target):\n    if target[0] < env.pos[0]:\n      actions.append(1)  # Move down\n    elif target[0] > env.pos[0]:\n      actions.append(0)  # Move up\n    elif target[1] < env.pos[1]:\n      actions.append(3)  # Move right\n    elif target[1] > env.pos[1]:\n      actions.append(2)  # Move left\n    else:\n      raise ValueError(\"Target position not reachable.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while count > 0:\n      target_pos = find_ingredient()\n      move_to_position(target_pos)\n      actions.append(4)  # Use the found item\n      count -= 1\n\n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the goal index from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  cookbook = env.world.cookbook\n  idx = cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = get_recipe(idx)\n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Get the current inventory of items needed for crafting\n  inventory = env._current_state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Check the position of the item and move towards it if necessary\n        pos = env._current_state.pos\n        grid = env._current_state.grid\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (pos[0]+dx, pos[1]+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # If we have enough items, craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos.pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n  for ingredient_index, count in ingredients:\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      actions += pickup_item(env, ingredients[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices = []\n  ingredient_counts = []\n  for key, count in recipe.items():\n    if isinstance(key, int):\n      ingredient_indices.append(key)\n      ingredient_counts.append(count)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  for i in range(len(ingredient_indices)):\n    while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n      # If we don't have enough of an ingredient, try to pick up more\n      actions += pickup_item(env, ingredient_indices[i])\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item_index)\n      if pos[0].size > 0:\n        return (pos[0][0], pos[1][0])\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_requirements(item):\n    indices = [item]\n    requirements = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to check their requirements recursively.\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Initialize the path with USE actions for each ingredient\n  actions = [4] * len(required_items)\n  \n  # Find and replace USE actions with actual paths to items in inventory or workshop\n  for i, required_item in enumerate(required_items):\n    if required_item in env.world.inventory:\n      continue  # If item is already in inventory, no action needed\n    \n    path = find_path_to_item(env, required_item)\n    if path:\n      actions[i] = None  # Mark this as a path to be filled later\n  \n  return [action if action is not None else fill_path_with_actions(env, required_item) for action, required_item in zip(actions, required_items)]", "occurrence_count": 2}
{"function_body": "  def find_and_grab_items(env, primitive_indices):\n    actions = []\n    for primitive in primitive_indices:\n      while not env._is_satisfied(primitive):\n        if env.next_to(primitive):\n          actions.append(env.grabbable_indices.index(primitive))  # Move to the item and grab it\n        else:\n          directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Directions for up, down, left, right\n          current_pos = env._current_state.pos\n          for dx, dy in directions:\n            new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if env._is_valid_position(new_pos):\n              actions.append(env._move_to(new_pos))  # Move to the position and grab the item\n              break\n        actions.append(4)  # Use the grabbed item after moving to it\n    return actions\n\n  recipe = env.world.cookbook.recipes[item]\n  primitive_indices = []\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.parse_fexp(ingredient)\n      primitive_index = env.world.cookbook.index[name]\n      primitive_indices.append((primitive_index, count))\n\n  actions = []\n  for primitive_index, count in primitive_indices:\n    actions += find_and_grab_items(env, [primitive_index] * count)\n\n  return actions", "occurrence_count": 2}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      while len(indices) > 0:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(indices[0]))  # Find the actual pickup action based on index\n        indices = np.where(inventory[primitive] > 0)[0]  # Update indices after using one\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while count > 0 and np.any(inventory[primitive] > 0):\n        actions.append(4)  # USE action to use the primitive to craft the item\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def find_and_move(env, item_idx):\n    grid = env._current_state.grid\n    pos = env._current_state.pos\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0] + dx, pos[1] + dy, item_idx] > 0:\n          return (env.action_index['right'] if dx == 1 else env.action_index['left'] if dx == -1 else None,\n                  env.action_index['up' if dy == -1 else 'down'])\n    return None, None\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  while any(env._current_state.inventory[idx] < count for idx, count in recipe.items()):\n    move_actions = []\n    _, inventory = env._get_item_and_update_inventory(recipe)\n    \n    for item_idx, count in recipe.items():\n      if env._current_state.inventory[item_idx] < count:\n        found_move_action, _ = find_and_move(env, item_idx)\n        if found_move_action is not None:\n          move_actions.append(found_move_action)\n    \n    actions.extend(move_actions)\n    craft_items(actions, inventory, recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Implement the improved crafting logic here.\n  return []", "occurrence_count": 2}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    return ingredient_indices\n  \n  def pickup_ingredients(env, ingredient_indices):\n    actions = []\n    inventory = env._current_state.inventory\n    for index in ingredient_indices:\n      while inventory[index] < recipe[index]:\n        actions += pickup_item(env, index)\n    return actions\n  \n  def use_ingredients(env, ingredient_indices):\n    actions = []\n    for index in ingredient_indices:\n      action = use_item(env, index, recipe[index])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices)\n  actions += use_ingredients(env, ingredient_indices)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(4)  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Pick up the necessary items first\n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      action = pickup_item(env, ingredients[i])\n      if action is not None:\n        actions.append(action)\n        env._current_state = env.step(action)[1]  # Update the state after pickup\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n  \n  # Use the ingredients to craft the item\n  for i in range(len(ingredients)):\n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  actions = []\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory that are needed.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(env.action_index['use'])  # USE action to use the primitive\n        inventory[primitive] -= 1\n  \n  def check_if_can_craft(inventory, recipe):\n    for item, _ in recipe.items():\n      if inventory[item] == 0:\n        return False\n    return True\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  while check_if_can_craft(env._current_state.inventory, recipe):\n    craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = get_item_count(index)\n      \n      if available_count >= count:\n        actions += [4] * count  # USE action\n      else:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = get_item_count(index)\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredient(kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          return (x, y)\n    return None\n\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  # Get the required ingredients and their counts from the recipe\n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  # Check if we have all the required ingredients in the inventory\n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  actions = []\n  for kind, count in required_ingredients.items():\n    while inventory[kind] < count:\n      pos = find_ingredient(kind)\n      if pos is None:\n        return []\n      dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n      actions.append(dir)\n      if env._current_state.step(dir) == (\"use\", None):\n        break\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredient(env, kind, count):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          pos = (x, y)\n          dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n          yield dir\n\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  for ingredient, count in recipe.items():\n    kind = ingredient if isinstance(ingredient, int) else env.world.cookbook.index[ingredient]\n    \n    # If the ingredient is not available in sufficient quantity, try to find and pick it up\n    found = False\n    for dir in find_ingredient(env, kind, count):\n      actions.append(dir)\n      if env._current_state.step(dir) == (\"use\", None):\n        found = True\n        break\n    \n    # If the ingredient was not found in the grid, return an empty list (no action to craft)\n    if not found:\n      return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      if ingredient_index == \"_key\":\n        continue\n      ingredients.append((ingredient_index, count))\n    return ingredients\n\n  def find_and_use_ingredients(ingredients):\n    actions = []\n    for ingredient_index, _ in ingredients:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  ingredients = get_ingredients(goal_index)\n  actions = find_and_use_ingredients(ingredients)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n\n    while count > 0:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n          actions.append(i)\n          count -= 1\n          found = True\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    nonlocal actions\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n    \n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        break\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      # Check inventory before taking action to avoid unnecessary actions\n      inventory = env._current_state.inventory\n      if inventory[required_item] > 0:\n        actions.append(env.world.grabbable_indices.index(required_item))\n        actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    inventory = env._current_state.inventory\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices and inventory[required_item] <= 0:\n          # Find the closest grabbable item to use for crafting\n          distances = [(idx, np.linalg.norm(np.array(env._current_state.pos) - np.array([x, y]))) \n                       for idx, (x, y) in enumerate(env.grabbable_indices.contents) if env.grid[x, y, required_item] > 0]\n          if distances:\n            closest_idx = min(distances, key=lambda x: x[1])[0]\n            actions.append(closest_idx)\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check inventory before taking action to avoid unnecessary actions\n        inventory = env._current_state.inventory\n        if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(env, item_pos):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+ny) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['move'])\n          found = True\n          break\n      if found: break\n    if not found:\n      raise ValueError(\"Item not found in the grid.\")\n\n  recipe = get_recipe(item)\n  if not recipe:\n    return []  # If no recipe, do nothing\n  \n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  for primitive, count in recipe.items():\n    while inventory[primitive] < count:\n      find_and_move_to_item(env, item_pos)\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  def craft_recursive(env, goal_index):\n    ingredients, counts = find_required_ingredients(goal_index)\n    if not ingredients:\n      return []\n    \n    # Pickup all required ingredients\n    for i in range(len(ingredients)):\n      while env._current_state.inventory[ingredients[i]] < counts[i]:\n        actions = pickup_item(env, ingredients[i])\n        env.step(actions[-1], num_steps=1)  # Perform the action and update the state\n    \n    # Craft each ingredient one by one (recursive crafting)\n    for i in range(len(ingredients)):\n      craft_recursive(env, ingredients[i])\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  craft_recursive(env, goal_index)\n  return []", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Implement the crafting logic here\n  # This function should return a list of actions to craft the item\n  # You can use the environment's methods and attributes to assist with this process\n  \n  return []", "occurrence_count": 2}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices and env._current_state.inventory[required_item] > 0:\n      # Check inventory before taking action to avoid unnecessary actions\n      actions.append(env.world.grabbable_indices.index(required_item))\n      actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    if component == \"_key\":  # Skip the key ingredient as it's not a physical item\n      continue\n    \n    # Find the index of the component in the environment's non-grabbable indices\n    component_index = list(env.non_grabbable_indices).index(component)\n    \n    # Add actions to pick up and use the component until the required count is reached\n    for _ in range(count):\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          pickup_action = env._find_pickup_action(primitive)\n          if pickup_action is not None:\n            actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n            inventory[primitive] -= count\n            count = 0\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    while env.inventory[ingredient_index] > 0:\n      action_index = env.grabbable_indices.index(ingredient_index)\n      actions.append(action_index)\n      break\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(item, actions):\n    recipe = get_recipe(item)\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Pick up the item\n          actions.append(env.world.grabbable_indices.index(required_item))\n          # Use the item to craft something\n          actions.append(4)\n  \n  actions = []\n  craft_items(item, actions)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def get_component_actions(env, component_index, count):\n    actions = []\n    for _ in range(count):\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    if component < len(env.non_grabbable_indices):\n      actions.extend(get_component_actions(env, list(env.non_grabbable_indices).index(component), count))\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  # Get the index and required primitives to craft the item\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, find a free grabbable item and use it\n        for i in range(len(env.grabbable_indices)):\n          if env.grid[i] == 0:  # Assuming 0 means the cell is empty or non-grabbable\n            actions.append(i)  # Use the action corresponding to an empty grabbable index\n            break\n      found = True\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      # Try to pick up the ingredient if not enough in inventory\n      actions += pickup_item(env, ingredients[i])\n      env._current_state = env.step(actions[-1])[1]  # Update the state after pickup\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 2}
{"function_body": "  return []", "occurrence_count": 1}
{"function_body": "  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  # While there are items in the required_items dictionary, keep crafting them\n  while required_items:\n    # Find an item with a count greater than zero in the inventory\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Implement the improved crafting logic here\n  return []", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n\n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n\n  def craft_sequence(goal_idx, required_items):\n    actions = []\n    while any(required_items[item] > 0 for item in required_items):\n      for item, count in list(required_items.items()):\n        if count > 0 and item in env.world.primitives:\n          actions.append(env.world.cookbook.index.contents[item])\n          required_items[item] -= 1\n          if required_items[item] == 0:\n            del required_items[item]\n    return actions\n\n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  \n  if goal_idx is None:\n    return []\n\n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = get_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(ingredients)\n  \n  # If any item in the recipe is missing, return an empty list as it's not possible to craft the desired item\n  if len(inventory_counts) != len(ingredients):\n    return []\n\n  # Prepare a dictionary of required items with their counts based on the recipe\n  required_items = {ing: count for ing, count in ingredients.items() if ing in inventory_counts}\n\n  # Generate the sequence of actions to craft the desired item\n  actions = craft_sequence(goal_idx, required_items)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = env.world.primitives\n  actions = []\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        return {env.world.cookbook.index.contents[k]: v for k, v in details.items() if k != \"_key\"}\n    return {}\n\n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n\n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = get_recipe(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your code here.\n\n  return []", "occurrence_count": 1}
{"function_body": "  # Your implementation here!\n  return []", "occurrence_count": 1}
{"function_body": "  # Get the indices and counts for crafting the item from the environment's cookbook.\n  recipe = env.world.cookbook.recipes[item]\n  needed_items = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and its index/argument\n      _, arg = parse_fexp(ingredient)\n      needed_items[arg] = count\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  for item, count in needed_items.items():\n    # Find the items in the inventory that are required for crafting\n    if inventory[item] >= count:\n      # If we have enough of the item, use it up to the count required\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n    else:\n      # Otherwise, try to pick up more items if they are available and not already in inventory\n      item_idx = env.world.cookbook.index.get_by_name(str(item))\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n        # After picking up the item, use it for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n      else:\n        # If we can't pick up or don't have enough items, do nothing for this required item\n        pass\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = next((idx for idx, details in idx_to_item.items() if details == item), None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {env.world.cookbook.index.get(k): k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.get(ing))  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  recipes = env.world.cookbook.recipes[goal_idx]\n  \n  # Check if all necessary items are available in the inventory\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  required_items = {}\n  for ing, count in recipes.items():\n    if ing in inventory and inventory[ing] >= count:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(recipes):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(ing)  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation goes here\n  \n  return []", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Initialize a list to hold actions needed to craft the item\n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Extract the name of the ingredient and its index/argument\n      _, arg = parse_fexp(ingredient)\n      \n      # Check if we have enough of this ingredient in our inventory\n      while env._current_state.inventory[arg] < count:\n        # If not, find the item to pick up (if it's available and not already picked up)\n        item_idx = env.world.cookbook.index.get_by_name(str(arg))\n        if env._current_state.next_to(item_idx) and env._current_state.inventory[item_idx] == 0:\n          # Pick up the ingredient if it's next to us and not in inventory\n          actions.append(env.world.non_grabbable_indices.index(item_idx))\n        else:\n          break  # If we can't pick up or don't have enough items, stop trying to craft the item\n      \n      # Use the ingredient for crafting as many times as needed\n      actions.extend([arg] * count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the target item\n  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  recipe = env.world.cookbook.recipes[item]\n  needed_items = []\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and its index/argument\n      _, arg = parse_fexp(ingredient)\n      needed_items.append((arg, count))\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  for item_idx, count in needed_items:\n    # Find the items in the inventory that are required for crafting\n    if inventory[item_idx] >= count:\n      # If we have enough of the item, use it up to the count required\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n    else:\n      # Otherwise, try to pick up more items if they are available and not already in inventory\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n        # After picking up the item, use it for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n      else:\n        # If we can't pick up or don't have enough items, do nothing for this required item\n        pass\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  \n  # While there are items in the required_items dictionary, keep crafting them\n  while required_items:\n    # Find an item with a count greater than zero in the inventory\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your code here\n  return []", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the environment's recipe book.\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients = env.world.cookbook.recipes[goal_idx]\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the cookbook\n  goal_idx = env.world.cookbook.index.contents.get(item)\n  \n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the recipe for the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  required_items = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  inventory = env.world.primitives\n  \n  # Check if all necessary items are available in the inventory\n  missing_items = {ing: count for ing, count in required_items.items() if ing not in inventory or inventory[ing] < count}\n  \n  if len(missing_items) != len(required_items):\n    return []\n  \n  actions = []\n  while any(required_items[ing] > 0 for ing in required_items):\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    for ingredient, count in recipe.items():\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the list to store actions\n  actions = []\n  \n  # Get the indices and counts for crafting the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  # Iterate over the indices and counts to craft the item\n  for i in range(len(indices)):\n    index = indices[i]\n    count = counts[i]\n    \n    # Check if we have enough of each primitive resource\n    if env.world.inventory[index] >= count:\n      # If we do, use the item (craft it) by adding a USE action for each count\n      actions += [4] * count\n    else:\n      # Otherwise, find out how many are needed and craft them one by one until enough is available\n      needed = count - env.world.inventory[index]\n      while needed > 0:\n        # Find the next most abundant primitive resource that we have at least some of\n        for idx in indices:\n          if env.world.inventory[idx] > 0:\n            actions.append(env.world.cookbook.index.getitem(str(idx)))\n            needed -= 1\n            break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  required_items = {}\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and recipes from the environment's cookbook\n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {idx_to_item[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(idx_to_item[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(goal_idx):\n    ingredients = env.world.cookbook.recipes[goal_idx]\n    return {k: v for k, v in zip(ingredients.keys(), ingredients.values())}\n  \n  # Get the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_items = get_required_items(goal_idx)\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  missing_items = {k: v for k, v in required_items.items() if k not in inventory or inventory[k] == 0}\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(missing_items) != len(required_items):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and counts for crafting the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  # Initialize the list of actions\n  actions = []\n  \n  # Iterate over the indices and counts to craft the item\n  for i in range(len(indices)):\n    index = indices[i]\n    count = counts[i]\n    \n    # Check if we have enough of each primitive resource\n    while env.world.inventory[index] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          break\n    \n    # If we do, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    if not available_items:\n      break\n    \n    most_available_item = max(available_items, key=lambda x: x[1])[0]\n    count_needed = min(recipe[most_available_item], inventory[most_available_item])\n    \n    actions.extend([env.world.grabbable_indices.index(most_available_item)] * count_needed)\n    env._current_state.inventory[most_available_item] -= count_needed\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  # Find the recipe for the given item\n  recipe = get_recipe(item)\n  \n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    if not available_items:\n      break\n    \n    most_available_item = max(available_items, key=lambda x: x[1])[0]\n    count_needed = min(recipe[most_available_item], inventory[most_available_item])\n    \n    actions.extend([env.world.grabbable_indices.index(most_available_item)] * count_needed)\n    env._current_state.inventory[most_available_item] -= count_needed\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    most_available_item = max(available_items, key=lambda x: x[1])[0]\n    count_needed = min(recipe[most_available_item], inventory[most_available_item])\n    \n    for _ in range(count_needed):\n      actions.append(env.world.grabbable_indices.index(most_available_item))\n      env._current_state.inventory[most_available_item] -= 1\n      \n      # Check if the crafted item is available now\n      recipe = get_recipe(item)\n      if all(env._current_state.inventory[ingredient] > 0 for ingredient in recipe):\n        break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        # Pick up the item if it's next to the agent and not already in inventory\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break  # If we can't pick up more items, stop trying\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(items):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for item in items:\n      if item in inventory:\n        found_items.append((item, inventory[item]))\n    return found_items\n  \n  actions = []\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory_counts = find_items_in_inventory(ingredients)\n  \n  while any(count > 0 for _, count in inventory_counts):\n    for ing, count in list(zip(ingredients, counts)):\n      if count > 0 and (ing, count) in inventory_counts:\n        actions.append(ing)\n        idx = ingredients.index(ing)\n        counts[idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  actions = []\n  \n  required_items = {}\n  for ing, count in ingredients.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook's index\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = env.world.primitives\n  actions = []\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n\n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = get_required_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])\n        required_ingredients[ing] -= 1\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = {k: v for k, v in env.world.cookbook.recipes[goal_idx].items() if k in env.world.primitives}\n  inventory_counts = {ing: env.world.primitives[ing] for ing in required_ingredients if ing in env.world.primitives}\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the item is a valid goal and retrieve its recipe\n  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  recipe = env.world.cookbook.recipes[item]\n  needed_items = []\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and its index/argument\n      _, arg = parse_fexp(ingredient)\n      needed_items.append((arg, count))\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  for item_idx, count in needed_items:\n    # Find the items in the inventory that are required for crafting\n    if inventory[item_idx] >= count:\n      # If we have enough of the item, use it up to the count required\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n    else:\n      # Otherwise, try to pick up more items if they are available and not already in inventory\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n        # After picking up the item, use it for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n      else:\n        # If we can't pick up or don't have enough items, do nothing for this required item\n        pass\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in missing.items():\n      while count > 0 and inventory[ingredient] > 0:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n        count -= 1\n    if craftable(inventory, recipe):\n      for ingredient, count in recipe.items():\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -x[1]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = {ingredient: count for ingredient, count in needed_items.items() if env._current_state.next_to(ingredient)}\n    \n    while sum(available_items.values()) > 0 and craftable(inventory, recipe):\n      for ingredient, count in available_items.items():\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n        available_items[ingredient] -= 1\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Sort ingredients by the amount we need to complete the recipe\n    needed_items = sorted([(ingredient, count) for ingredient, count in recipe.items() if inventory[ingredient] < count], key=lambda x: x[1])\n    available_items = [(ingredient, min(count, env._current_state.inventory[ingredient])) for ingredient, count in needed_items]\n    \n    while sum([amount for _, amount in available_items]) > 0:\n      for i, (ingredient, count) in enumerate(available_items):\n        if count > 0:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          available_items[i] = (ingredient, count - 1)\n    \n    # Update the recipe to reflect what's left in the inventory\n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  needed_items = {}\n  \n  # Extract the indices and counts of required ingredients from the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      _, arg = parse_fexp(ingredient)\n      needed_items[arg] = count\n  \n  inventory = env._current_state.inventory\n  actions = []\n\n  # Iterate over the required ingredients and their counts\n  for item, count in needed_items.items():\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    \n    # If we have enough of the item in inventory, use it up to the count required\n    if inventory[item_idx] >= count:\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item)))\n    \n    # Otherwise, try to pick up more items if they are available and not already in inventory\n    elif env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n      # After picking up the item, use it for crafting\n      actions.append(env.world.cookbook.index.get_by_name(str(item)))\n    \n    # If we can't pick up or don't have enough items, do nothing for this required item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Start with an empty list of actions to take\n  actions = []\n  \n  # Find the recipe for the desired item by looking it up in the cookbook's recipes dictionary\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate over each ingredient and its count in the recipe\n  for idx, count in recipe.items():\n    if count == \"_key\":  # If this is a key indicating a primitive resource...\n      index = int(idx)  # Convert the string index to an integer\n      \n      # While we don't have enough of this primitive resource, keep trying to craft it\n      while env.world.inventory[index] < count:\n        actions += [env.world.cookbook.index.getitem(str(index))]  # Add the index action for pickup\n        \n        # If we can't find enough of this primitive resource, add a USE action to craft more (if possible)\n        if env.world.inventory[index] == 0:\n          actions += [4] * count\n          break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts of primitive resources needed for crafting\n  required_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  required_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  # Iterate over the indices and counts to craft the item\n  for i in range(len(required_indices)):\n    index = required_indices[i]\n    count = required_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    while env.world.inventory[index] < count:\n      # If not, find the next most abundant primitive resource that we can use to craft more\n      for idx in required_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          count -= 1\n          break\n    \n    # If we have enough of the resource, use it to craft the item\n    if env.world.inventory[index] >= count:\n      actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts needed to craft the item\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Craft each required primitive resource one by one until enough is available\n  for i in range(len(indices)):\n    index = indices[i]\n    count = counts[i]\n    \n    while env.world.inventory[index] < count:\n      actions.append(env.world.cookbook.index.getitem(str(index)))\n  \n  # Use the crafted items to make the desired item\n  for _ in range(len(indices)):\n    actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Define a helper function to find the most abundant primitive resource we have at least some of\n  def most_abundant_resource(needed_resources):\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  # Extract indices and counts for crafting from the recipe\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for _, count in needed_resources:\n    while env.world.inventory[needed_resources[0][0]] < count:\n      most_abundant = most_abundant_resource(needed_resources)\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not most_abundant:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      idx, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[needed_resources[0][0]]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # Prioritize picking up items that are exactly what is needed or part of the recipe\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        # Pick up the item if it's next to the agent and not already in inventory\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break  # If we can't pick up more items, stop trying\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # Sort items by priority based on their indices in the recipe (higher indices have higher priority)\n  sorted_needed_items = sorted(needed_items.keys(), key=lambda x: env.world.cookbook.index[x], reverse=True)\n  \n  for item_idx in sorted_needed_items:\n    while inventory[item_idx] < needed_items[item_idx]:\n      if can_pickup_item(item_idx):\n        # Pick up the item if it's next to the agent and not already in inventory\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break  # If we can't pick up more items, stop trying\n    use_item_for_crafting(item_idx, needed_items[item_idx] - inventory[item_idx])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  # Initialize the list of actions (empty for now)\n  actions = []\n\n  # Use the ingredients in reverse order to find them and craft the final product\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # First gather all required items and pick them up if possible\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break\n  \n  # Then use the items for crafting\n  for item_idx, count in needed_items.items():\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # Prioritize items that are already in the inventory but not enough to craft the desired item\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        # Pick up the item if it's next to the agent and not already in inventory\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break  # If we can't pick up more items, stop trying\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Function to find the indices and counts for crafting a specific item from its recipe\n  def get_required_resources(recipe):\n    required = {}\n    for idx, count in recipe.items():\n      if count == \"_key\":\n        required[idx] = required.get(idx, 0) + 1\n    return required\n  \n  # Get the crafting recipe for the given item index\n  recipe = env.world.cookbook.recipes[item]\n  required_resources = get_required_resources(recipe)\n  \n  actions = []\n  \n  # Iterate over each required resource and its count\n  for idx, count in required_resources.items():\n    available_count = env.world.inventory[idx]\n    \n    if available_count >= count:\n      # If we have enough of the resource, use it by adding a USE action for each count\n      actions += [4] * count\n    else:\n      # Otherwise, craft as many as possible and then continue crafting until enough is available\n      crafted = 0\n      while crafted < count and env.world.inventory[idx] > 0:\n        actions.append(env.world.cookbook.index.getitem(str(idx)))\n        crafted += 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_needed_resources():\n    recipe = env.world.cookbook.recipes[item]\n    needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n    needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n    return needed_indices, needed_counts\n\n  def get_available_resources():\n    inventory = env.world.inventory\n    available_indices = [idx for idx in range(len(inventory)) if inventory[idx] > 0]\n    available_counts = [inventory[idx] for idx in available_indices]\n    return available_indices, available_counts\n\n  needed_indices, needed_counts = get_needed_resources()\n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  while any(env.world.inventory[idx] < count for idx, count in zip(needed_indices, needed_counts)):\n    available_indices, available_counts = get_available_resources()\n    \n    for i, (needed_index, needed_count) in enumerate(zip(needed_indices, needed_counts)):\n      if env.world.inventory[needed_index] < needed_count:\n        # If we need more of this resource and don't have enough, find out how many are still needed\n        to_craft = needed_count - env.world.inventory[needed_index]\n        \n        # Find the next most abundant primitive resource that we can use to craft more\n        for available_index in available_indices:\n          if env.world.inventory[available_index] > 0:\n            actions.append(env.world.cookbook.index.getitem(str(available_index)))\n            to_craft -= 1\n            break\n  \n  # If we have enough of the resource, use it to craft the item\n  for idx in needed_indices:\n    if env.world.inventory[idx] >= min(needed_counts):\n      actions += [4] * min(needed_counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(item):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    items = [ing for ing, count in inventory.items() if ing == item]\n    return items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    found = False\n    for ing, count in list(zip(ingredients, counts)):\n      items_in_inventory = find_items_in_inventory(ing)\n      if len(items_in_inventory) >= count and all(items_in_inventory):\n        actions.extend([ing] * min(counts))\n        counts = [max(0, c - 1) for c in counts]\n        found = True\n    \n    if not found:\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(items):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    return [ing for ing in items if ing in inventory]\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = find_items_in_inventory(ingredients)\n  \n  while any(counts):\n    for ing, count in list(zip(ingredients, counts)):\n      if count > 0 and ing in inventory:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n    \n    ingredients = [ing for ing in ingredients if ing not in actions]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = {k: v for k, v in env.world.cookbook.recipes[goal_idx].items() if k != \"_key\"}\n  inventory_counts = {ing: env.world.primitives[ing] for ing in required_ingredients}\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        # Find the action to use the item from the inventory\n        action = env.world.cookbook.index.contents[ing]\n        actions.append(action)\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[arg] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while inventory[int(item)] < count:\n      pick_up_item(int(item))\n    use_item_for_crafting(item)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[arg] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while inventory[int(item)] < count:\n      pick_up_item(int(item))\n      use_item_for_crafting(item)\n    use_item_for_crafting(item)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in missing.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    \n    # Craft the item\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # First gather all required items and pick them up if possible\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break\n  \n  # Then use the items for crafting\n  for item_idx, count in needed_items.items():\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # Iterate over the required ingredients and their counts\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break\n  \n  # Iterate over the required ingredients and their counts again to use them for crafting\n  for item_idx, count in needed_items.items():\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  # Initialize the list of actions (empty for now)\n  actions = []\n\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Filter out only those ingredients that are not in inventory yet\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\" and env.world.inventory[idx] < 1]\n  \n  actions = []\n  \n  # For each resource needed but not in inventory, find a way to acquire or use it\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in recipe.items() if env.world.inventory[ridx] > 0 and count <= env.world.inventory[ridx]]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(count, inventory[ingredient])\n    \n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(inventory[ingredient] // count, recipe[ingredient])\n    \n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -x[1]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal item in the cookbook\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  actions = []\n  \n  required_items = {}\n  for ing, count in ingredients.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory():\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing, count in counts.items():\n      if ing in inventory and inventory[ing] >= count:\n        found_items.append((ing, count))\n    return found_items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    found_items = find_items_in_inventory()\n    if not found_items:\n      break\n    \n    for ing, count in found_items:\n      actions.append(ing)\n      counts[ingredients.index(ing)] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  def craft_item():\n    nonlocal actions\n    ingredients, counts = get_recipe(goal_idx)\n    found_items = find_items_in_inventory(ingredients)\n    \n    for ing, count in found_items:\n      while inventory[ing] > 0 and count > 0:\n        actions.append(env.world.cookbook.index.contents[ing])\n        counts[ingredients.index(ing)] -= 1\n  \n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  actions = []\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  craft_item()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(item):\n    idx = env.world.cookbook.index.get(item)\n    if idx is None or idx not in env.world.cookbook.recipes:\n      return []\n    ingredients = env.world.cookbook.recipes[idx]\n    return {env.world.cookbook.index.get(ing): ing for ing in ingredients}\n  \n  def has_ingredients(required_items):\n    inventory = env.world.primitives\n    return all(inventory.get(item, 0) >= count for item, count in required_items.items())\n  \n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  goal_idx = next((idx for idx, details in idx_to_item.items() if details == item), None)\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  ingredient_names = get_ingredients(goal_idx)\n  required_items = {ing: count for ing, count in ingredient_names.items() if has_ingredients({ing: count})}\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in env.world.primitives and env.world.primitives[ing] > 0:\n        actions.append(env.world.cookbook.index.get(ing))\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Define the function to get the index of an item in the world's recipe output list.\n  def get_item_index():\n    return next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  \n  goal_idx = get_item_index()\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  def get_ingredient_names():\n    return {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  ingredient_names = get_ingredient_names()\n  \n  # Check if all necessary items are available in the inventory\n  def check_inventory(required_items):\n    inventory = env.world.primitives\n    return {ing: count for ing, count in required_items.items() if ing in inventory and inventory[ing] > 0}\n  \n  required_items = check_inventory(ingredient_names)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.get(ing))  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index():\n    for idx, details in env.world.cookbook.index.contents.items():\n      if details == item:\n        return idx\n    return None\n  \n  goal_idx = get_item_index()\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  \n  required_items = {}\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.get(ing))  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index():\n    for idx, details in env.world.cookbook.index.contents.items():\n      if details == item:\n        return idx\n    return None\n  \n  goal_idx = get_item_index()\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  def get_ingredient_names():\n    inventory = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n    return inventory\n  \n  required_items = get_ingredient_names()\n  \n  # Check if all necessary items are available in the inventory\n  def check_inventory():\n    inventory = env.world.primitives\n    return {ing: count for ing, count in required_items.items() if ing in inventory and inventory[ing] > 0}\n  \n  inventory_check = check_inventory()\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(inventory_check) != len(required_items):\n    return []\n  \n  actions = []\n  \n  while inventory_check:\n    for ing, count in list(inventory_check.items()):\n      if count > 0 and ing in env.world.primitives and env.world.primitives[ing] > 0:\n        actions.append(env.world.cookbook.index.get(ing))  # Append the action to use the item from the inventory\n        inventory_check[ing] -= 1  # Decrease the count of the used item\n        \n        if inventory_check[ing] == 0:\n          del inventory_check[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def can_pickup_item(item_idx):\n    # Check if the item is next to the agent and not already in inventory\n    return env._current_state.next_to(item_idx) and env._current_state.inventory[item_idx] == 0\n  \n  def use_item_for_crafting(item_idx, count):\n    for _ in range(count):\n      actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0 and inventory[item_idx] < count:\n      if can_pickup_item(item_idx):\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      else:\n        break\n  \n  for item_idx, count in needed_items.items():\n    use_item_for_crafting(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(inventory):\n    for i in range(len(inventory)):\n      if inventory[i] > 0:\n        return i\n    return None\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  # Initialize the list of actions (empty for now)\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient(env.state.inventory)\n    if ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in ingredients}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = env.world.primitives\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Unknown item index\")\n  \n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the actions list to store all the actions needed to craft the item\n  actions = []\n\n  # Get the recipe for the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check how many of this primitive resource we currently have\n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, craft it by gathering until we reach the required amount\n    while available_count < count:\n      actions += [env.world.cookbook.index.getitem(str(index))]  # Gather more of this primitive resource\n      available_count += 1\n    \n    # If we have enough, craft it by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i, count in recipe.items() if env.state.inventory[i] == 0]\n\n  def find_closest_ingredient(ingredients):\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, min_distance\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while ingredients:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient_index():\n    cookbook = env.world.cookbook\n    goal_idx = cookbook.index.get(item)\n    if goal_idx is None:\n      raise ValueError(\"Unknown item to craft\")\n    \n    # Check if we have any recipes that can produce this item\n    recipe = cookbook.primitives_for(goal_idx)\n    if not recipe:\n      return None\n\n    for ingredient_index, count in recipe.items():\n      if env.state.inventory[ingredient_index] == 0 and np.any(env.state.grid == ingredient_index):\n        ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n        rel_pos = ingredient_pos - env.state.pos\n        if np.all(np.abs(rel_pos) <= 1):\n          return ingredient_index, rel_pos\n    return None\n\n  actions = []\n  \n  while True:\n    ingredient_info = find_ingredient_index()\n    if not ingredient_info:\n      break\n    \n    ingredient_index, rel_pos = ingredient_info\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the item is known in the world's cookbook\n  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Unknown item index\")\n  \n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Unknown item index\")\n  \n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in sorted(missing.items(), key=lambda x: env._current_state.inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    # Craft the item if possible\n    recipe = get_recipe(item)\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in sorted(missing.items(), key=lambda x: env._current_state.inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    \n    # Craft the item\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    \n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(count, inventory[ingredient])\n    \n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      env._current_state = env.step(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(count, inventory[ingredient])\n    \n    # Find the most efficient combination of actions to craft the items in the recipe\n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.recipes.get(goal, {})\n  \n  def required_items(recipe):\n    items = {}\n    for key, value in recipe.items():\n      if isinstance(key, int) and value > 0:\n        items[key] = value\n    return items\n  \n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  recipe = get_recipe(goal_idx)\n  required = required_items(recipe)\n  \n  inventory = {k: v for k, v in zip(env.world.primitives.keys(), env.inventory) if v > 0}\n  \n  actions = []\n  while any(required.values()):\n    found = False\n    for ing, count in list(required.items()):\n      if count > 0 and ing in inventory:\n        actions.append(ing)\n        required[ing] -= 1\n        found = True\n    \n    if not found:\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(required_items):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    items_found = {}\n    for ing, count in required_items:\n      found_item = next((inv_ing for inv_ing, inv_count in inventory.items() if inv_ing == ing and inv_count >= count), None)\n      if found_item is not None:\n        items_found[found_item] = min(inventory[found_item], count)\n    return items_found\n  \n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  required_items = list(zip(ingredients, counts))\n  \n  actions = []\n  while any(counts):\n    items_found = find_items_in_inventory(required_items)\n    \n    for ing, count in required_items:\n      if count > 0 and ing in items_found:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n        required_items = [(i, c - (c == 1)) for i, c in required_items]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Implement the improved crafting logic here\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  \n  while True:\n    ingredients = [i for i, count in cookbook.primitives_for(goal_idx).items() if env.state.inventory[i] == 0]\n    \n    if not ingredients:\n      break\n    \n    closest_ingredient = min(ingredients, key=lambda x: np.sum(np.abs(np.argwhere(env.state.grid == x) - env.state.pos)))\n    closest_pos = np.argwhere(env.state.grid == closest_ingredient)[0]\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if not np.any(np.abs(rel_pos) > 1):\n      actions.append(4)  # USE action\n      continue\n    \n    actions += [direction] * abs(rel_pos[direction])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  actions = []\n  while True:\n    required_ingredients = get_required_ingredients(goal_idx)\n    inventory_counts = get_inventory_counts(required_ingredients)\n    \n    # If any item is missing, break the loop as it's not possible to craft the desired item\n    if len(required_ingredients) != len(inventory_counts):\n      break\n    \n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    if item in env.world.cookbook.recipes:\n      return env.world.cookbook.recipes[item]\n    else:\n      return {}\n\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  recipe = get_recipe(goal_idx)\n  actions = []\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n\n  while any(recipe.values()):\n    found = False\n    for ingredient, count in recipe.items():\n      if count > 0 and inventory.get(ingredient, 0) > 0:\n        actions.append(ingredient)\n        recipe[ingredient] -= 1\n        found = True\n    \n    if not found:\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_needed_resources(recipe):\n    needed_indices = []\n    needed_counts = []\n    for idx, count in recipe.items():\n      if count == \"_key\":\n        needed_indices.append(idx)\n        needed_counts.append(1)  # Assuming each primitive resource is required once per craftable item\n    return needed_indices, needed_counts\n\n  def craft_item(env, index):\n    recipe = env.world.cookbook.recipes[index]\n    needed_indices, needed_counts = get_needed_resources(recipe)\n    \n    for idx, count in zip(needed_indices, needed_counts):\n      while env.world.inventory[idx] < count:\n        # Find the next most abundant primitive resource that we have at least some of\n        for i_kind in range(len(env.world.non_grabbable_indices)):\n          if env.world.inventory[i_kind] > 0:\n            actions.append(i_kind)\n            env.world.inventory[i_kind] -= 1\n            break\n    \n    # Craft the item using USE actions for each count\n    for _ in range(count):\n      actions.append(4)\n\n  recipe = env.world.cookbook.recipes[item]\n  needed_indices, needed_counts = get_needed_resources(recipe)\n  \n  actions = []\n  for idx, count in zip(needed_indices, needed_counts):\n    craft_item(env, idx)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = {ingredient: count for ingredient, count in needed_items.items() if env._current_state.next_to(ingredient)}\n    \n    while sum(available_items.values()) > 0:\n      for ingredient, count in available_items.items():\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n        available_items[ingredgent] -= 1\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(item_name):\n    for idx, name in env.world.cookbook.index.contents.items():\n      if name == item_name:\n        return idx\n    return None\n\n  goal_idx = get_item_index(item)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = env.world.cookbook.recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  \n  actions = []\n  required_items = {}\n  \n  for ing, count in ingredients.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and inventory[ing] > 0:\n        actions.append(get_item_index(ing))  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  ingredients = recipes[goal_idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = env.world.primitives\n  actions = []\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n    for ingredient in sorted_ingredients:\n      while inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  \n  while sum(env._current_state.inventory[i] for i in recipe) > 0:\n    for ingredient, count in sorted(recipe.items(), key=lambda x: env._current_state.inventory[x[0]], reverse=True):\n      if env._current_state.inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Start from the goal and work backwards to find all required components.\n  indices = [item]\n  requirements = {}\n  while len(indices) > 0:\n    current = indices.pop()\n    if current not in requirements:\n      requirements[current] = env.world.cookbook.primitives_for(current)\n    for k, v in requirements[current].items():\n      if k not in requirements:\n        requirements[k] = {}\n        # Add the required components to indices list to check their requirements recursively.\n        indices.append(k)\n  \n  # Now craft each item in reverse order of requirement from least to most complex.\n  actions = []\n  for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n    if all(env.world.cookbook.primitives_for(key).values()):\n      continue  # Skip items that are already crafted or can be directly grabbed.\n    for k, v in value.items():\n      actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    for ingredient, count in reversed(list(recipe.items())):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # While we don't have enough of this primitive resource, keep trying to pick it up or use it if already picked up\n    while env.world.inventory[index] < count:\n      actions.append(env.world.cookbook.index.getitem(str(index)))  # Add the index action for pickup\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    if env.world.inventory[index] >= count:\n      actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the next most abundant primitive resource that we have at least some of and add a pickup action for it\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # Use the item (craft it) by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  def craft_item():\n    nonlocal actions, counts\n    while any(counts):\n      found_items = find_items_in_inventory(ingredients)\n      if not found_items:\n        break\n      \n      for ing, count in found_items:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  craft_item()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Sort ingredients by the amount we need to complete the recipe and available in inventory\n    needed_items = sorted([(ingredient, count) for ingredient, count in recipe.items() if inventory[ingredient] < count], key=lambda x: x[1])\n    available_items = [(ingredient, min(count, env._current_state.inventory[ingredient])) for ingredient, count in needed_items]\n    \n    while sum([amount for _, amount in available_items]) > 0:\n      # Pick up the items we need most urgently first\n      for i, (ingredient, count) in enumerate(available_items):\n        if count > 0:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          available_items[i] = (ingredient, count - 1)\n    \n    # Update the recipe to reflect what's left in the inventory\n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Sort ingredients by the amount we need to complete the recipe\n    needed_items = sorted([(ingredient, count) for ingredient, count in recipe.items() if inventory[ingredient] < count], key=lambda x: x[1])\n    available_items = [(ingredient, min(count, env._current_state.inventory[ingredient])) for ingredient, count in needed_items]\n    \n    # Pick up items until we have enough to craft the item\n    while sum([amount for _, amount in available_items]) > 0:\n      for i, (ingredient, count) in enumerate(available_items):\n        if count > 0:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          available_items[i] = (ingredient, count - 1)\n    \n    # Update the recipe to reflect what's left in the inventory\n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Create a list of tuples where each tuple contains the index of the ingredient and its required quantity for crafting\n  craft_list = [(env.world.grabbable_indices.index(ingredient), count) for ingredient, count in recipe.items()]\n\n  while sum(inventory[i] for i, _ in craft_list) > 0:\n    # Find the most abundant ingredients first and craft them\n    crafted = False\n    for idx, (ingredient, count) in enumerate(craft_list):\n      if inventory[ingredient] >= count:\n        actions.append(idx)\n        inventory = env._current_state.inventory\n        # After crafting the ingredients, we need to re-sort the craft list based on the updated inventory\n        craft_list = [(env.world.grabbable_indices.index(ingredient), count) for ingredient, count in recipe.items()]\n        crafted = True\n        break\n    if not crafted:\n      break  # If no more items can be crafted, we stop crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_needed_resources():\n    recipe = env.world.cookbook.recipes[item]\n    needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n    return needed_resources\n  \n  actions = []\n  \n  for idx, count in get_needed_resources():\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in get_needed_resources() if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Check what we already have and plan the rest to acquire\n  inventory_counts = np.array([env.world.inventory[idx] for idx in indices])\n  needed_counts = np.max(recipe.values()) - inventory_counts\n  \n  for needed, count in zip(indices, needed_counts):\n    while env.world.inventory[needed] < count:\n      actions.append(env.world.cookbook.index.getitem(str(needed)))\n  \n  # Use the crafted items to make the desired item\n  for _ in range(len(indices)):\n    actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  def craft_item():\n    nonlocal actions, counts\n    while any(counts):\n      found_items = find_items_in_inventory(ingredients)\n      if not found_items:\n        break\n      \n      for ing, count in found_items:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n  \n  def use_item():\n    nonlocal actions, counts\n    while any(counts):\n      found_items = find_items_in_inventory(ingredients)\n      if not found_items:\n        break\n      \n      for ing, count in found_items:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  craft_item()\n  use_item()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  def craft_item():\n    nonlocal actions, counts\n    while any(counts):\n      found_items = find_items_in_inventory(ingredients)\n      if not found_items:\n        break\n      \n      for ing, count in found_items:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n  \n  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  craft_item()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = env.world.cookbook.recipes[goal_idx]\n    required_ingredients = {ing: count for ing, count in ingredients.items() if ing != \"_key\"}\n    return required_ingredients\n  \n  def get_inventory_counts(required_ingredients):\n    inventory_counts = {}\n    for ing, count in list(required_ingredients.items()):\n      idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == ing), None)\n      if idx is not None and idx in env.world.primitives:\n        inventory_counts[ing] = min(env.world.primitives[idx], count)\n    return inventory_counts\n  \n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  actions = []\n  while True:\n    required_ingredients = get_required_ingredients(goal_idx)\n    inventory_counts = get_inventory_counts(required_ingredients)\n    \n    # If any item is missing, break the loop as it's not possible to craft the desired item\n    if len(required_ingredients) != len(inventory_counts):\n      break\n    \n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_ingredients[ing] -= inventory_counts[ing]  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients = env.world.cookbook.recipes[goal_idx]\n  inventory = {k: v for k, v in enumerate(env.inventory)}\n  actions = []\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  for ing, count in ingredients.items():\n    if ing != \"_key\" and count > 0 and inventory[ing] > 0:\n      actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook.index\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  recipe = env.world.cookbook.recipes[goal_idx]\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in recipe}\n  \n  # Check if all necessary items are available in the inventory\n  inventory = {k: v for k, v in env.world.primitives.items() if v > 0}\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = count\n    \n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while required_items:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Extract indices and counts for crafting from the recipe\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Function to pick up resources until enough are available\n  def pick_up_resource(needed_resources):\n    for ridx, rcount in needed_resources:\n      while env.world.inventory[ridx] < rcount:\n        most_abundant = max([(env.world.cookbook.index.getitem(str(ridx)), rcount) if env.world.inventory[ridx] > 0 else (None, 0) for ridx in recipe], key=lambda x: x[1])\n        if most_abundant[0] is not None:\n          actions.append(most_abundant[0])\n          rcount -= env.world.inventory[ridx]\n  \n  # Pick up all needed resources for crafting\n  pick_up_resource(needed_resources)\n  \n  # Craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n  \n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n  \n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  required_ingredients = get_required_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  \n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        action = idx_to_item[ing]\n        actions.append(action)\n        required_ingredients[ing] -= 1\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(goal_idx):\n    ingredients = {}\n    for output, details in env.world.cookbook.recipes.items():\n      if output == goal_idx:\n        for ingredient, count in details.items():\n          ingredients[ingredient] = count\n    return ingredients\n  \n  def get_inventory_counts(ingredients):\n    inventory_counts = {ing: env.world.primitives[ing] for ing in ingredients if ing in env.world.primitives}\n    return inventory_counts\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  required_ingredients = get_required_ingredients(goal_idx)\n  inventory_counts = get_inventory_counts(required_ingredients)\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_ingredients) != len(inventory_counts):\n    return []\n  \n  actions = []\n  \n  while required_ingredients:\n    for ing, count in list(required_ingredients.items()):\n      if count > 0 and inventory_counts[ing] > 0:\n        # Find the action to use the item from the inventory\n        action = env.world.cookbook.index.contents[ing]\n        actions.append(action)\n        required_ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_ingredients dictionary\n        if required_ingredients[ing] == 0:\n          del required_ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe where count is \"_key\"\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    available_count = env.world.inventory[index]\n    if available_count >= count:\n      # If we have enough, use the item (craft it) by adding a USE action for each count\n      actions += [4] * count\n    else:\n      # Otherwise, find out how many are needed and craft them one by one until enough is available\n      needed = count - available_count\n      while needed > 0:\n        # Find the next most abundant primitive resource that we have at least some of\n        for idx in needed_indices:\n          if env.world.inventory[idx] > 0:\n            actions.append(env.world.cookbook.index.getitem(str(idx)))\n            needed -= 1\n            break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.recipes[goal_idx]\n    return {k: v for k, v in recipe.items()}\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients = get_ingredients(goal_idx)\n  inventory = {k: v for k, v in env.world.primitives.items() if v > 0}\n  \n  actions = []\n  while ingredients:\n    # Find an item with a count greater than zero in the inventory that is also required\n    for ing, count in list(ingredients.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        ingredients[ing] -= 1  # Decrease the count of the used item\n        \n        # If the count reaches zero, remove it from the required_items dictionary\n        if ingredients[ing] == 0:\n          del ingredients[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    recipe = env.world.cookbook.recipes.get(goal_idx, {})\n    return {env.world.cookbook.index.contents[k]: k for k in recipe}\n\n  idx_to_item = env.world.cookbook.index.contents\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  recipe = get_recipe(goal_idx)\n  \n  # Check if all necessary items are available in the inventory\n  inventory = {k: v for k, v in env.world.primitives.items() if v > 0}\n  \n  actions = []\n  for ing, count in recipe.items():\n    while count > 0 and ing in inventory and inventory[ing] > 0:\n      actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n      inventory[ing] -= 1\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while not craftable(inventory, get_recipe(item)):\n    needed_items = {ingredient: count for ingredient, count in get_recipe(item).items() if inventory[ingredient] < count}\n    available_items = {ingredient: count for ingredient, count in needed_items.items() if env._current_state.next_to(ingredient)}\n    \n    while sum(available_items.values()) > 0 and not craftable(inventory, get_recipe(item)):\n      for ingredient, count in available_items.items():\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n        available_items[ingredient] -= 1\n    \n    if not craftable(inventory, get_recipe(item)):\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0 and craftable(inventory, recipe):\n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = {ingredient: count for ingredient, count in needed_items.items() if env._current_state.next_to(ingredient)}\n    \n    while sum(available_items.values()) > 0 and craftable(inventory, recipe):\n      sorted_needed = sorted(needed_items.keys(), key=lambda x: inventory[x])\n      for ingredient in sorted_needed:\n        if available_items.get(ingredient, 0) > 0 and env._current_state.next_to(ingredient):\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          available_items[ingredient] -= 1\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the desired item\n  recipe = env.world.cookbook.recipes[goal_idx]\n  \n  # Check if all necessary items are available in the inventory\n  inventory = {ing: count for ing, count in zip(env.world.cookbook.index.contents, env.inventory) if count > 0}\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  required_items = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int) and inventory.get(ingredient, 0) >= count:\n      required_items[ingredient] = count\n  \n  # If any item is missing, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(recipe):\n    return []\n  \n  actions = []\n  while required_items:\n    for ingredient, count in list(required_items.items()):\n      if count > 0 and ingredient in inventory:\n        actions.append(ingredient)\n        env.inventory[ingredient] -= 1\n        required_items[ingredient] -= 1\n        if required_items[ingredient] == 0:\n          del required_items[ingredient]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] >= counts[ingredients.index(ing)]:\n        found_items.append((ing, counts[ingredients.index(ing)]))\n    return found_items\n  \n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  actions = []\n  ingredients, counts = get_recipe(goal_idx)\n  found_items = find_items_in_inventory(ingredients)\n  \n  for ing, count in found_items:\n    while env.inventory[ing] > 0 and count > 0:\n      actions.append(env.world.cookbook.index.contents[ing])\n      counts[ingredients.index(ing)] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    # Sort ingredients by the number of items available, starting from the most abundant\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    \n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        crafted = True\n        break  # Break after crafting one ingredient to prioritize the most abundant ones first\n    \n    if not crafted:\n      break  # If no ingredients can be crafted, stop trying to craft\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    craftable = True\n    for ingredient, count in recipe.items():\n      if inventory[ingredient] < count:\n        craftable = False\n        break\n    if not craftable:\n      break\n    for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: -x[1])\n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        recipe = get_recipe(item)  # Update the recipe based on updated inventory\n        crafted = True\n        break\n    if not crafted:\n      break  # If no more items can be crafted, we stop crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts needed from the recipe\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  counts = np.array([recipe[str(idx)] for idx in indices])\n  \n  # Check what we already have and plan the rest to acquire\n  inventory_counts = np.array([env.world.inventory[idx] for idx in indices])\n  needed_counts = counts - inventory_counts\n  \n  actions = []\n  \n  # Plan the acquisition of each needed item\n  for needed, count in zip(indices, needed_counts):\n    while env.world.inventory[needed] < count:\n      actions.append(env.world.cookbook.index.getitem(str(needed)))\n  \n  # Use the crafted items to make the desired item\n  for _ in range(len(indices)):\n    actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your code here!\n\n  return []", "occurrence_count": 1}
{"function_body": "  def find_needed_resources(env, recipe):\n    needed = {}\n    for idx, count in recipe.items():\n      if count == \"_key\":\n        ridx = int(idx)\n        needed[ridx] = needed.get(ridx, 0) + 1\n    return needed\n\n  def find_available_resources(env, needed):\n    available = {}\n    for idx, count in needed.items():\n      if env.world.inventory[idx] > 0:\n        available[idx] = min(count, env.world.inventory[idx])\n    return available\n\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = find_needed_resources(env, recipe)\n  actions = []\n\n  while not all(env.world.inventory[idx] >= count for idx, count in needed_resources.items()):\n    available_resources = find_available_resources(env, needed_resources)\n    if not available_resources:\n      break\n    \n    # Pick up the resource with the highest need (or any one of them if they are equally abundant)\n    idx_to_pickup = max(needed_resources.items(), key=lambda x: x[1] - env.world.inventory[x[0]])[0]\n    actions.append(env.world.cookbook.index.getitem(str(idx_to_pickup)))\n    \n    # Decrease the needed count based on what we have in inventory\n    needed_resources[idx_to_pickup] -= 1\n\n  if all(env.world.inventory[idx] >= count for idx, count in needed_resources.items()):\n    actions = [4] * sum(needed_resources.values())\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe to craft the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource():\n    # Find the index of the resource with the highest count in inventory that is needed for crafting\n    available_resources = [(idx, env.world.inventory[idx]) for idx, _ in env.world.cookbook.recipes[item].items() if env.world.inventory[idx] > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  # Extract indices and counts for crafting from the recipe\n  needed_indices = [idx for idx, count in env.world.cookbook.recipes[item].items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  while any(env.world.inventory[idx] < count for idx, count in env.world.cookbook.recipes[item].items() if count == \"_key\"):\n    most_abundant = most_abundant_resource()\n    \n    # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n    if not most_abundant:\n      break\n    \n    # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n    idx, _ = most_abundant\n    actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n    env.world.inventory[idx] -= 1  # Decrease the inventory count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_indices) == len(actions):\n    actions = [4] * sum([count for idx, count in env.world.cookbook.recipes[item].items() if count == \"_key\"])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  def most_abundant_resource():\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for _, count in needed_resources:\n    while env.world.inventory[needed_resources[0][0]] < count:\n      most_abundant = most_abundant_resource()\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not most_abundant:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      idx, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[needed_resources[0][0]]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    # Sort by the minimum of (remaining needed, current inventory) to prioritize most needed ingredients first\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: min(x[1], inventory[x[0]]))\n    \n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check how many of this primitive resource we currently have\n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, gather more until we reach the required amount\n    if available_count < count:\n      actions += [env.world.cookbook.index.getitem(str(index))] * (count - available_count)\n    \n    # Add a USE action for each count of this primitive resource needed to craft the item\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [int(idx) for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check how many of this primitive resource we currently have\n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, craft it by gathering until we reach the required amount\n    while available_count < count:\n      actions += [env.world.cookbook.index.getitem(str(index))]  # Gather more of this primitive resource\n      available_count = env.world.inventory[index]\n    \n    # If we have enough, craft it by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Unknown item index\")\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n\n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check if we have enough of each primitive resource\n    available_count = env.world.inventory[index]\n    while available_count < count:\n      # Find the most abundant primitive resource that we can use to craft more of the required resource\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0 and idx != index:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          available_count += 1\n          break\n    \n    # If we have enough of the primitive resource, use the item (craft it) by adding a USE action for each count\n    actions += [4] * min(available_count, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource():\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in env.world.inventory if rcount > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n  \n  # Check if the item is known and has a recipe\n  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Unknown item index\")\n  \n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed resources to craft the item\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      most_abundant = most_abundant_resource()\n      \n      if not most_abundant:\n        break\n      \n      # If we find a resource with at least some count available, pick it up and use it towards crafting the item\n      _, idx_to_pickup = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx_to_pickup)))\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n    \n    if len(needed_resources) == len(actions):\n      actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal item in the cookbook\n  idx = None\n  for i, details in env.world.cookbook.index.contents.items():\n    if details == item:\n      idx = i\n      break\n  \n  # If the goal item is not found or has no recipe, return an empty list\n  if idx is None or idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients required to craft the desired item\n  ingredients = env.world.cookbook.recipes[idx]\n  \n  # Convert ingredient indices to names using idx_to_item dictionary\n  inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n  actions = []\n  \n  required_items = {}\n  for ing, count in ingredients.items():\n    if ing in inventory and inventory[ing] > 0:\n      required_items[ing] = count\n    \n  # If any item is missing from the inventory, return an empty list as it's not possible to craft the desired item\n  if len(required_items) != len(ingredients):\n    return []\n  \n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])  # Append the action to use the item from the inventory\n        required_items[ing] -= 1  # Decrease the count of the used item\n        \n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(item):\n    idx = env.world.cookbook.index.get(item)\n    if idx is None or idx not in env.world.cookbook.recipes:\n      return []\n    ingredients = env.world.cookbook.recipes[idx]\n    inventory = {env.world.cookbook.index.contents[k]: k for k in env.world.primitives}\n    required_items = {}\n    for ing, count in ingredients.items():\n      if ing in inventory:\n        required_items[ing] = count\n    return required_items\n  \n  def has_ingredients(required_items):\n    inventory = env.world.primitives\n    return all(inventory.get(item, 0) >= count for item, count in required_items.items())\n  \n  idx_to_item = env.world.cookbook.index.contents\n  recipes = env.world.cookbook.recipes\n  \n  goal_idx = next((idx for idx, details in idx_to_item.items() if details == item), None)\n  if goal_idx is None or goal_idx not in recipes:\n    return []\n  \n  ingredient_names = get_ingredients(goal_idx)\n  required_items = {ing: count for ing, count in ingredient_names.items() if has_ingredients({ing: count})}\n  \n  actions = []\n  while required_items:\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in env.world.primitives and env.world.primitives[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook's index\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  \n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[goal_idx]\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in recipe if isinstance(k, int)}\n  \n  # Check and filter items from inventory that are available and required\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  inventory_items = []\n  for ing, count in ingredient_names.items():\n    if ing in inventory and inventory[ing] > 0:\n      inventory_items.append((ing, min(inventory[ing], count)))\n  \n  # If any required item is not available, return an empty list\n  if len(inventory_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  for ing, count in inventory_items:\n    while count > 0:\n      actions.append(ing)\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook's index\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  \n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  # Get the ingredients and their counts required to craft the item from the recipe\n  recipe = env.world.cookbook.recipes[goal_idx]\n  ingredient_names = {env.world.cookbook.index.contents[k]: k for k in recipe}\n  \n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  # Find which ingredients are available in the inventory and their counts\n  required_items = {}\n  for ing, count in ingredient_names.items():\n    if ing in inventory:\n      required_items[ing] = min(count, inventory[ing])\n    \n  if len(required_items) != len(ingredient_names):\n    return []\n  \n  actions = []\n  while any(required_items.values()):\n    for ing, count in list(required_items.items()):\n      if count > 0 and ing in inventory and inventory[ing] > 0:\n        actions.append(env.world.cookbook.index.contents[ing])\n        required_items[ing] -= 1\n        if required_items[ing] == 0:\n          del required_items[ing]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.get_by_name(str(item_idx)))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0:\n      if inventory[item_idx] < count:\n        pick_up_item(item_idx)\n      else:\n        use_item_for_crafting(item_idx)\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(inventory):\n    for idx in env.world.kinds:\n      if idx in inventory and not any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient(env.state.inventory)\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the sequence of actions to perform the crafting task.\n  actions = []\n  \n  # Get the recipe for the desired item.\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return actions\n\n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Fetch the index of the desired item from the environment's world cookbook.index\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Check if we can use the ingredient for crafting and it's available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n      # Check again for the next ingredient since we've potentially changed the inventory\n      recipe = env.world.cookbook.primitives_for(goal_idx)\n      if not recipe:\n        break\n      \n      current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Find the most needed ingredient to craft the item\n    needed_items = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    available_items = {ingredient: env._current_state.inventory[ingredient] for ingredient in needed_items if env._current_state.next_to(ingredient)}\n    \n    # If no item is next to the agent, break the loop\n    if not available_items:\n      break\n    \n    most_needed_item = max(available_items, key=available_items.get)\n    count_needed = min(recipe[most_needed_item], inventory[most_needed_item])\n    \n    # Append the actions to pick up and use the item until the recipe is satisfied\n    for _ in range(count_needed):\n      actions.append(env.world.grabbable_indices.index(most_needed_item))\n      env._current_state.inventory[most_needed_item] -= 1\n      \n      # Check if the crafted item is available now\n      recipe = get_recipe(item)\n      if all(env._current_state.inventory[ingredient] > 0 for ingredient in recipe):\n        break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if we have any recipes that can produce this item\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Filter out ingredients that are not needed or already have enough\n  usable_ingredients = [ingredient for ingredient in recipe if inventory[ingredient] >= recipe[ingredient]]\n  \n  while usable_ingredients:\n    # Sort by the amount in inventory, descending\n    sorted_ingredients = sorted(usable_ingredients, key=lambda x: inventory[x], reverse=True)\n    \n    for ingredient in sorted_ingredients:\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    if not available_items:\n      break\n    \n    most_available_item = max(available_items, key=lambda x: (x[1], -env.world.index.get(x[0])))[0]\n    count_needed = min(recipe[most_available_item], inventory[most_available_item])\n    \n    actions.extend([env.world.grabbable_indices.index(most_available_item)] * count_needed)\n    env._current_state.inventory[most_available_item] -= count_needed\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # Check how many of this primitive resource we currently have\n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, craft it by gathering until we reach the required amount\n    while available_count < count:\n      # Find the next most abundant primitive resource that we can gather more of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0 and idx != index:\n          actions.append(env.world.cookbook.index.getitem(str(idx)))\n          break\n      \n      # Update the available count after gathering more of any primitive resource\n      available_count = env.world.inventory[index]\n    \n    # If we have enough, craft it by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_move_to_ingredient(recipe):\n    nonlocal env\n    for ingredient_index, count in recipe.items():\n      if env.state.inventory[ingredient_index] == 0:\n        ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n        rel_pos = ingredient_pos - env.state.pos\n        \n        if np.any(np.abs(rel_pos) > 1):\n          direction = np.argmax(np.abs(rel_pos))\n          actions.extend([direction] * abs(rel_pos[direction]))\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  recipe = cookbook.primitives_for(goal_idx)\n  actions = []\n\n  while True:\n    find_and_move_to_ingredient(recipe)\n    \n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    if current_ingredient_index is None:\n      break\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts that need to be crafted (count == \"_key\")\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed but not in inventory, find a way to acquire or use it\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in recipe.items() if env.world.inventory[ridx] > 0 and count <= env.world.inventory[ridx]]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  # Initialize the list of actions\n  actions = []\n  \n  # Iterate over the indices and counts to craft the item\n  for i in range(len(indices)):\n    index = indices[i]\n    count = counts[i]\n    \n    # Collect all primitive resources needed, prioritizing those with more inventory\n    while env.world.inventory[index] < count:\n      available_resources = [(idx, count) for idx, count in recipe.items() if env.world.inventory[idx] > 0 and count <= env.world.inventory[idx]]\n      \n      # If no more resources are available, break out of the loop to handle as much as possible\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest remaining count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[index]  # Decrease the needed count based on what we have in inventory\n    \n    # If enough resources are available, craft the item using USE actions for each count required\n    if len(indices) == len(actions):\n      actions = [4] * sum([count for _, count in recipe.items() if count == \"_key\"])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe where count is \"_key\"\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed resources to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    while env.world.inventory[index] < count:\n      most_abundant = None\n      \n      # Find the next most abundant primitive resource that we can gather more of\n      for idx in needed_indices:\n        if env.world.inventory[idx] > 0 and idx != index:\n          most_abundant = (idx, env.world.inventory[idx])\n          break\n      \n      # If no other resources are available, we need to gather more of this resource\n      if not most_abundant:\n        actions.append(env.world.cookbook.index.getitem(str(index)))\n      else:\n        actions.append(env.world.cookbook.index.getitem(str(most_abundant[0])))\n      \n      # Update the count after gathering more of the resource\n      count -= env.world.inventory[index]\n    \n    # If we have enough, craft it by adding a USE action for each count\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource():\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in env.world.inventory if rcount > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n  \n  recipe = env.world.cookbook.recipes[item]\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, craft it by gathering until we reach the required amount\n    while available_count < count:\n      most_abundant = most_abundant_resource()\n      \n      if not most_abundant:\n        break  # Exit the loop if no more resources can be gathered\n      \n      idx_to_pickup, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx_to_pickup)))\n      \n      available_count = env.world.inventory[index]  # Update the available count after gathering more of any resource\n    \n    if len(needed_indices) == len(actions):\n      actions = [4] * sum(needed_counts)  # If all needed resources are gathered, add USE actions for each count required\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the crafting recipe for the given item index\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts for crafting from the recipe\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx, count in needed_resources:\n    while env.world.inventory[idx] < count:\n      # Find the next most abundant primitive resource that we have at least some of\n      available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not available_resources:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      _, max_count = max(available_resources, key=lambda x: x[1])\n      actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    recipe = env.world.cookbook.primitives_for(env.world.cookbook.index[item])\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  actions = []\n  ingredients = get_ingredients()\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    ingredients.remove(ingredient_idx)\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_needed_resources(recipe):\n    needed_indices = []\n    needed_counts = []\n    for idx, count in recipe.items():\n      if count == \"_key\":\n        needed_indices.append(idx)\n        needed_counts.append(count)  # Use the actual count required for crafting\n    return needed_indices, needed_counts\n\n  def craft_item(env, index):\n    recipe = env.world.cookbook.recipes[index]\n    needed_indices, needed_counts = get_needed_resources(recipe)\n    \n    # Ensure we have enough resources in inventory before crafting\n    for idx, count in zip(needed_indices, needed_counts):\n      while env.world.inventory[idx] < count:\n        available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in recipe.items() if env.world.inventory[ridx] > 0 and count <= env.world.inventory[ridx]]\n        \n        # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n        if not available_resources:\n          break\n        \n        # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n        _, max_count = max(available_resources, key=lambda x: x[1])\n        actions.append(env.world.cookbook.index.getitem(str(max_count)))  # Assuming getitem returns the index of the resource\n        count -= env.world.inventory[idx]  # Decrease the needed count based on what we have in inventory\n    \n    # Craft the item using USE actions for each count required\n    for _ in range(count):\n      actions.append(4)\n\n  recipe = env.world.cookbook.recipes[item]\n  needed_indices, needed_counts = get_needed_resources(recipe)\n  \n  actions = []\n  for idx, count in zip(needed_indices, needed_counts):\n    craft_item(env, idx)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    for ingredient, count in reversed(list(recipe.items())):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    # Sort ingredients by the amount in inventory, descending\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: env.world.cookbook.primitives_for(x)[item], reverse=True)\n    for ingredient in sorted_ingredients:\n      while inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(goal_idx):\n    ingredients = []\n    for ingredient_index, count in cookbook.primitives_for(goal_idx).items():\n      if env.state.inventory[ingredient_index] == 0:\n        ingredients.append((ingredient_index, count))\n    return ingredients\n  \n  def closest_ingredient(ingredients):\n    return min(ingredients, key=lambda x: np.sum(np.abs(np.argwhere(env.state.grid == x[0]) - env.state.pos)))\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  \n  while True:\n    ingredients = find_ingredients(goal_idx)\n    \n    if not ingredients:\n      break\n    \n    closest_ingredient_info = closest_ingredient(ingredients)\n    ingredient_index, _ = closest_ingredient_info\n    closest_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if not np.any(np.abs(rel_pos) > 1):\n      actions.append(4)  # USE action\n      continue\n    \n    actions += [direction] * abs(rel_pos[direction])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[arg] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while count > 0 and inventory[int(item)] < count:\n      pick_up_item(int(item))\n      count -= 1\n    use_item_for_crafting(item)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = []\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items.append((int(arg), count))\n    return needed_items\n  \n  def find_and_use_item(item_idx, count):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n    elif inventory[item_idx] >= count:\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items:\n    find_and_use_item(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  recipe = env.world.cookbook.recipes[item]\n  inventory = env._current_state.inventory\n  actions = []\n\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      _, arg = parse_fexp(ingredient)\n      item_idx = int(arg)\n      while count > inventory[item_idx]:\n        # Try to pick up the item if it's available and not already in inventory\n        if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n          actions.append(env.world.non_grabbable_indices.index(item_idx))\n          # After picking up the item, use it for crafting\n        count -= 1\n      if count > 0:\n        # If we have enough of the item, use it directly for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource():\n    available_resources = [(ridx, env.world.inventory[ridx]) for ridx in range(len(env.world.cookbook.index)) if env.world.cookbook.index.getitem(str(ridx)) is not None and env.world.inventory[ridx] > 0]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  # Extract indices and counts for crafting from the recipe\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for _, count in needed_resources:\n    while env.world.inventory[needed_resources[0][0]] < count:\n      most_abundant = most_abundant_resource()\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not most_abundant:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      idx, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[needed_resources[0][0]]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource(needed_resources):\n    available_resources = [(env.world.cookbook.index.getitem(str(ridx)), rcount) for ridx, rcount in needed_resources if env.world.inventory[ridx] > 0]\n    return max(available_resources, key=lambda x: (x[1], -x[0]), default=None)\n\n  # Extract indices and counts for crafting from the recipe\n  recipe = env.world.cookbook.recipes[item]\n  needed_resources = [(idx, count) for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for _, count in needed_resources:\n    while env.world.inventory[needed_resources[0][0]] < count:\n      most_abundant = most_abundant_resource(needed_resources)\n      \n      # If there are no more resources available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if not most_abundant:\n        break\n      \n      # Otherwise, pick up the resource with the highest count and use it towards crafting the item\n      idx, _ = most_abundant\n      actions.append(env.world.cookbook.index.getitem(str(idx)))  # Assuming getitem returns the index of the resource\n      count -= env.world.inventory[needed_resources[0][0]]  # Decrease the needed count based on what we have in inventory\n  \n  # If enough resources are available, craft the item using USE actions for each count required\n  if len(needed_resources) == len(actions):\n    actions = [4] * sum([count for _, count in needed_resources])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def most_abundant_resource():\n    available_resources = [(idx, env.world.inventory[ridx]) for ridx, idx in env.world.cookbook.index.contents.items() if env.world.inventory[ridx] > 0 and ridx != item]\n    return max(available_resources, key=lambda x: x[1], default=None)\n\n  recipe = env.world.cookbook.recipes[item]\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # For each resource needed, check inventory and perform necessary actions to acquire or use them\n  for idx in needed_indices:\n    while env.world.inventory[idx] < 1:\n      most_abundant = most_abundant_resource()\n      \n      if not most_abundant:\n        break\n      \n      ridx, _ = most_abundant\n      actions.append(ridx)  # Assuming the index is what we need to pick up\n  \n  if len(needed_indices) == len(actions):\n    for _ in range(sum([recipe[str(idx)] for idx in needed_indices])):\n      actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    recipe = env.world.cookbook.recipes.get(goal_idx, {})\n    return {env.world.cookbook.index.contents[k]: k for k in recipe}\n\n  idx_to_item = env.world.cookbook.index.contents\n  \n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  recipe = get_recipe(goal_idx)\n  \n  inventory = {k: v for k, v in env.world.primitives.items() if v > 0}\n  \n  actions = []\n  required_items = list(recipe.keys())\n  while required_items and any(inventory.get(ing, 0) >= count for ing, count in recipe.items()):\n    for ing, count in required_items:\n      if inventory.get(ing, 0) > 0 and count > 0:\n        actions.append(idx_to_item[ing])\n        inventory[ing] -= 1\n        count -= 1\n        if count == 0:\n          required_items.remove((ing, 0))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Helper function to get recipe details\n  def get_recipe(goal_idx):\n    return env.world.cookbook.recipes.get(goal_idx, {})\n\n  idx_to_item = env.world.cookbook.index.contents\n  \n  # Find the index of the desired item in the world's recipe output list (env.world.primitives)\n  goal_idx = None\n  for idx, details in idx_to_item.items():\n    if details == item:\n      goal_idx = idx\n      break\n  \n  # If the item is not found in the recipes, return an empty list\n  if goal_idx is None or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  recipe = get_recipe(goal_idx)\n  \n  # Check if all necessary items are available in the inventory\n  inventory = {k: v for k, v in env.world.primitives.items() if v > 0}\n  \n  actions = []\n  for ing, count in recipe.items():\n    while count > 0 and ing in inventory and inventory[ing] > 0:\n      actions.append(idx_to_item[ing])  # Append the action to use the item from the inventory\n      inventory[ing] -= 1\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, closest_pos(env, i)) for i in recipe if env.state.inventory[i] == 0 and i != goal_idx]\n  \n  def closest_pos(env, ingredient_index):\n    positions = np.argwhere(env.state.grid == ingredient_index)\n    if len(positions) > 0:\n      distances = np.linalg.norm(positions - env.state.pos, axis=1)\n      return positions[np.argmin(distances)]\n    return None\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_index = min(ingredients, key=lambda x: np.linalg.norm(x[1] - env.state.pos))\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_index] -= 1\n    ingredients.remove((ingredient_index, closest_pos))\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] >= counts[ingredients.index(ing)]:\n        found_items.append((ing, counts[ingredients.index(ing)]))\n    return found_items\n  \n  actions = []\n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  found_items = find_items_in_inventory(ingredients)\n  \n  while any(counts):\n    for ing, count in found_items:\n      if count > 0 and env.inventory[ing] > 0:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n    \n    ingredients, counts = get_recipe(goal_idx)\n    found_items = find_items_in_inventory(ingredients)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] >= counts[ingredients.index(ing)]:\n        found_items.append((ing, counts[ingredients.index(ing)]))\n    return found_items\n  \n  goal_idx = next((idx for idx, details in env.world.cookbook.index.contents.items() if details == item), None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  actions = []\n  ingredients, counts = get_recipe(goal_idx)\n  found_items = find_items_in_inventory(ingredients)\n  \n  while any(counts):\n    for ing, count in found_items:\n      if count > 0 and env.inventory[ing] > 0:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n    \n    ingredients, counts = get_recipe(goal_idx)\n    found_items = find_items_in_inventory(ingredients)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_items_in_inventory(ingredients):\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in ingredients:\n      if ing in inventory and inventory[ing] > 0:\n        found_items.append((ing, min(inventory[ing], counts[ingredients.index(ing)])))\n    return found_items\n  \n  def craft_item():\n    nonlocal actions, counts\n    while any(counts):\n      found_items = find_items_in_inventory(ingredients)\n      if not found_items:\n        break\n      \n      for ing, count in found_items:\n        actions.append(ing)\n        counts[ingredients.index(ing)] -= 1\n  \n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = [], []\n  for ing, count in env.world.cookbook.recipes[goal_idx].items():\n    if isinstance(ing, int):\n      ingredients.append(ing)\n      counts.append(count)\n  \n  actions = []\n  craft_item()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_resources():\n    recipe = env.world.cookbook.recipes[item]\n    needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n    return needed_indices\n  \n  actions = []\n  resources_needed = find_resources()\n  \n  # Check inventory and perform necessary actions to acquire or use them\n  for idx in resources_needed:\n    available_count = env.world.inventory[idx]\n    \n    while available_count < 1:\n      # Find the next most abundant primitive resource that we have at least some of\n      for ridx in reversed(resources_needed):  # Reverse to prefer earlier resources if possible\n        if env.world.inventory[ridx] > 0:\n          actions.append(env.world.cookbook.index.getitem(str(ridx)))\n          available_count += 1\n          break\n      \n      # If no more resources are available, stop the process (this is a simplification; you might want to handle differently in a full implementation)\n      if available_count < 1:\n        break\n    \n    # Use the item (craft it) by adding a USE action for each count\n    actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_inventory(inventory, item):\n    idx = env.world.cookbook.index.get_by_name(str(item))\n    if inventory[idx] > 0:\n      return True\n    return False\n  \n  recipe = env.world.cookbook.recipes[item]\n  inventory = env._current_state.inventory\n  actions = []\n\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      _, arg = parse_fexp(ingredient)\n      item_idx = int(arg)\n      while count > inventory[item_idx]:\n        # Try to pick up the item if it's available and not already in inventory\n        if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n          actions.append(env.world.non_grabbable_indices.index(item_idx))\n          # After picking up the item, use it for crafting\n        count -= 1\n      if count > 0:\n        # If we have enough of the item, use it directly for crafting\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  recipe = env.world.cookbook.recipes[item]\n  inventory = env._current_state.inventory\n  actions = []\n\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      _, arg = parse_fexp(ingredient)\n      item_idx = int(arg)\n      while inventory[item_idx] < count:\n        # Try to pick up the item if it's available and not already in inventory\n        if env._current_state.next_to(item_idx):\n          actions.append(env.world.non_grabbable_indices.index(item_idx))\n        count -= 1\n      # If we have enough of the item, use it directly for crafting\n      while count > 0:\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n        count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = []\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items.append((int(arg), count))\n    return needed_items\n  \n  def find_and_use_item(item_idx, count):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n    elif inventory[item_idx] >= count:\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  def craft_if_possible():\n    required = get_required_items()\n    if all(inventory[i] >= c for i, c in required):\n      for i, c in reversed(required):\n        for _ in range(c):\n          actions.append(env.world.cookbook.index.get_by_name(str(i)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items:\n    find_and_use_item(item_idx, count)\n  \n  craft_if_possible()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  if item not in env.world.cookbook.recipes:\n    raise ValueError(\"Item {} is not a valid goal.\".format(item))\n  \n  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = []\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items.append((int(arg), count))\n    return needed_items\n  \n  def find_and_use_item(item_idx, count):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n    elif inventory[item_idx] >= count:\n      for _ in range(count):\n        actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  def move_to_crafting_position(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]: actions.append(env.world.index.get('RIGHT'))\n    elif target_pos[0] < current_pos[0]: actions.append(env.world.index.get('LEFT'))\n    elif target_pos[1] > current_pos[1]: actions.append(env.world.index.get('DOWN'))\n    elif target_pos[1] < current_pos[1]: actions.append(env.world.index.get('UP'))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items:\n    while not (env._current_state.next_to(item_idx) and inventory[item_idx] == 0):\n      move_to_crafting_position((item_idx, 0))\n    find_and_use_item(item_idx, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item_idx, count in needed_items.items():\n    while count > 0:\n      if inventory[item_idx] < count:\n        pick_up_item(item_idx)\n      else:\n        use_item_for_crafting(item_idx)\n      count -= 1\n  \n  # If there are any actions, simulate them in the environment\n  if len(actions) > 0:\n    _, new_state = env._current_state.step(actions[0])\n    env._current_state = new_state\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item, None)\n    if not recipe:\n      return [], []\n    \n    ingredients = [k for k in recipe if isinstance(k, int)]\n    counts = list(recipe.values())[:len(ingredients)]\n    return ingredients, counts\n  \n  def find_items_in_inventory():\n    inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n    found_items = []\n    for ing in list(ingredients):\n      item = next((inv for inv in inventory if inv == ing), None)\n      if item:\n        found_items.append(item)\n    return found_items\n  \n  actions = []\n  goal_idx = env.world.cookbook.index.contents.get(item, None)\n  if not goal_idx or goal_idx not in env.world.cookbook.recipes:\n    return []\n  \n  ingredients, counts = get_recipe(goal_idx)\n  inventory = {k: v for k, v in zip(env.world.cookbook.index.contents.keys(), env.inventory) if v > 0}\n  \n  while any(counts):\n    used_items = find_items_in_inventory()\n    for ing, count in list(zip(used_items, counts)):\n      actions.append(ing)\n      counts[used_items.index(ing)] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    goal_idx = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n\n  actions = []\n  ingredients = get_ingredients()\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx, needed_count = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while needed_count > 0 and np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n      needed_count -= 1\n    \n    # Use the ingredient to craft the final product\n    if needed_count == 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n      ingredients = get_ingredients()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    goal_idx = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  def find_closest_ingredient(ingredients):\n    closest_dist = float('inf')\n    closest_pos = None\n    ingredient_idx = None\n    \n    for ingr in ingredients:\n      pos = np.argwhere(env.state.grid == ingr)[0]\n      dist = np.sum(np.abs(pos - env.state.pos))\n      \n      if dist < closest_dist:\n        closest_dist = dist\n        closest_pos = pos\n        ingredient_idx = ingr\n    \n    return (closest_pos, ingredient_idx) if closest_pos else (None, None)\n\n  actions = []\n  ingredients = get_ingredients()\n\n  while len(ingredients) > 0:\n    _, ingredient_idx = find_closest_ingredient(ingredients)\n    \n    if not _:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    ingredients.remove(ingredient_idx)\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients_to_craft = [i for i, count in recipe.items() if env.state.inventory[i] == 0]\n  \n  actions = []\n  \n  while ingredients_to_craft:\n    # Find the closest ingredient to collect and craft from the list of required ingredients\n    closest_ingredient_index = min(ingredients_to_craft, key=lambda x: np.sum(np.abs(env.state.pos - np.argwhere(env.state.grid == x)[0])))\n    \n    # Move towards the ingredient\n    ingredient_pos = np.argwhere(env.state.grid == closest_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the list of required ingredients to track progress\n    ingredients_to_craft.remove(closest_ingredient_index)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[arg] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while count > 0:\n      if inventory[int(item)] < count:\n        pick_up_item(int(item))\n      else:\n        use_item_for_crafting(item)\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def pick_up_item(item_idx):\n    if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n      actions.append(env.world.non_grabbable_indices.index(item_idx))\n  \n  def use_item_for_crafting(item):\n    item_idx = env.world.cookbook.index.get_by_name(str(item))\n    actions.append(item_idx)\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  for item, count in needed_items.items():\n    while count > 0:\n      if inventory[item] < count:\n        pick_up_item(item)\n      else:\n        use_item_for_crafting(item)\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    needed_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        _, arg = parse_fexp(ingredient)\n        needed_items[int(arg)] = count\n    return needed_items\n  \n  def craft_item(item_idx):\n    actions.append(env.world.cookbook.index.get_by_name(str(item_idx)))\n  \n  inventory = env._current_state.inventory\n  needed_items = get_required_items()\n  actions = []\n\n  # Sort the required items by their count to prioritize crafting higher-priority items first\n  sorted_needed_items = sorted(needed_items.items(), key=lambda x: x[1], reverse=True)\n  \n  for item_idx, _ in sorted_needed_items:\n    while inventory[item_idx] < needed_items[item_idx]:\n      # Try to pick up the required items if they are available\n      if env._current_state.next_to(item_idx) and inventory[item_idx] == 0:\n        actions.append(env.world.non_grabbable_indices.index(item_idx))\n      # Increase the count of needed items to simulate attempting to craft more than one at a time if possible\n      needed_items[item_idx] += 1\n    # Craft the item after ensuring we have enough of each required ingredient\n    craft_item(item_idx)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    # Sort ingredients by the amount in inventory, descending\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n    for ingredient in sorted_ingredients:\n      while inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Sort ingredients by the amount in inventory, descending\n    sorted_ingredients = sorted(recipe.keys(), key=lambda x: inventory[x], reverse=True)\n    for ingredient in sorted_ingredients:\n      while inventory[ingredient] >= recipe[ingredient]:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract indices and counts from the recipe\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    # If we don't have enough of this primitive resource, gather more until we reach the required amount\n    available_count = env.world.inventory[index]\n    if available_count < count:\n      actions += [env.world.cookbook.index.getitem(str(index))] * (count - available_count)\n    \n    # Add a USE action for each count of this primitive resource needed to craft the item\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  needed_indices = [idx for idx, count in recipe.items() if count == \"_key\"]\n  needed_counts = [count for idx, count in recipe.items() if count == \"_key\"]\n  \n  actions = []\n  \n  # Iterate over the needed indices and counts to craft the item\n  for i in range(len(needed_indices)):\n    index = needed_indices[i]\n    count = needed_counts[i]\n    \n    available_count = env.world.inventory[index]\n    \n    # If we don't have enough, gather more until we reach the required amount\n    if available_count < count:\n      actions += [env.world.cookbook.index.getitem(str(index))] * (count - available_count)\n    \n    # Add a USE action for each count of this primitive resource needed to craft the item\n    actions += [4] * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    ingredients = [ingredient for ingredient in env.world.cookbook.index if recipe.get(ingredient, None)]\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, ingredients[0] if ingredients else None\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  actions = []\n  \n  while recipe:\n    closest_pos, next_ingredient = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[next_ingredient]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use(inventory, index):\n    # Find all instances of the primitive in the inventory.\n    indices = np.where(inventory[index] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for idx in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(idx))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  def get_recipe(item):\n    cookbook = env.world.cookbook\n    return cookbook.primitives_for(item)\n\n  actions = []\n  recipe = get_recipe(item)\n  \n  if not recipe:\n    return actions\n\n  for primitive, count in recipe.items():\n    find_and_use(env._current_state.inventory, primitive)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_closest_ingredient_index(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient_index, count in recipe.items():\n      if env.state.inventory[ingredient_index] == 0:\n        pos = np.argwhere(env.state.grid == ingredient_index)[0]\n        distance = np.sum(np.abs(pos - env.state.pos))\n        \n        if distance < min_distance:\n          closest_pos = pos\n          min_distance = distance\n    \n    return closest_pos, min_distance\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n\n  while True:\n    closest_pos, _ = get_closest_ingredient_index(goal_idx)\n    \n    if not closest_pos:\n      break\n\n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n\n    ingredient_index = env.state.grid[closest_pos[0], closest_pos[1]]\n    if env.state.inventory[ingredient_index] == 0:\n      break\n    \n    actions.append(4)  # USE action\n    env.state.inventory[ingredient_index] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for idx in env.world.kinds:\n      if idx not in env.state.inventory or any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        continue\n      \n      pos = np.argwhere(env.state.grid == idx)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, min_distance\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    closest_pos, _ = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    \n    if not any(env.state.inventory == 0 for item in recipe):\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_next_ingredient(recipe, inventory):\n    return next((i for i, count in recipe.items() if i not in inventory), None)\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Get the recipe for the goal index\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    current_ingredient_index = get_next_ingredient(recipe, env.state.inventory)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Move to the ingredient and use it for crafting if available in inventory\n    while not env.state.next_to(current_ingredient_index):\n      direction = np.argmax(np.abs(rel_pos))\n      actions.append(direction)\n      env.state.step(direction)  # Perform the action in the environment\n      ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n      rel_pos = ingredient_pos - env.state.pos\n    \n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n      # Update the recipe to reflect the used ingredient and check again for the next ingredient\n      recipe = env.world.cookbook.primitives_for(goal_idx)\n      if not recipe:\n        break\n      \n      current_ingredient_index = get_next_ingredient(recipe, env.state.inventory)\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    # Sort by the least amount of each ingredient needed that we have enough of\n    sorted_missing = sorted([(ingredient, count) for ingredient, count in missing.items()], key=lambda x: env._current_state.inventory[x[0]])\n    \n    # Pick up ingredients in order of need\n    for ingredient, count in sorted_missing:\n      while inventory[ingredient] < count and sum(inventory[i] for i in recipe) > 0:\n        actions.append(env.world.grabbable_indices.index(ingredient))\n        env._current_state.step(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n    \n    # Craft the item\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      env._current_state.step(env.world.grabbable_indices.index(item))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    ingredient_positions = np.argwhere(np.isin(env.state.grid, [recipe[k] for k in recipe if env.state.inventory[recipe[k]] > 0]))\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for pos in ingredient_positions:\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, [k for k in recipe if recipe[k] == closest_pos][0] if ingredient_positions else None\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  \n  actions = []\n  \n  while recipe:\n    closest_pos, next_ingredient = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[next_ingredient]\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    ingredients = [ingredient for ingredient in env.world.cookbook.index if recipe.get(ingredient, None)]\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, ingredients[0] if ingredients else None\n\n  def move_to_ingredient():\n    closest_pos, _ = find_closest_ingredient()\n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if np.any(np.abs(rel_pos) > 1):\n      return [direction] * abs(rel_pos[direction])\n    else:\n      return []\n  \n  def use_ingredient():\n    closest_pos, _ = find_closest_ingredient()\n    if env.state.inventory[closest_pos[0]] > 0:\n      return [4]  # USE action\n    else:\n      return []\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    move_actions = move_to_ingredient()\n    if move_actions:\n      actions += move_actions\n    \n    use_actions = use_ingredient()\n    if use_actions:\n      actions += use_actions\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(next(key for key in recipe if env.state.inventory[key] > 0))\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that can be directly grabbed or are already crafted.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to indices list to check their requirements recursively.\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient(ingredients):\n    closest_pos = None\n    ingredient_idx = None\n    needed_count = None\n    \n    for i, count in ingredients:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = i\n          needed_count = count\n    \n    return (closest_pos, ingredient_idx, needed_count) if closest_pos is not None else (None, None, None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx, needed_count = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while needed_count > 0 and np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n      needed_count -= 1\n    \n    # Use the ingredient to craft the final product\n    if needed_count == 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the environment's cookbook.index\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            found = True\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    inventory = env.state.inventory\n    grid = env.state.grid\n    for idx in env.world.kinds:\n      if idx in inventory and not any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient()\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    \n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(count, inventory[ingredient])\n    \n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      env._current_state = env.step(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n    \n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      env._current_state = env.step(env.world.grabbable_indices.index(item))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    \n    ingredients_to_craft = {}\n    for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]]):\n      if inventory[ingredient] >= count:\n        ingredients_to_craft[ingredient] = min(count, inventory[ingredient])\n    \n    for ingredient, count in sorted(ingredients_to_craft.items(), key=lambda x: -inventory[x[0]]):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      env._current_state = env.step(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n    \n    # Craft the item if possible\n    recipe = get_recipe(item)\n    if craftable(inventory, recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      env._current_state = env.step(env.world.grabbable_indices.index(item))\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        requirements[current] = env.world.cookbook.primitives_for(current)\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  # Add a penalty for picking up and discarding items that are not directly needed.\n  extra_penalty = env._extra_pickup_penalty\n  adjusted_actions = []\n  for action in actions:\n    if action == env.world.grabble_indices.index:\n      # Check if the item can be picked up and is not required for crafting the final product.\n      current_item = env.scenario._current_state.inventory[item]\n      if current_item > 0:\n        adjusted_actions.append(action)\n      else:\n        adjusted_actions.append(env.world.non_grabbable_indices.index)\n    else:\n      adjusted_actions.append(action)\n  \n  return adjusted_actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env.state.inventory\n\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in inventory or inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_closest_ingredient_pos(ingredients):\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    closest_pos = get_closest_ingredient_pos(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not already adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient_index():\n    cookbook = env.world.cookbook\n    goal_idx = cookbook.index.get(item)\n    if goal_idx is None:\n      raise ValueError(\"Unknown item to craft\")\n    \n    # Check if we have any recipes that can produce this item\n    recipe = cookbook.primitives_for(goal_idx)\n    if not recipe:\n      return None, None\n\n    for ingredient_index, count in recipe.items():\n      if env.state.inventory[ingredient_index] == 0 and np.any(env.state.grid == ingredient_index):\n        ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n        rel_pos = ingredient_pos - env.state.pos\n        if np.all(np.abs(rel_pos) <= 1):\n          return ingredient_index, rel_pos\n    return None, None\n\n  actions = []\n  \n  while True:\n    ingredient_info = find_ingredient_index()\n    if not ingredient_info[0]:\n      break\n    \n    ingredient_index, rel_pos = ingredient_info\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        requirements[current] = env.world.cookbook.primitives_for(current)\n      for k, v in requirements[current].items():\n        if k not in requirements and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the item can be crafted from primitives and get the recipe\n  cookbook = env.world.cookbook\n  idx = cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = cookbook.primitives_for(idx)\n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Get the current inventory of items needed for crafting\n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Check the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # If we have enough items, craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0 and np.any(env.state.grid == i)]\n  \n  def find_closest_ingredient():\n    closest_pos = None\n    ingredient_idx = None\n    needed_count = None\n    \n    for idx in get_ingredients(goal_idx):\n      pos = np.argwhere(env.state.grid == idx)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = idx\n          needed_count = recipe[ingredient_idx]\n    \n    return (closest_pos, ingredient_idx, needed_count) if closest_pos is not None else (None, None, None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  \n  while len(get_ingredients(goal_idx)) > 0:\n    closest_pos, ingredient_idx, needed_count = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while needed_count > 0 and np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n      needed_count -= 1\n    \n    # Use the ingredient to craft the final product\n    if needed_count == 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(goal_idx):\n    ingredients = []\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    for ingredient_index, count in recipe.items():\n      if env.state.inventory[ingredient_index] == 0:\n        ingredients.append((ingredient_index, count))\n    return ingredients\n  \n  def closest_ingredient(ingredients):\n    return min(ingredients, key=lambda x: np.sum(np.abs(np.argwhere(env.state.grid == x[0]) - env.state.pos)))\n\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  \n  while True:\n    ingredients = find_ingredients(goal_idx)\n    \n    if not ingredients:\n      break\n    \n    closest_ingredient_info = closest_ingredient(ingredients)\n    ingredient_index, _ = closest_ingredient_info\n    closest_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if not np.any(np.abs(rel_pos) > 1):\n      actions.append(4)  # USE action\n      continue\n    \n    actions += [direction] * abs(rel_pos[direction])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            found = True\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the indices for the environment components and crafting recipe lookup\n  non_grabbable_indices = env.world.non_grabbable_indices\n  grabbable_indices = env.world.grabbable_indices\n  workshop_indices = env.world.workshop_indices\n  water_index = env.world.water_index\n  stone_index = env.world.stone_index\n  \n  # Get the indices for the goal item and its crafting components from the environment's cookbook\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n  \n  # Extract ingredient names and counts from the recipe\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in non_grabbable_indices:\n      ingredients[key] = count\n    \n  # Initialize an empty list to store actions for crafting the item\n  actions = []\n  \n  # Function to move to a specific position\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n  \n  # Function to pick up an item at a specific position\n  def pickup(item_idx):\n    if env._current_state.next_to(item_idx):\n      actions.append(env_factory.USE)\n  \n  # Function to craft an item using the ingredients found in inventory\n  def craft():\n    for ingredient, count in ingredients.items():\n      while not env._current_state.inventory[ingredient] >= count:\n        pickup(ingredient)\n      actions.append(env_factory.USE)\n  \n  # Main logic to move to the workshop and craft the item\n  if len(ingredients) == 2:\n    for key, value in ingredients.items():\n      target_pos = None\n      if key == water_index:\n        target_pos = (0, 0)  # Placeholder position, adjust as necessary\n      elif key == stone_index:\n        target_pos = (0, 0)  # Placeholder position, adjust as necessary\n      else:\n        for idx in workshop_indices:\n          if env._current_state.grid[idx] == key:\n            target_pos = idx\n            break\n      move_to(target_pos)\n      pickup(key)\n    craft()\n  elif len(ingredients) == 1:\n    for key, value in ingredients.items():\n      target_pos = None\n      if key == water_index or key == stone_index:\n        target_pos = (0, 0)  # Placeholder position, adjust as necessary\n      else:\n        for idx in workshop_indices:\n          if env._current_state.grid[idx] == key:\n            target_pos = idx\n            break\n      move_to(target_pos)\n      pickup(key)\n    craft()\n  elif len(ingredients) == 0:\n    # If no ingredients are required, do nothing (assuming the item is already available in inventory)\n    pass\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the goal item is available in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            found = True\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence with an initial 'USE' action at position (0, 0)\n  actions = [4]  # USE is represented by index 4\n  \n  # Get the recipe for the item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          if env.world.cookbook.reverse_contents[sub_ingredient_index] not in env.non_grabbable_indices:\n            # Find the position of the ingredient in the grid\n            found = False\n            for x in range(env.grid.shape[0]):\n              for y in range(env.grid.shape[1]):\n                if np.any(env.grid[x, y] == sub_ingredient_index):\n                  # Move to the position of the ingredient\n                  dx = x - env.pos[0]\n                  dy = y - env.pos[1]\n                  if dx < 0: actions.append(2)  # LEFT\n                  elif dx > 0: actions.append(3)  # RIGHT\n                  elif dy < 0: actions.append(1)  # UP\n                  elif dy > 0: actions.append(0)  # DOWN\n                  # Pick up the ingredient\n                  actions.append(4)  # USE\n                  found = True\n                  break\n              if found: break\n          else:\n            # If the ingredient is not grabbable, we need to find it again later when it's available\n            pass\n        else:\n          # If the count is a direct index of an item that can be grabbed directly\n          for x in range(env.grid.shape[0]):\n            for y in range(env.grid.shape[1]):\n              if np.any(env.grid[x, y] == ingredient_index):\n                # Move to the position of the ingredient\n                dx = x - env.pos[0]\n                dy = y - env.pos[1]\n                if dx < 0: actions.append(2)  # LEFT\n                elif dx > 0: actions.append(3)  # RIGHT\n                elif dy < 0: actions.append(1)  # UP\n                elif dy > 0: actions.append(0)  # DOWN\n                # Pick up the ingredient\n                actions.append(4)  # USE\n                break\n            if found: break\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        for x in range(env.grid.shape[0]):\n          for y in range(env.grid.shape[1]):\n            if np.any(env.grid[x, y] == ingredient_index):\n              # Move to the position of the ingredient\n              dx = x - env.pos[0]\n              dy = y - env.pos[1]\n              if dx < 0: actions.append(2)  # LEFT\n              elif dx > 0: actions.append(3)  # RIGHT\n              elif dy < 0: actions.append(1)  # UP\n              elif dy > 0: actions.append(0)  # DOWN\n              # Pick up the ingredient\n              actions.append(4)  # USE\n              break\n          if found: break\n      recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize a list to store actions\n  actions = []\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n          found = True\n          break\n      if not found:\n        # If no more instances are found and we haven't used all ingredients, keep searching by picking up new ones\n        for i in range(len(env.inventory)):\n          if env.inventory[i] == 0:\n            actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n            break\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, np.argwhere(env.state.grid == i)[0]) for i in recipe if env.state.inventory[i] == 0]\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos[0])\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item.\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  actions = []\n\n  if not recipe:\n    return actions  # If no recipe is found, return an empty list (it's already crafted).\n\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    missing = {ingredient: count for ingredient, count in recipe.items() if inventory[ingredient] < count}\n    for ingredient, count in sorted(missing.items(), key=lambda x: env._current_state.inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n    \n    # Craft the item\n    if all(inventory[i] >= recipe[i] for i in recipe):\n      output_count = min(recipe[i] for i in recipe if inventory[i] >= recipe[i])\n      actions.extend([env.world.grabbable_indices.index(item)] * output_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.recipes.get(goal, {})\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isdigit():\n        primitive_index = int(ingredient)\n        if primitive_index not in env.world.inventory or env.world.inventory[primitive_index] == 0:\n          raise ValueError(\"Not enough inventory to craft the item\")\n    return recipe\n\n  def craft_step(current_item, target_item):\n    if current_item == target_item:\n      return []\n    recipe = get_recipe(target_item)\n    actions = []\n    for ingredient, count in recipe.items():\n      while env.world.inventory[int(ingredient)] > 0 and count > 0:\n        actions.append(env.world.index.get(int(ingredient)))\n        env.world.inventory[int(ingredient)] -= 1\n        count -= 1\n    return actions + craft_step(current_item, target_item) if count > 0 else []\n\n  start_item = item\n  initial_actions = craft_step(start_item, start_item)\n  return initial_actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    current = [item]\n    while len(current) > 0:\n      next_item = current.pop()\n      if next_item not in requirements:\n        reqs = env.world.cookbook.primitives_for(next_item)\n        if reqs:\n          requirements[next_item] = reqs\n          # Add the required components to the current list to check their requirements recursively.\n          for k, v in reqs.items():\n            current += [k] * v\n    return requirements\n\n  requirements = get_requirements(item)\n  \n  actions = []\n  for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n    if all(env.world.cookbook.primitives_for(key).values()):\n      continue  # Skip items that are already crafted or can be directly grabbed.\n    for k, v in value.items():\n      actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    if item not in env.world.cookbook.recipes:\n      return {}\n    requirements = {}\n    for output, recipe in env.world.cookbook.recipes[item].items():\n      if isinstance(recipe, dict) and \"_key\" in recipe:  # It's a recipe.\n        sub_item = next((k for k, v in recipe.items() if k != \"_key\"), None)\n        sub_requirements = get_requirements(sub_item)\n        for k, v in sub_requirements.items():\n          if k not in requirements:\n            requirements[k] = 0\n          requirements[k] += v\n      else:  # It's a primitive or already crafted item.\n        if recipe != \"_key\":\n          requirements[recipe] = 1\n    return requirements\n  \n  requirements = get_requirements(item)\n  actions = []\n  for k, v in reversed(sorted(requirements.items(), key=lambda x: len(env.world.cookbook.primitives_for(x)))):\n    if env.world.cookbook.primitives_for(k).get(item, 0) > 0 or all(env.world.cookbook.primitives_for(k).values()):\n      continue  # Skip items that are already crafted or can be directly grabbed.\n    actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            actions.append(4)  # USE\n          else:\n            # If the ingredient is not grabbable, we need to find it again later when it's available\n            pass\n        recipe = env.world.cookbook.recipes[ingredient_index]\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n          if dx < 0: actions.append(2)  # LEFT\n          elif dx > 0: actions.append(3)  # RIGHT\n          elif dy < 0: actions.append(1)  # UP\n          elif dy > 0: actions.append(0)  # DOWN\n          actions.append(4)  # USE\n        recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action list with a USE action to start crafting\n  actions = [4]\n\n  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    # Find and collect all ingredients required by the current recipe\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Iterate through each ingredient to find its position in the grid and pick it up\n    for ingredient_index in ingredient_indices:\n      found = False\n      for x in range(env.grid.shape[0]):\n        for y in range(env.grid.shape[1]):\n          if np.any(env.grid[x, y] == ingredient_index):\n            # Calculate the necessary movement to reach and pick up the ingredient\n            dx = x - env.pos[0]\n            dy = y - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            if not found: actions.append(4)  # USE to pick up the ingredient\n            found = True\n            break\n        if found: break\n      \n      # Update the recipe for the next iteration, now that we have collected this ingredient\n      del recipe[ingredient_index]\n    \n    # If there are still nested dictionaries left in the recipe, it means we need to find specific items again later when they're available\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    ingredient_idx = None\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = i\n    \n    return (closest_pos, ingredient_idx) if closest_pos is not None else (None, None)\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index[item]\n  recipe = {k: v for k, v in cookbook.primitives_for(goal_idx).items() if env.state.inventory[k] > 0}\n  \n  while len(recipe) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft the final product\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n      recipe = {k: v for k, v in cookbook.primitives_for(goal_idx).items() if env.state.inventory[k] > 0}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    closest_distance = float('inf')\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        avg_dist = np.mean(dist)\n        if closest_distance is None or avg_dist < closest_distance:\n          closest_distance = avg_dist\n          closest_pos = pos[np.argmin(dist)]\n    \n    return (closest_pos, recipe[closest_pos]) if closest_pos is not None else (None, None)\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  recipe = cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n\n  actions = []\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_index = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient (if not already adjacent)\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Prioritize collecting items that are directly next to the agent\n  for ingredient_index in ingredients:\n    target_pos = get_item_position(env._current_state.grid, ingredient_index)\n    if target_pos is not None:\n      move_to(target_pos)\n      pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env.state.inventory.copy()\n  grid = env.state.grid.copy()\n  \n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Check inventory and use the ingredient to craft the final product\n    if inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  # Initialize the list of actions (empty for now)\n  actions = []\n\n  # Use the ingredients in reverse order to find them and craft the final product\n  while goal_idx != -1:\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env.grid, sub_ingredient_index)\n          if position:\n            dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            actions.append(4)  # USE\n          else:\n            # If the ingredient is not grabbable, we need to find it again later when it's available\n            pass\n        recipe = env.world.cookbook.recipes[ingredient_index]\n      else:\n        position = find_item(env.grid, ingredient_index)\n        if position:\n          dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n          if dx < 0: actions.append(2)  # LEFT\n          elif dx > 0: actions.append(3)  # RIGHT\n          elif dy < 0: actions.append(1)  # UP\n          elif dy > 0: actions.append(0)  # DOWN\n          actions.append(4)  # USE\n        recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_position_of_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        for sub_ingredient_index, sub_count in count.items():\n          position = get_position_of_item(env, sub_ingredient_index)\n          required_items.append((sub_ingredient_index, position))\n      else:\n        position = get_position_of_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    for ingredient_index, position in required_items:\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      actions.append(4)  # USE to pick up and craft\n    \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    current = [item]\n    while len(current) > 0:\n      next_item = current.pop()\n      if next_item not in requirements:\n        reqs = env.world.cookbook.primitives_for(next_item)\n        if reqs:\n          requirements[next_item] = reqs\n          # Add the required components to the current list to check their requirements recursively.\n          for k, v in reqs.items():\n            current += [k] * v\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  def is_craftable(item):\n    requirements = get_requirements(item)\n    for key in requirements:\n      if not all(env.world.cookbook.primitives_for(key).values()):\n        return False\n    return True\n\n  # Ensure the item can be crafted before generating actions.\n  if not is_craftable(item):\n    raise ValueError(\"Item cannot be crafted from available resources.\")\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  def move_to_position(env, target_pos):\n    dx, dy = target_pos[0] - env.pos[0], target_pos[1] - env.pos[1]\n    if dx < 0: actions = [2] * abs(dx)  # LEFT\n    elif dx > 0: actions = [3] * abs(dx)  # RIGHT\n    elif dy < 0: actions = [1] * abs(dy)  # UP\n    elif dy > 0: actions = [0] * abs(dy)  # DOWN\n    else: actions = []\n    return actions\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      actions += move_to_position(env, position)\n      actions.append(4)  # USE\n      \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  def move_to_position(env, target_pos):\n    dx, dy = target_pos[0] - env.pos[0], target_pos[1] - env.pos[1]\n    if dx < 0: actions = [2] * abs(dx)  # LEFT\n    elif dx > 0: actions = [3] * abs(dx)  # RIGHT\n    elif dy < 0: actions = [1] * abs(dy)  # UP\n    elif dy > 0: actions = [0] * abs(dy)  # DOWN\n    else: actions = []\n    return actions\n\n  def use_item(env, target_pos):\n    dx, dy = target_pos[0] - env.pos[0], target_pos[1] - env.pos[1]\n    if dx < 0: return [2, 4]  # LEFT + USE\n    elif dx > 0: return [3, 4]  # RIGHT + USE\n    elif dy < 0: return [1, 4]  # UP + USE\n    elif dy > 0: return [0, 4]  # DOWN + USE\n    else: return []\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      actions += move_to_position(env, position)\n      actions.append(4)  # USE\n      \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Sort ingredients by distance to the agent's current position\n  sorted_ingredients = sorted(ingredients, key=lambda x: abs(env._current_state.pos[0]-get_item_position(env._current_state.grid, x)[0]) + abs(env._current_state.pos[1]-get_item_position(env._current_state.grid, x)[1]))\n  \n  for ingredient_index in sorted_ingredients:\n    while not env._current_state.inventory[ingredient_index] >= ingredients[ingredient_index]:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    craftable = True\n    for ingredient, count in recipe.items():\n      if inventory[ingredient] < count:\n        craftable = False\n        break\n    if not craftable:\n      return actions\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    goal_idx = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  def find_closest_ingredient(ingredients):\n    closest = None\n    min_dist = float('inf')\n    for ingredient_idx in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient_idx)\n      dist = np.sum(np.abs(pos - env.state.pos))\n      if dist < min_dist:\n        closest = pos[0]\n        min_dist = dist\n    return (closest, ingredients[0]) if closest else (None, None)\n  \n  actions = []\n  ingredients = get_ingredients()\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    ingredients.remove(ingredient_idx)\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    # Find the closest ingredient to the agent's current position\n    closest_ingredient_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_ingredient_pos = pos\n        min_distance = distance\n    \n    if not closest_ingredient_pos:\n      break\n    \n    rel_pos = closest_ingredient_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[closest_ingredient_pos[0]] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[closest_ingredient_pos[0]] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(closest_ingredient_pos[0])\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Sort ingredients by their distance to the agent for efficient pickup\n  sorted_ingredients = sorted(ingredients.items(), key=lambda x: abs(x[0][0]-env._current_state.pos[0]) + abs(x[0][1]-env._current_state.pos[1]))\n\n  for ingredient_index, count in sorted_ingredients:\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Pickup ingredients needed for the craft\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    ingredient_idx = None\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = i\n    \n    return (closest_pos, ingredient_idx) if closest_pos is not None else (None, None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      new_state = env.state.step(direction)\n      env.state = new_state\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft the final product\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      new_inventory = env.state.inventory.copy()\n      new_inventory[ingredient_idx] -= 1\n      env.state = CraftState(env.scenario, env.state.grid, env.state.pos, env.state.dir, new_inventory)\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_inventory(env, ingredient_index):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    while not find_item_in_inventory(env, ingredient_index):\n      # If the item is not found in inventory, try to pick it up from the world\n      if env.next_to(ingredient_index):\n        actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n      else:\n        break\n    if find_item_in_inventory(env, ingredient_index):\n      actions.extend([4] * count)  # USE action index for each instance of the ingredient found\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Retrieve the index for the goal item and its recipe\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize the list to store actions\n  actions = []\n\n  # Helper function to find an item and use it if possible\n  def find_and_use_item(env, ingredient_index, count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # Use the item as many times as needed\n        actions.extend([4] * count)  # USE action index repeated for each use\n        break\n      elif env.inventory[i] == 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # If the item is not in inventory, pick it up\n        actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n        break\n      else:\n        # Move around to find the item if necessary\n        move_actions = []\n        pos = env.pos\n        while True:\n          if pos[0] > 0 and env.grid[pos[0]-1, pos[1], ingredient_index] == 0:\n            move_actions.append(1) # UP action index\n            pos = (pos[0]-1, pos[1])\n          elif pos[0] < env.grid.shape[0]-1 and env.grid[pos[0]+1, pos[1], ingredient_index] == 0:\n            move_actions.append(3) # DOWN action index\n            pos = (pos[0]+1, pos[1])\n          elif pos[1] > 0 and env.grid[pos[0], pos[1]-1, ingredient_index] == 0:\n            move_actions.append(2) # LEFT action index\n            pos = (pos[0], pos[1]-1)\n          elif pos[1] < env.grid.shape[1]-1 and env.grid[pos[0], pos[1]+1, ingredient_index] == 0:\n            move_actions.append(4) # RIGHT action index\n            pos = (pos[0], pos[1]+1)\n          else:\n            break\n        actions.extend(move_actions)\n  \n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_use_item(env, ingredient_index, count)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if found:\n          break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  recipe = get_recipe(goal_idx)\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] > 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient if not already close enough\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n      recipe = get_recipe(goal_idx)  # Update the recipe since inventory might have changed\n      if not recipe:\n        break\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required primitives for crafting the item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Get the current inventory of items needed for crafting\n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in required_items.items():\n      if count > inventory[item_idx]:\n        # Find the position of the missing item and move towards it\n        pos = env.state.pos\n        grid = env.state.grid\n        found = False\n        for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n          for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n            if grid[x, y, item_idx] > 0:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # If we have enough items, craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the requirements for crafting the desired item.\n  def get_requirements(item):\n    indices = [item]\n    requirements = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to check their requirements recursively.\n    return requirements\n\n  # Generate a sequence of actions to craft the item based on its requirements.\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, np.argwhere(env.state.grid == i)[0]) for i in recipe if env.state.inventory[i] < 1]\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  ingredients = get_ingredients(goal_idx)\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    steps = abs(rel_pos[direction])\n    if steps > 0:\n      actions += [direction] * int(steps)\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    ingredients.remove((ingredient_idx, closest_pos))\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    goal_idx = cookbook.index.get(item)\n    if goal_idx is None:\n      raise ValueError(\"Unknown item to craft\")\n    \n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [(i, np.argwhere(env.state.grid == i)[0]) for i in recipe]\n  \n  cookbook = env.world.cookbook\n  ingredients = get_ingredients()\n\n  actions = []\n  while len(ingredients) > 0:\n    closest_pos, _ = find_closest_ingredient(ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    ingredients.remove(closest_pos)\n    \n    if not ingredients:\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Find the most needed ingredient to craft the item\n    available_items = {ingredient: inventory[ingredient] for ingredient in recipe.keys()}\n    \n    # If no item is next to the agent, break the loop\n    if not available_items:\n      break\n    \n    most_needed_item = max(available_items, key=lambda x: (x[1], env.world.grabbable_indices.index(x[0])))[0]\n    count_needed = min(recipe[most_needed_item], inventory[most_needed_item])\n    \n    # Append the actions to pick up and use the item until the recipe is satisfied\n    for _ in range(count_needed):\n      actions.append(env.world.grabbable_indices.index(most_needed_item))\n      inventory = env._current_state.inventory\n      \n      # Check if the crafted item is available now\n      recipe = get_recipe(item)\n      if all(inventory[ingredient] > 0 for ingredient in recipe):\n        break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  # Find the most abundant ingredients first and craft them\n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    \n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        break\n    \n    # If no more items can be crafted, we stop crafting\n    if not craftable(inventory, recipe):\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    current = [item]\n    while len(current) > 0:\n      next_item = current.pop()\n      if next_item not in requirements:\n        reqs = env.world.cookbook.primitives_for(next_item)\n        if reqs:\n          requirements[next_item] = reqs\n          # Add the required components to the current list to check their requirements recursively.\n          for k, v in reqs.items():\n            current += [k] * v\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    while len(requirements) > 0:\n      next_craftable = None\n      for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n        if all(env.world.cookbook.primitives_for(key).values()):\n          continue  # Skip items that are already crafted or can be directly grabbed.\n        next_craftable = key\n        break\n      if not next_craftable:\n        break\n      \n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n      del requirements[next_craftable]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    indices = [item]\n    requirement_dict = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirement_dict:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirement_dict[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirement_dict[current].items():\n        if k not in requirement_dict:\n          indices.append(k)\n    return requirement_dict\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [k] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  def craft_ingredient(env, ingredient_index):\n    position = find_item(env.grid, ingredient_index)\n    if position is None: \n      raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n    \n    dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    while dx != 0 or dy != 0:\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      env.step(actions[-1])\n      position = find_item(env.grid, ingredient_index)\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    \n    if position != env.pos: \n      actions.append(4)  # USE to pick up the ingredient if not already at its location\n      env.step(actions[-1])\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Find and craft all ingredients required by the current recipe\n    for ingredient_index in ingredient_indices:\n      craft_ingredient(env, ingredient_index)\n    \n    # Update the recipe for the next iteration, now that we have crafted this ingredient\n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation here\n  \n  return []", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n\n  actions = []\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    # Find and collect all ingredients required by the current recipe\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Iterate through each ingredient to find its position in the grid and pick it up\n    for ingredient_index in ingredient_indices:\n      found = False\n      for x in range(env.grid.shape[0]):\n        for y in range(env.grid.shape[1]):\n          if np.any(env.grid[x, y] == ingredient_index):\n            # Calculate the necessary movement to reach and pick up the ingredient\n            dx = x - env.pos[0]\n            dy = y - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            if not found: actions.append(4)  # USE to pick up the ingredient\n            found = True\n            break\n        if found: break\n      \n      # Update the recipe for the next iteration, now that we have collected this ingredient\n      del recipe[ingredient_index]\n    \n    # If there are still nested dictionaries left in the recipe, it means we need to find specific items later when they're available\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Check if we have enough ingredients to craft the item at least once\n  while sum(inventory[i] for i in recipe) > 0:\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True)\n    \n    crafted = False\n    for ingredient, count in sorted_ingredients:\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n        break  # Only one ingredient should be used at a time to craft the item\n    \n    if not crafted:\n      break  # If no ingredients can be used, stop crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item from the cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_closest_ingredient(ingredients):\n    if not ingredients:\n      return None\n    closest = min(ingredients, key=lambda x: np.linalg.norm(np.array(env.state.pos) - np.array(x[1])))\n    return closest\n\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  actions = []\n  \n  while len(recipe) > 0:\n    closest_pos, ingredient_index = get_closest_ingredient(list(recipe.items()))\n    \n    if not closest_pos:\n      break  # No more ingredients needed, crafting is complete\n    \n    rel_pos = np.array(env.state.pos) - np.array(closest_pos[1])\n    \n    direction = np.argmax(np.abs(rel_pos))\n    \n    if not np.all(np.abs(rel_pos) <= 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_closest_ingredient_pos(ingredients):\n    closest = None\n    min_dist = float('inf')\n    for i, count in ingredients:\n      pos = np.argwhere(env.state.grid == i)[0]\n      dist = np.sum(np.abs(pos - env.state.pos))\n      if dist < min_dist:\n        closest = pos\n        min_dist = dist\n    return closest, ingredients.index((closest[0], i))\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  actions = []\n  recipe = {i: count for i, count in cookbook.primitives_for(goal_idx).items() if env.state.inventory[i] == 0}\n  \n  while len(recipe) > 0:\n    closest_pos, idx = get_closest_ingredient_pos(list(recipe.items()))\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[closest_pos[0]] -= 1\n    del recipe[list(recipe.keys())[idx]]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  def craft_ingredient(env, ingredient_index):\n    position = find_item(env.grid, ingredient_index)\n    if position is None: \n      raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n    \n    dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    while dx != 0 or dy != 0:\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      env.step(actions[-1])\n      position = find_item(env.grid, ingredient_index)\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    \n    if position != env.pos: \n      actions.append(4)  # USE to pick up the ingredient if not already at its location\n      env.step(actions[-1])\n  \n  def craft_all_ingredients(env, recipe):\n    while any(isinstance(value, dict) for value in recipe.values()):\n      ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n      \n      # Find and craft all ingredients required by the current recipe\n      for ingredient_index in ingredient_indices:\n        craft_ingredient(env, ingredient_index)\n      \n      # Update the recipe for the next iteration, now that we have crafted this ingredient\n      del recipe[ingredient_index]\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  craft_all_ingredients(env, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  def craft_ingredient(env, ingredient_index):\n    position = find_item(env.grid, ingredient_index)\n    if position is None: \n      raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n    \n    dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    while dx != 0 or dy != 0:\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      env.step(actions[-1])\n      position = find_item(env.grid, ingredient_index)\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n    \n    if position != env.pos: \n      actions.append(4)  # USE to pick up the ingredient if not already at its location\n      env.step(actions[-1])\n  \n  def craft_recipe(env, item):\n    recipe = env.world.cookbook.recipes[item]\n    while any(isinstance(value, dict) for value in recipe.values()):\n      ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n      \n      # Find and craft all ingredients required by the current recipe\n      for ingredient_index in ingredient_indices:\n        craft_ingredient(env, ingredient_index)\n      \n      # Update the recipe for the next iteration, now that we have crafted this ingredient\n      del recipe[ingredient_index]\n  \n  actions = []\n  craft_recipe(env, item)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n    while inventory[ingredient] >= count:\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  \n  while True:\n    craftable = all(env._current_state.inventory[ingredient] >= count for ingredient, count in recipe.items())\n    if not craftable:\n      break\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  # Check if we have any recipes that can produce this item\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  \n  while True:\n    # Find the next ingredient to collect and craft from the recipe\n    current_ingredient_index = next((i for i, count in recipe.items() if i not in env.state.inventory), None)\n    \n    if current_ingredient_index is None:\n      break  # No more ingredients needed, crafting is complete\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      # Move towards the ingredient\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n    # Remove the used ingredient from the recipe to track progress\n    del recipe[current_ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  def find_ingredient(recipe):\n    for ingredient, count in recipe.items():\n      if ingredient not in env.state.inventory and env.state.grid[env.state.pos] != ingredient:\n        return ingredient\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = get_recipe(goal_idx)\n  actions = []\n  \n  while recipe:\n    ingredient = find_ingredient(recipe)\n    \n    if not ingredient:\n      break  # No more ingredients needed, crafting is complete\n    \n    target_pos = np.argwhere(env.state.grid == ingredient)[0]\n    rel_pos = target_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    while not (env.state.grid[tuple(env.state.pos)] == ingredient and env.state.inventory[ingredient] > 0):\n      actions.append(4)  # USE action\n      time.sleep(1)  # Wait for the craft to complete\n    \n    del recipe[ingredient]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    # Prioritize grabbing items that are needed the most based on the current inventory and required count in the recipe\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: (x[1] - env._current_state.inventory[x[0]], -env._current_state.inventory[x[0]]))\n    \n    for ingredient, count in sorted_ingredients:\n      if count > 0 and inventory[ingredient] < count:\n        while count > 0 and inventory[ingredient] < count:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory = env._current_state.inventory\n          count -= 1\n    \n    recipe = {i: c for i, c in recipe.items() if inventory[i] < c}\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    # Find the ingredient index in the environment's inventory\n    if env.inventory[ingredient_index] <= 0:\n      # If the ingredient is not in the inventory, try to pick it up from the world\n      while True:\n        for action in [2, 3, 0, 1]:  # Try all possible pickup actions\n          if env.next_to(ingredient_index):\n            actions.append(4 + action)  # USE and then move to the position of the ingredient\n            break\n        else:\n          break  # If no valid action is found, stop trying\n      continue  # Skip checking inventory after attempting a pickup\n    # If the ingredient is in the inventory, add 'USE' actions for each count of the ingredient found\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    while not env.satisfies(ingredient_index, goal_index):\n      if env.next_to(ingredient_index):\n        actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n      else:\n        break\n    if env.satisfies(ingredient_index, goal_index):\n      actions.extend([4] * count)  # USE action index for each instance of the ingredient found\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n\n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  def move_to_and_use(env, target_position):\n    dx, dy = target_position[0] - env.pos[0], target_position[1] - env.pos[1]\n    actions = []\n    if dx < 0: actions.append(2)  # LEFT\n    elif dx > 0: actions.append(3)  # RIGHT\n    elif dy < 0: actions.append(1)  # UP\n    elif dy > 0: actions.append(0)  # DOWN\n    if (dx, dy) != (0, 0): actions.append(4)  # USE\n    return actions\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      actions += move_to_and_use(env, position)\n      \n      # Update the recipe for the next iteration, now that we have collected this ingredient\n      del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(env, index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  def craft_required_items(env, recipe):\n    required_items = []\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item(env, sub_ingredient_index)\n          if position:\n            required_items.append((sub_ingredient_index, position))\n      else:\n        # If the count is a direct index of an item that can be grabbed directly\n        position = find_item(env, ingredient_index)\n        if position:\n          required_items.append((ingredient_index, position))\n    return required_items\n\n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    required_items = craft_required_items(env, recipe)\n    \n    # Move towards each required item and use them to craft other items\n    for ingredient_index, position in required_items:\n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if dx < 0: actions.append(2)  # LEFT\n      elif dx > 0: actions.append(3)  # RIGHT\n      elif dy < 0: actions.append(1)  # UP\n      elif dy > 0: actions.append(0)  # DOWN\n      if position != env.pos: actions.append(4)  # USE to pick up the ingredient if not already at its location\n      \n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, index):\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if np.any(grid[x, y] == index):\n          return (x, y)\n    return None\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Find and collect all ingredients required by the current recipe\n    for ingredient_index in ingredient_indices:\n      position = find_item(env.grid, ingredient_index)\n      if position is None: \n        raise ValueError(f\"Item with index {ingredient_index} not found in the grid.\")\n      \n      dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      while dx != 0 or dy != 0:\n        if dx < 0 and env.grid[env.pos[0]-1, env.pos[1]] == 0: actions.append(2)  # LEFT\n        elif dx > 0 and env.grid[env.pos[0]+1, env.pos[1]] == 0: actions.append(3)  # RIGHT\n        elif dy < 0 and env.grid[env.pos[0], env.pos[1]-1] == 0: actions.append(1)  # UP\n        elif dy > 0 and env.grid[env.pos[0], env.pos[1]+1] == 0: actions.append(0)  # DOWN\n        dx, dy = position[0] - env.pos[0], position[1] - env.pos[1]\n      if position != env.pos: actions.append(4)  # USE to pick up the ingredient if not already at its location\n    \n    # Update the recipe for the next iteration, now that we have collected this ingredient\n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Initialize a list to store actions\n  actions = []\n  \n  # Helper function to find and pick up items based on indices\n  def find_and_pickup(ingredient_index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == ingredient_index) and env.world.cookbook.reverse_contents[ingredient_index] not in env.non_grabbable_indices:\n          dx = x - env.pos[0]\n          dy = y - env.pos[1]\n          if dx < 0: actions.append(2)  # LEFT\n          elif dx > 0: actions.append(3)  # RIGHT\n          elif dy < 0: actions.append(1)  # UP\n          elif dy > 0: actions.append(0)  # DOWN\n          actions.append(4)  # USE\n          return True\n    return False\n  \n  # Iterate through the ingredients in the recipe to craft the item\n  while any(isinstance(value, dict) for value in recipe.values()):\n    found = False\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          if not found:\n            found = find_and_pickup(sub_ingredient_index)\n      else:\n        if not found:\n          found = find_and_pickup(ingredient_index)\n    # If the ingredient is not grabbable, we need to find it again later when it's available\n    if not found:\n      pass\n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_grid(env, item_index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == item_index):\n          return (x, y)\n    return None\n\n  actions = []\n  \n  # Get the recipe for the item\n  recipe = env.world.cookbook.recipes[item]\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    found_all = False\n    for ingredient_index, count in list(recipe.items()):  # Iterate over a copy of the dictionary to modify it\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        positions = []\n        for sub_ingredient_index, sub_count in count.items():\n          position = find_item_in_grid(env, sub_ingredient_index)\n          if position:\n            positions.append(position)\n            recipe[ingredient_index] = {sub_ingredient_index: 1}  # Replace the nested dictionary with direct index for further processing\n            del recipe[ingredient_index + count]  # Remove the original entry to avoid reprocessing it\n        if len(positions) == sum(count.values()):  # Check if all positions were found\n          for pos in positions:\n            dx = pos[0] - env.pos[0]\n            dy = pos[1] - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            actions.append(4)  # USE\n          found_all = True\n      else:\n        position = find_item_in_grid(env, ingredient_index)\n        if position:\n          dx = position[0] - env.pos[0]\n          dy = position[1] - env.pos[1]\n          if dx < 0: actions.append(2)  # LEFT\n          elif dx > 0: actions.append(3)  # RIGHT\n          elif dy < 0: actions.append(1)  # UP\n          elif dy > 0: actions.append(0)  # DOWN\n          actions.append(4)  # USE\n        else:\n          found_all = False\n          break\n    if not found_all:\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env.state.inventory\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  # Check if we have any recipes that can produce this item\n  recipe = cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    # Find the next ingredient to use in crafting with available inventory\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] == 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    # Find the position of the ingredient in the grid\n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    \n    # Calculate the relative position to move towards the ingredient\n    rel_pos = ingredient_pos - env.state.pos\n    \n    # Move towards the ingredient (if not already adjacent)\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product (if not already used in crafting)\n    if env.state.inventory[current_ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    craftable = True\n    for ingredient, count in sorted(recipe.items(), key=lambda x: inventory[x[0]], reverse=True):\n      if inventory[ingredient] < count:\n        craftable = False\n        break\n    if not craftable:\n      break\n    for ingredient, count in recipe.items():\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    craftable = True\n    needed_ingredients = {k: v for k, v in recipe.items() if inventory[k] < v}\n    available_ingredients = {k: v for k, v in recipe.items() if inventory[k] >= v}\n    \n    # If there are any ingredients that cannot be crafted, stop trying to craft the item\n    if not available_ingredients:\n      break\n\n    # Sort by the least amount needed first\n    sorted_needed = sorted(needed_ingredients.items(), key=lambda x: inventory[x[0]])\n    \n    for ingredient, count in sorted_needed:\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    actions.extend([env.world.grabbable_indices.index(ingredient) for ingredient, count in sorted(recipe.items(), key=lambda x: -x[1])])\n    inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    ingredients_to_craft = []\n    for ingredient, count in reversed(list(recipe.items())):\n      while inventory[ingredient] >= count:\n        ingredients_to_craft.append(env.world.grabbable_indices.index(ingredient))\n        inventory = env._current_state.inventory\n    actions.extend(reversed(ingredients_to_craft))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n\n  def pickup_ingredient(index):\n    pos = None\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index) and env.world.cookbook.reverse_contents[index] not in env.non_grabbable_indices:\n          pos = (x, y)\n          break\n      if pos is not None:\n        break\n    \n    if pos is not None:\n      dx = pos[0] - env.pos[0]\n      dy = pos[1] - env.pos[1]\n      if dx < 0: actions.append(2) # LEFT\n      elif dx > 0: actions.append(3) # RIGHT\n      elif dy < 0: actions.append(1) # UP\n      elif dy > 0: actions.append(0) # DOWN\n      actions.append(4) # USE\n\n  def craft_ingredient(index):\n    pos = None\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == index) and env.world.cookbook.reverse_contents[index] not in env.non_grabbable_indices:\n          pos = (x, y)\n          break\n      if pos is not None:\n        break\n    \n    if pos is not None:\n      dx = pos[0] - env.pos[0]\n      dy = pos[1] - env.pos[1]\n      if dx < 0: actions.append(2) # LEFT\n      elif dx > 0: actions.append(3) # RIGHT\n      elif dy < 0: actions.append(1) # UP\n      elif dy > 0: actions.append(0) # DOWN\n      actions.append(4) # USE\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    found = False\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):  # If the count is a nested dictionary, it means we need to find specific items\n        for sub_ingredient_index, sub_count in count.items():\n          if not found:\n            craft_ingredient(sub_ingredient_index)\n            pickup_ingredient(sub_ingredient_index)\n            found = True\n      else:\n        if not found:\n          craft_ingredient(ingredient_index)\n          pickup_ingredient(ingredient_index)\n          found = True\n    recipe = env.world.cookbook.recipes[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    ingredient_idx = None\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        idx_dist = np.argmin(dist)\n        if closest_pos is None or dist[idx_dist] < np.sum(np.abs(closest_pos - env.state.pos)):\n          closest_pos = pos[idx_dist]\n          ingredient_idx = i\n    \n    return (closest_pos, ingredient_idx) if closest_pos is not None else (None, None)\n  \n  actions = []\n  goal_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count - env.state.inventory[i]) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  while len(ingredients) > 0:\n    closest_pos, ingredient_idx = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft the final product\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_idx] -= 1\n      ingredients = [(i, count - env.state.inventory[i]) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def find_and_craft(goal):\n    recipe = get_recipe(goal)\n    inventory = env._current_state.inventory\n    actions = []\n    \n    while sum(inventory[i] for i in recipe) > 0:\n      crafted = False\n      # Sort ingredients by how many are already in the inventory to prioritize crafting those that need more\n      sorted_ingredients = sorted(recipe.items(), key=lambda x: env._current_state.inventory[x[0]])\n      for ingredient, count in sorted_ingredients:\n        if inventory[ingredient] >= count:\n          actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n          crafted = True\n          break\n      if not crafted:\n        # Try to find and craft the item directly from the environment\n        for i in range(len(inventory)):\n          if inventory[i] > 0 and env.world.cookbook.index.get(i) == goal:\n            actions.append(env.world.grabbable_indices.index(i))\n            break\n      inventory = env._current_state.inventory\n    \n    return actions\n  \n  # Find the recipe for the desired item and craft it\n  return find_and_craft(item)", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def find_and_craft(goal):\n    recipe = get_recipe(goal)\n    inventory = env._current_state.inventory\n    actions = []\n    \n    while sum(inventory[i] for i in recipe) > 0:\n      crafted = False\n      # Sort ingredients by what's available, starting with the least available first\n      sorted_ingredients = sorted(recipe.items(), key=lambda x: env._current_state.inventory[x[0]])\n      for ingredient, count in sorted_ingredients:\n        while inventory[ingredient] > 0 and count > 0:\n          actions.append(env.world.grabbable_indices.index(ingredient))\n          inventory[ingredient] -= 1\n          count -= 1\n      if all(count == 0 for _, count in sorted_ingredients):\n        # If we've crafted everything that could be crafted, break the loop\n        break\n    \n    return actions\n  \n  # Find the recipe for the desired item and craft it\n  return find_and_craft(item)", "occurrence_count": 1}
{"function_body": "  def get_closest_ingredient(env, goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    if not recipe:\n      return None\n    \n    for ingredient_index, count in recipe.items():\n      if ingredient_index not in env.state.inventory or env.state.inventory[ingredient_index] == 0:\n        positions = np.argwhere(env.state.grid == ingredient_index)\n        if len(positions) > 0:\n          distances = np.linalg.norm(positions - env.state.pos, axis=1)\n          closest_pos = positions[np.argmin(distances)]\n          rel_pos = closest_pos - env.state.pos\n          return (ingredient_index, rel_pos)\n    return None\n\n  def move_to(env, target_pos):\n    current_pos = np.array(env.state.pos)\n    target_pos = np.array(target_pos)\n    diff = target_pos - current_pos\n    if np.any(diff != 0):\n      direction = np.argmax(np.abs(diff))\n      actions = [direction] * abs(diff[direction])\n      env.step(actions[0])  # Perform the movement action\n      return True\n    return False\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  while True:\n    ingredient = get_closest_ingredient(env, goal_idx)\n    if ingredient is None:\n      break\n    \n    ingredient_index, rel_pos = ingredient\n    target_pos = np.array(env.state.pos) + rel_pos\n    \n    # Move to the closest ingredient position if not already there\n    moved = move_to(env, target_pos)\n    if not moved:\n      continue\n    \n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in recipe) > 0:\n    if not craftable(inventory, recipe):\n      break\n    \n    most_available_items = [(ingredient, inventory[ingredient]) for ingredient in recipe if inventory[ingredient] > 0]\n    most_available_items.sort(key=lambda x: -x[1])  # Sort by availability descending\n    \n    for ingredient, _ in most_available_items:\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n      recipe = get_recipe(item)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while True:\n    recipe = get_recipe(item)\n    if not craftable(inventory, recipe):\n      break\n    for ingredient, count in recipe.items():\n      available_count = min(inventory[ingredient], count)\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * available_count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  inventory = env._current_state.inventory\n  \n  # Create a list of (ingredient, count) tuples sorted by the amount in inventory, descending\n  ingredient_counts = [(ingredient, count) for ingredient, count in recipe.items()]\n  ingredient_counts.sort(key=lambda x: inventory[x[0]], reverse=True)\n  \n  for ingredient, _ in ingredient_counts:\n    while inventory[ingredient] > 0 and recipe[ingredient] > 0:\n      actions.append(env.world.grabbable_indices.index(ingredient))\n      inventory = env._current_state.inventory\n      recipe[ingredient] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    actions.extend([env.world.grabbable_indices.index(ingredient) for ingredient, count in sorted(recipe.items(), key=lambda x: -inventory[x[0]])])\n    inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    ingredients = [ingredient for ingredient in env.world.cookbook.index if recipe.get(ingredient, None)]\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in ingredients:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, ingredients[0] if ingredients else None\n  \n  def move_to_ingredient():\n    closest_pos, _ = find_closest_ingredient()\n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    if np.any(np.abs(rel_pos) > 1):\n      return [direction] * abs(rel_pos[direction])\n    else:\n      return []\n  \n  def use_ingredient():\n    closest_pos, _ = find_closest_ingredient()\n    if env.state.inventory[closest_pos[0]] > 0:\n      return [4]  # USE action\n    else:\n      return []\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  ingredients = list(recipe.keys())\n  \n  actions = []\n  \n  while ingredients:\n    move_actions = move_to_ingredient()\n    if move_actions:\n      actions += move_actions\n    \n    use_actions = use_ingredient()\n    if use_actions:\n      actions += use_actions\n      \n    # Remove the used ingredient from the recipe to track progress\n    ingredients.remove(next(key for key in recipe if env.state.inventory[key] > 0))\n    \n    if not ingredients:\n      break  # No more ingredients needed, crafting is complete\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    min_distance = float('inf')\n    \n    for ingredient in recipe:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance and env.state.inventory[ingredient] > 0:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, ingredient if closest_pos is not None else None\n\n  def move_to_ingredient():\n    actions = []\n    for ingredient in recipe:\n      pos = np.argwhere(env.state.grid == ingredient)[0]\n      rel_pos = pos - env.state.pos\n      direction = np.argmax(np.abs(rel_pos))\n      \n      if np.any(np.abs(rel_pos) > 1):\n        actions += [direction] * abs(rel_pos[direction])\n    \n    return actions\n  \n  def use_ingredient():\n    for ingredient in recipe:\n      if env.state.inventory[ingredient] > 0 and np.array_equal(env.state.grid[tuple(env.state.pos + rel_pos)], ingredient):\n        return [4]  # USE action\n    return []\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index[item]\n  recipe = {ingredient: count for ingredient, count in env.world.cookbook.primitives_for(goal_idx).items()}\n  \n  actions = move_to_ingredient()\n  actions += use_ingredient()\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  actions = []\n  recipe = get_recipe(item)\n  \n  while sum(env._current_state.inventory[i] for i in recipe) > 0:\n    craftable = True\n    needed_ingredients = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n    available_ingredients = {k: v for k, v in recipe.items() if env._current_state.inventory[k] >= v}\n    \n    # If there are any ingredients that cannot be crafted, stop trying to craft the item\n    if not available_ingredients:\n      break\n    \n    # Sort by the least amount needed first\n    sorted_needed = sorted(needed_ingredients.items(), key=lambda x: env._current_state.inventory[x[0]])\n    \n    for ingredient, count in sorted_needed:\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable_items(inventory):\n    recipe = get_recipe(item)\n    return {k: v for k, v in recipe.items() if inventory[k] >= v}\n  \n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    craftable_items_list = list(craftable_items(inventory).keys())\n    \n    if not craftable_items_list:\n      break\n    \n    # If there are any ingredients that cannot be crafted, stop trying to craft the item\n    for ingredient in craftable_items_list:\n      actions.extend([env.world.grabbable_indices.index(ingredient)] * recipe[ingredient])\n      inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    output_index = env.world.cookbook.recipes.get(item, {})\n    ingredients = {}\n    for ingredient_index, count in output_index.items():\n      if isinstance(ingredient_index, int) and ingredient_index != \"_key\":\n        ingredients[ingredient_index] = count\n    return ingredients\n\n  def craftable(inventory, recipe):\n    return all(inventory[i] >= c for i, c in recipe.items())\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  while sum(inventory[i] for i in get_recipe(item)) > 0:\n    if not craftable(inventory, get_recipe(item)):\n      break\n    recipe = get_recipe(item)\n    sorted_ingredients = sorted(recipe.items(), key=lambda x: -x[1])\n    for ingredient, count in reversed(list(sorted_ingredients)):\n      if inventory[ingredient] >= count:\n        actions.extend([env.world.grabbable_indices.index(ingredient)] * count)\n        inventory = env._current_state.inventory\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    inventory = env.state.inventory\n    grid = env.state.grid\n    for idx in range(len(inventory)):\n      if inventory[idx] > 0:\n        pos = np.argwhere(grid == idx)\n        if not any((env.state.pos + np.array([dx, dy]) == p).all() for p in pos):\n          return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient()\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if ingredient_index in env.state.inventory and env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    inventory = env.state.inventory\n    grid = env.state.grid\n    for idx in env.world.kinds:\n      if idx in inventory and not any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient()\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    del recipe[ingredient_index]  # Remove the used ingredient from the recipe to track progress\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    inventory = env.state.inventory\n    grid = env.state.grid\n    for idx in env.world.kinds:\n      if idx in inventory and not any(np.array_equal(env.state.pos + np.array([dx, dy]), ingredient_pos) for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]):\n        return idx\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = env.world.cookbook.primitives_for(goal_idx)\n  if not recipe:\n    return []\n\n  actions = []\n\n  while True:\n    ingredient_index = find_ingredient()\n    if ingredient_index is None:\n      break\n\n    ingredient_pos = np.argwhere(env.state.grid == ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n\n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n\n    if env.state.inventory[ingredient_index] > 0:\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the full crafting recipe for the specified item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Initialize a list to store actions\n  actions = []\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    # Find and collect all ingredients required by the current recipe\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Iterate through each ingredient to find its position in the grid and pick it up\n    for ingredient_index in ingredient_indices:\n      found = False\n      for x in range(env.grid.shape[0]):\n        for y in range(env.grid.shape[1]):\n          if np.any(env.grid[x, y] == ingredient_index):\n            # Calculate the necessary movement to reach and pick up the ingredient\n            dx = x - env.pos[0]\n            dy = y - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            if not found: actions.append(4)  # USE to pick up the ingredient\n            found = True\n            break\n        if found: break\n      \n      # Update the recipe for the next iteration, now that we have collected this ingredient\n      del recipe[ingredient_index]\n    \n    # If there are still nested dictionaries left in the recipe, it means we need to find specific items later when they're available\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(recipe):\n    ingredients = []\n    for ingredient_index in recipe:\n      if isinstance(recipe[ingredient_index], int):\n        ingredients.append((ingredient_index, 1))\n      else:\n        nested_ingredients = list(recipe[ingredient_index].keys())\n        ingredients.extend([(nested_ingr, count) for nested_ingr in nested_ingredients])\n    return ingredients\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  while any(isinstance(value, dict) for value in recipe.values()):\n    # Find and collect all ingredients required by the current recipe\n    ingredients = get_ingredients(recipe)\n    \n    # Iterate through each ingredient to find its position in the grid and pick it up\n    for ingredient_index, count in ingredients:\n      found = False\n      for x in range(env.grid.shape[0]):\n        for y in range(env.grid.shape[1]):\n          if np.any(env.grid[x, y] == ingredient_index):\n            # Calculate the necessary movement to reach and pick up the ingredient\n            dx = x - env.pos[0]\n            dy = y - env.pos[1]\n            if dx < 0: actions.append(2)  # LEFT\n            elif dx > 0: actions.append(3)  # RIGHT\n            elif dy < 0: actions.append(1)  # UP\n            elif dy > 0: actions.append(0)  # DOWN\n            if not found: actions.append(4)  # USE to pick up the ingredient\n            found = True\n            break\n        if found: break\n      \n      # If there are still nested dictionaries left in the recipe, it means we need to find specific items later when they're available\n      if isinstance(recipe[ingredient_index], dict):\n        del recipe[ingredient_index]\n    \n    # Update the recipe for the next iteration, now that we have collected this ingredient\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_pickup(ingredient_index):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if np.any(env.grid[x, y] == ingredient_index) and env.world.cookbook.reverse_contents[ingredient_index] not in env.non_grabbable_indices:\n          dx = x - env.pos[0]\n          dy = y - env.pos[1]\n          if dx < 0: return 2  # LEFT\n          elif dx > 0: return 3  # RIGHT\n          elif dy < 0: return 1  # UP\n          elif dy > 0: return 0  # DOWN\n          else: return 4  # USE\n    return None\n  \n  def craft_ingredient(ingredient_index):\n    actions = []\n    while any(isinstance(value, dict) for value in env.world.cookbook.recipes[ingredient_index].values()):\n      found = False\n      for sub_ingredient_index, count in env.world.cookbook.recipes[ingredient_index].items():\n        if isinstance(count, dict):\n          for sub_sub_ingredient_index, sub_sub_count in count.items():\n            if not found:\n              action = find_and_pickup(sub_sub_ingredient_index)\n              if action is not None:\n                actions.append(action)\n                found = True\n        else:\n          if not found:\n            action = find_and_pickup(sub_ingredient_index)\n            if action is not None:\n              actions.append(action)\n              found = True\n      ingredient_index = sub_ingredient_index\n    return actions, ingredient_index\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n  while any(isinstance(value, dict) for value in recipe.values()):\n    found = False\n    for ingredient_index, count in recipe.items():\n      if isinstance(count, dict):\n        for sub_ingredient_index, sub_count in count.items():\n          if not found:\n            action = find_and_pickup(sub_ingredient_index)\n            if action is not None:\n              actions.append(action)\n              found = True\n      else:\n        if not found:\n          action = find_and_pickup(ingredient_index)\n          if action is not None:\n            actions.append(action)\n            found = True\n    recipe = env.world.cookbook.recipes[ingredient_index]\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def find_closest_workshop(env):\n    workshop_indices = env.world.workshop_indices\n    pos = env._current_state.pos\n    min_dist = float('inf')\n    closest_workshop = None\n    for idx in workshop_indices:\n      dist = np.linalg.norm(np.array(pos) - np.array(env.world.grid[idx]))\n      if dist < min_dist:\n        min_dist = dist\n        closest_workshop = idx\n    return closest_workshop\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  workshop_idx = find_closest_workshop(env)\n  if workshop_idx is None:\n    raise ValueError(\"No workshop found to craft the item.\")\n  \n  # Move to the closest workshop\n  pos = env._current_state.pos\n  target_x, target_y = int(pos[0]), int(pos[1])\n  grid_width, grid_height = env.world.grid.shape[0], env.world.grid.shape[1]\n  \n  if target_x < workshop_idx[0]:\n    for _ in range(target_x + 1, workshop_idx[0]):\n      actions.append(3)  # RIGHT action\n  elif target_x > workshop_idx[0]:\n    for _ in range(workshop_idx[0], target_x):\n      actions.append(2)  # LEFT action\n  \n  if target_y < workshop_idx[1]:\n    for _ in range(target_y + 1, workshop_idx[1]):\n      actions.append(0)  # DOWN action\n  elif target_y > workshop_idx[1]:\n    for _ in range(workshop_idx[1], target_y):\n      actions.append(1)  # UP action\n  \n  # Craft the item at the workshop\n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to indices list to check their requirements recursively.\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  # Add a penalty for picking up and discarding items that are not directly needed.\n  extra_penalty = env._extra_pickup_penalty\n  adjusted_actions = []\n  for action in actions:\n    if action == env.world.grabble_indices.index:\n      # Check if the item can be picked up and is not required for crafting the final product.\n      current_item = env.scenario._current_state.inventory[item]\n      if current_item > 0:\n        adjusted_actions.append(action)\n      else:\n        adjusted_actions.append(env.world.non_grabbable_indices.index)\n    else:\n      adjusted_actions.append(action)\n  \n  # Remove unnecessary actions (e.g., picking up and discarding items not needed for crafting).\n  final_actions = []\n  for action in adjusted_actions:\n    if env.scenario._current_state.inventory[item] > 0 or action != env.world.grabble_indices.index:\n      final_actions.append(action)\n  \n  return final_actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    reqs = env.world.cookbook.primitives_for(item)\n    if not reqs:\n      return {}\n    requirements = {item: reqs}\n    for k, v in reqs.items():\n      sub_reqs = get_requirements(k)\n      if sub_reqs:\n        requirements[k] = sub_reqs\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  # Filter out actions that are not possible in the current state\n  valid_actions = []\n  for action in actions:\n    if env._is_valid_action(action):\n      valid_actions.append(action)\n\n  return valid_actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the environment's cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  if not recipe:\n    return []\n  \n  actions = []\n  inventory = env._current_state.inventory\n  grid = env._current_state.grid\n  pos = env._current_state.pos\n  \n  # Find the required items and their positions in the grid\n  for item_idx, count in recipe.items():\n    while count > 0:\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (pos[0]+dx, pos[1]+dy) == item_pos and grid[pos[0]+dx, pos[1]+dy, item_idx] > 0:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            count -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n  \n  # Craft the desired item and update inventory\n  actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_items(grid, indices):\n    positions = []\n    for index in indices:\n      position = np.argwhere(grid == index)\n      if len(position) > 0:\n        positions.append((int(position[0][0]), int(position[0][1])))\n    return positions\n  \n  def move_to(current, target):\n    dx, dy = target[0] - current[0], target[1] - current[1]\n    actions = []\n    while dx != 0 or dy != 0:\n      if dx < 0: \n        actions.append(2)  # LEFT\n        dx += 1\n      elif dx > 0: \n        actions.append(3)  # RIGHT\n        dx -= 1\n      elif dy < 0: \n        actions.append(1)  # UP\n        dy += 1\n      elif dy > 0: \n        actions.append(0)  # DOWN\n        dy -= 1\n    return actions\n  \n  def use_to_pickup(current, target):\n    if current != target:\n      dx, dy = target[0] - current[0], target[1] - current[1]\n      if dx < 0: actions.append([2])  # LEFT\n      elif dx > 0: actions.append([3])  # RIGHT\n      elif dy < 0: actions.append([1])  # UP\n      elif dy > 0: actions.append([0])  # DOWN\n      if current != target: actions.append(4)  # USE to pick up the ingredient if not already at its location\n  \n  actions = []\n  recipe = env.world.cookbook.recipes[item]\n\n  while any(isinstance(value, dict) for value in recipe.values()):\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if isinstance(recipe[ingredient_index], int)]\n    \n    # Find and collect all ingredients required by the current recipe\n    positions = find_items(env.grid, ingredient_indices)\n    for target in positions:\n      actions.extend(move_to(env.pos, target))\n      use_to_pickup(env.pos, target)\n    \n    # Update the recipe for the next iteration, now that we have collected this ingredient\n    del recipe[ingredient_index]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  def find_closest_ingredient():\n    inventory = np.where(env.state.inventory > 0)[0]\n    ingredient_positions = []\n    \n    for ingredient in inventory:\n      pos = np.argwhere(env.state.grid == ingredient)\n      if len(pos):\n        ingredient_positions.append((pos[0], ingredient))\n    \n    closest_pos = None\n    min_distance = float('inf')\n    \n    for pos, _ in ingredient_positions:\n      distance = np.sum(np.abs(pos - env.state.pos))\n      \n      if distance < min_distance:\n        closest_pos = pos\n        min_distance = distance\n    \n    return closest_pos, [k for k in recipe if recipe[k] == closest_pos][0] if ingredient_positions else None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = get_recipe(goal_idx)\n  actions = []\n  \n  while recipe:\n    closest_pos, next_ingredient = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient if not adjacent\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft if available in inventory\n    while env.state.grid[tuple(env.state.pos)] != next_ingredient or env.state.inventory[next_ingredient] <= 0:\n      actions.append(4)  # USE action\n      time.sleep(1)  # Wait for the craft to complete\n    \n    del recipe[next_ingredient]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  def find_ingredient(recipe):\n    for ingredient, count in recipe.items():\n      if ingredient not in env.state.inventory and env.state.grid[env.state.pos] != ingredient:\n        return ingredient\n    return None\n\n  goal_idx = env.world.cookbook.index.get(item)\n  \n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  recipe = get_recipe(goal_idx)\n  actions = []\n  \n  while recipe:\n    ingredient = find_ingredient(recipe)\n    \n    if not ingredient:\n      break  # No more ingredients needed, crafting is complete\n    \n    target_pos = np.argwhere(env.state.grid == ingredient)[0]\n    rel_pos = target_pos - env.state.pos\n    \n    direction = np.argmax(np.abs(rel_pos))\n    actions += [direction] * abs(rel_pos[direction])\n    \n    # Move to the position of the ingredient if not already there\n    while tuple(env.state.pos) != tuple(target_pos):\n      for action in [(0, -1), (0, 1), (-1, 0), (1, 0)]:  # UP, DOWN, LEFT, RIGHT\n        if env.state.grid[tuple(np.array(env.state.pos) + np.array(action))] != 0:\n          actions.append([-1, 1, -2, 2][list(action).index((max(action), min(action)))] / abs(max(action)))\n          break\n    \n    # Use the ingredient to craft if available in inventory\n    while not (env.state.grid[tuple(env.state.pos)] == ingredient and env.state.inventory[ingredient] > 0):\n      actions.append(4)  # USE action\n      time.sleep(1)  # Wait for the craft to complete\n    \n    del recipe[ingredient]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_closest_ingredient():\n    closest_pos = None\n    closest_distance = float('inf')\n    \n    for i in recipe:\n      pos = np.argwhere(env.state.grid == i)\n      if len(pos) > 0:\n        dist = np.sum(np.abs(pos - env.state.pos), axis=1)\n        avg_dist = np.mean(dist)\n        if closest_distance is None or avg_dist < closest_distance:\n          closest_distance = avg_dist\n          closest_pos = pos[np.argmin(dist)]\n    \n    return (closest_pos, recipe[closest_pos]) if closest_pos is not None else (None, None)\n  \n  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  recipe = cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n\n  actions = []\n\n  while len(ingredients) > 0:\n    closest_pos, ingredient_index = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient (if not already adjacent)\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft if available in inventory\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  goal_idx = cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n  \n  recipe = cookbook.primitives_for(goal_idx)\n  ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n\n  actions = []\n\n  while len(ingredients) > 0:\n    # Find the closest ingredient to pick up and move towards it\n    closest_pos, ingredient_index = find_closest_ingredient(env, ingredients)\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # Move towards the ingredient (if not already adjacent)\n    while np.any(np.abs(rel_pos) > 1):\n      actions.append(direction)\n      env.state.step(direction)\n      rel_pos = closest_pos - env.state.pos\n    \n    # Use the ingredient to craft if available in inventory\n    if np.all(np.abs(rel_pos) <= 1):\n      actions.append(4)  # USE action\n      env.state.inventory[ingredient_index] -= 1\n      ingredients = [(i, count) for i, count in recipe.items() if env.state.inventory[i] < count]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n        # Add the required components to indices list to check their requirements recursively.\n        indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    reqs = env.world.cookbook.primitives_for(item)\n    requirements = {} if not reqs else {item: reqs}\n    indices = list(reqs.keys())\n    while len(indices) > 0:\n      current = indices.pop()\n      for key, value in env.world.cookbook.primitives_for(current).items():\n        if key not in requirements:\n          requirements[key] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(key)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the indices and counts for crafting the specified item\n  recipe = env.world.cookbook.recipes[item]\n  ingredients = {name: count for name, count in recipe.items() if isinstance(name, int)}\n\n  # Initialize the list of actions\n  actions = []\n\n  # Iterate over each ingredient and its count\n  for ingredient_index, count in ingredients.items():\n    # Find where the ingredient is located in the inventory\n    while env._current_state.inventory[ingredient_index] > 0:\n      # If the ingredient is found in the inventory, pick it up and add the action to the list\n      actions.append(env.world.grabbable_indices.index(ingredient_index))\n      # Decrease the count of the ingredient in the inventory\n      env._current_state.inventory[ingredient_index] -= 1\n    else:\n      # If the ingredient is not found, move to a position where it might be located and search for it\n      while True:\n        # Find the position of the ingredient in the grid\n        pos = np.argwhere(env._current_state.grid[:, :, ingredient_index] > 0)\n        if len(pos) == 0:\n          # If the ingredient is not found, move to a random location and try again\n          actions.append(np.random.choice([0, 1, 2, 3]))\n        else:\n          # Move to the position of the ingredient\n          pos = tuple(pos[0])\n          if pos[0] < env._current_state.pos[0]:\n            actions.append(1)\n          elif pos[0] > env._current_state.pos[0]:\n            actions.append(0)\n          elif pos[1] < env._current_state.pos[1]:\n            actions.append(3)\n          else:\n            actions.append(2)\n          break\n\n  # Craft the item if all ingredients are found in the inventory or picked up and used to craft it\n  while np.sum(env._current_state.inventory[list(ingredients.keys())]) >= sum(ingredients.values()):\n    actions.append(4)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      for x in range(grid.shape[0]):\n        for y in range(grid.shape[1]):\n          if grid[x, y, z] != 0:\n            if z not in positions:\n              positions[z] = []\n            positions[z].append((x, y))\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if ingredient_index in positions and len(positions[ingredient_index]) > 0:\n        target_pos = positions[ingredient_index][0]\n        move_to(target_pos)\n        pickup()\n        # Remove the collected item from the position list to simulate picking it up\n        positions[ingredient_index].pop(0)\n      else:\n        break  # If no more items of this type are available, stop trying to pick them up\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_item(env, ingredient_index, count):\n    # Search for the ingredient in the grid and inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # USE action index repeated for each use\n        found = True\n        break\n      elif env.inventory[i] == 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n        found = True\n        break\n    if not found:\n      pos = env.pos\n      while True:\n        if pos[0] > 0 and env.grid[pos[0]-1, pos[1], ingredient_index] == 0:\n          actions.append(1) # UP action index\n          pos = (pos[0]-1, pos[1])\n        elif pos[0] < env.grid.shape[0]-1 and env.grid[pos[0]+1, pos[1], ingredient_index] == 0:\n          actions.append(3) # DOWN action index\n          pos = (pos[0]+1, pos[1])\n        elif pos[1] > 0 and env.grid[pos[0], pos[1]-1, ingredient_index] == 0:\n          actions.append(2) # LEFT action index\n          pos = (pos[0], pos[1]-1)\n        elif pos[1] < env.grid.shape[1]-1 and env.grid[pos[0], pos[1]+1, ingredient_index] == 0:\n          actions.append(4) # RIGHT action index\n          pos = (pos[0], pos[1]+1)\n        else:\n          break\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_use_item(env, ingredient_index, count)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Ensure the recipe is known and get it\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize the list to store actions\n  actions = []\n\n  # Helper function to find an item and use it if possible\n  def find_and_use_item(env, ingredient_index, count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # Use the item as many times as needed\n        actions.extend([4] * count)  # USE action index repeated for each use\n        break\n      elif env.inventory[i] == 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # If the item is not in inventory, pick it up\n        actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n        break\n      else:\n        # Move around to find the item if necessary\n        move_actions = []\n        pos = env.pos\n        while True:\n          if pos[0] > 0 and env.grid[pos[0]-1, pos[1], ingredient_index] == 0:\n            move_actions.append(1) # UP action index\n            pos = (pos[0]-1, pos[1])\n          elif pos[0] < env.grid.shape[0]-1 and env.grid[pos[0]+1, pos[1], ingredient_index] == 0:\n            move_actions.append(3) # DOWN action index\n            pos = (pos[0]+1, pos[1])\n          elif pos[1] > 0 and env.grid[pos[0], pos[1]-1, ingredient_index] == 0:\n            move_actions.append(2) # LEFT action index\n            pos = (pos[0], pos[1]-1)\n          elif pos[1] < env.grid.shape[1]-1 and env.grid[pos[0], pos[1]+1, ingredient_index] == 0:\n            move_actions.append(4) # RIGHT action index\n            pos = (pos[0], pos[1]+1)\n          else:\n            break\n        actions.extend(move_actions)\n  \n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_use_item(env, ingredient_index, count)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return {k: v for k, v in recipe.items() if env.state.inventory[k] > 0}\n  \n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  recipe = get_recipe(goal_idx)\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] > 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    if np.any(np.abs(rel_pos) > 1):\n      direction = np.argmax(np.abs(rel_pos))\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Move to the ingredient position and use it for crafting\n    if not np.array_equal(env.state.pos, ingredient_pos):\n      move_actions = []\n      while env.state.pos != ingredient_pos:\n        diff = ingredient_pos - env.state.pos\n        move_action = {0: 0, 1: 1, 2: 2, 3: 3}.get(np.argmax(np.abs(diff)), None)\n        if move_action is not None:\n          move_actions.append(move_action)\n      actions += move_actions\n    \n    # Use the ingredient for crafting\n    actions.append(4)\n    env.state.inventory[current_ingredient_index] -= 1\n    \n    recipe = get_recipe(goal_idx)  # Update the recipe since inventory might have changed\n    if not recipe:\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_idx):\n    return env.world.cookbook.primitives_for(goal_idx)\n  \n  goal_idx = env.world.cookbook.index.get(item)\n  if goal_idx is None:\n    raise ValueError(\"Unknown item to craft\")\n\n  actions = []\n  recipe = get_recipe(goal_idx)\n\n  while True:\n    current_ingredient_index = next((i for i, count in recipe.items() if env.state.inventory[i] > 0), None)\n    \n    if current_ingredient_index is None:\n      break\n    \n    ingredient_pos = np.argwhere(env.state.grid == current_ingredient_index)[0]\n    rel_pos = ingredient_pos - env.state.pos\n    \n    while not np.array_equal(env.state.pos, ingredient_pos):\n      if rel_pos[0] > 0:\n        actions.append(0)  # DOWN\n        env.state.pos = (env.state.pos[0] + 1, env.state.pos[1])\n      elif rel_pos[0] < 0:\n        actions.append(1)  # UP\n        env.state.pos = (env.state.pos[0] - 1, env.state.pos[1])\n      elif rel_pos[1] > 0:\n        actions.append(3)  # RIGHT\n        env.state.pos = (env.state.pos[0], env.state.pos[1] + 1)\n      elif rel_pos[1] < 0:\n        actions.append(2)  # LEFT\n        env.state.pos = (env.state.pos[0], env.state.pos[1] - 1)\n      rel_pos = ingredient_pos - env.state.pos\n    \n    if np.array_equal(env.state.pos, ingredient_pos):\n      actions.append(4)  # USE action\n      env.state.inventory[current_ingredient_index] -= 1\n      \n      recipe = get_recipe(goal_idx)  # Update the recipe since inventory might have changed\n      if not recipe:\n        break\n    \n    goal_idx = -1  # Mark this ingredient as used for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients():\n    goal_idx = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.primitives_for(goal_idx)\n    return [i for i in recipe if env.state.inventory[i] == 0]\n\n  def find_closest_ingredient():\n    closest_dist = float('inf')\n    closest_pos = None\n    \n    ingredients = get_ingredients()\n    for ingr in ingredients:\n      pos = np.argwhere(env.state.grid == ingr)[0]\n      dist = np.sum(np.abs(pos - env.state.pos))\n      \n      if dist < closest_dist:\n        closest_dist = dist\n        closest_pos = pos\n    \n    return (closest_pos, ingredients[ingredients.index(ingr)]) if closest_pos else (None, None)\n\n  actions = []\n  \n  while True:\n    closest_pos, ingredient_idx = find_closest_ingredient()\n    \n    if not closest_pos:\n      break\n    \n    rel_pos = closest_pos - env.state.pos\n    direction = np.argmax(np.abs(rel_pos))\n    \n    # If not adjacent, move towards the ingredient\n    if np.any(np.abs(rel_pos) > 1):\n      actions += [direction] * abs(rel_pos[direction])\n    \n    # Use the ingredient to craft the final product\n    env.state.inventory[ingredient_idx] -= 1\n    get_ingredients()  # Update ingredients list after using one\n    \n    if not any([env.state.inventory[i] for i in get_ingredients()]):\n      actions.append(4)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation goes here\n  return []", "occurrence_count": 1}
{"function_body": "  # Ensure the item is in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, pos, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    return None\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    if item not in env.world.cookbook.recipes:\n      return {}\n    requirements = {}\n    for output, recipe in env.world.cookbook.recipes[item].items():\n      if isinstance(recipe, dict) and \"_key\" in recipe:  # It's a recipe.\n        sub_requirements = get_requirements(next((k for k, v in recipe.items() if k != \"_key\")))\n        for k, v in sub_requirements.items():\n          requirements[k] = requirements.get(k, 0) + v\n      else:  # It's a primitive or already crafted item.\n        requirements[recipe] = requirements.get(recipe, 0) + 1\n    return requirements\n  \n  def craft_sequence(item, requirements):\n    actions = []\n    for k, v in reversed(sorted(requirements.items(), key=lambda x: len(env.world.cookbook.primitives_for(x)))):\n      if env.world.cookbook.primitives_for(k).get(item, 0) > 0 or all(env.world.cookbook.primitives_for(k).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n  \n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    indices = [item]\n    requirements = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements and env.world.cookbook.primitives_for(k):\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key in reversed(sorted(requirements.keys(), key=lambda x: len(env.world.cookbook.primitives_for(x)))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[key].items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(env, item_pos):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['move'])\n          found = True\n          break\n      if found: break\n    if not found:\n      raise ValueError(\"Item not found in the grid.\")\n\n  recipe = get_recipe(item)\n  if not recipe:\n    return []  # If no recipe, do nothing\n  \n  actions = []\n  for primitive, count in recipe.items():\n    while inventory[primitive] > 0 and count > 0:\n      actions.append(4)  # USE action to use the primitive\n      inventory[primitive] -= 1\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index for the desired item in the cookbook.\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Use and craft items based on the recipe.\n  for primitive in required_primitives:\n    count = recipe[primitive]\n    while count > 0:\n      if env._current_state.inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n        count -= 1\n      else:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory or grid\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      found = True\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If the item is found, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      if not found:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos_0:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  inventory = env._current_state.inventory\n  for ingredient_index, count in ingredients.items():\n    while not inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item and check if it's valid\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index for the specified item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    # Find and use the specified ingredient from the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Your improved implementation here.\n  return []", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        for _ in range(count):\n          actions.append(4)  # USE action index\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the environment's cookbook.\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Use and craft items based on the recipe.\n  for primitive in required_primitives:\n    count = recipe[primitive]\n    while count > 0:\n      if env._current_state.inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n        count -= 1\n      else:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Check if we have all the required primitives in inventory and craft them accordingly\n  for primitive in required_primitives:\n    while env._current_state.inventory[primitive] < recipe[primitive]:\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      else:\n        break  # If we can't get the required item, stop trying\n\n    # Use the primitive if enough are available in inventory\n    while env._current_state.inventory[primitive] >= recipe[primitive]:\n      actions.append(4)  # USE action to use the primitive\n      env._current_state.inventory[primitive] -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence\n  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices = []\n  ingredient_counts = []\n  for key, count in recipe.items():\n    if isinstance(key, int):\n      ingredient_indices.append(key)\n      ingredient_counts.append(count)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  for i in range(len(ingredient_indices)):\n    if inventory[ingredient_indices[i]] < ingredient_counts[i]:\n      # If we don't have enough of an ingredient, try to pick up more\n      actions += pickup_item(env, ingredient_indices[i])\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_pickup(env, index):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    primitives = env.world.primitives\n    non_grabbable = env.world.non_grabbable_indices\n    \n    # Check the 3x3 neighborhood around the agent's position for the primitive.\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        x = int(pos[0] + dx)\n        y = int(pos[1] + dy)\n        if 0 <= x < env._current_state.grid.shape[0] and 0 <= y < env._current_state.grid.shape[1]:\n          cell = grid[x, y, :]\n          if primitives[index] in cell:\n            return True\n    return False\n\n  def get_pickup_action(env, index):\n    for action in [0, 1, 2, 3]:  # DOWN, UP, LEFT, RIGHT\n      new_pos = (int(env._current_state.pos[0] + (action % 2 == 0) * (-1 if action < 2 else 1)),\n                 int(env._current_state.pos[1] + (action // 2 == 0) * (-1 if action // 2 < 1 else 1)))\n      if env._is_valid_move(new_pos):\n        return action\n    return None\n\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      while not find_and_pickup(env, index):\n        actions.append(get_pickup_action(env, index))  # Move towards the primitive\n      actions.append(4)  # USE action to pick up from inventory\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(x[0]) - np.array(env._current_state.pos))):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    indices = [item]\n    requirement_dict = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirement_dict:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirement_dict[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirement_dict[current].items():\n        if k not in requirement_dict and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          indices.append(k)\n    return requirement_dict\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    indices = [item]\n    requirement_dict = {}\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirement_dict:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirement_dict[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirement_dict[current].items():\n        if k not in requirement_dict and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirement_dict[k] = {}\n          indices.append(k)\n    return requirement_dict\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Sort ingredients by distance to current position for efficient picking up\n  sorted_ingredients = sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - get_item_position(env._current_state.grid, x[0])), reverse=True)\n\n  for ingredient_index, count in sorted_ingredients:\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        return True\n    return False\n\n  def move_to_ingredient():\n    pos = env.pos\n    grid = env.grid\n    if pos[0] > 0 and grid[pos[0]-1, pos[1], ingredient_index] == 1:\n      actions.append(0)  # Move up\n    elif pos[0] < grid.shape[0]-1 and grid[pos[0]+1, pos[1], ingredient_index] == 1:\n      actions.append(1)  # Move down\n    elif pos[1] > 0 and grid[pos[0], pos[1]-1, ingredient_index] == 1:\n      actions.append(2)  # Move left\n    elif pos[1] < grid.shape[1]-1 and grid[pos[0], pos[1]+1, ingredient_index] == 1:\n      actions.append(3)  # Move right\n    else:\n      raise ValueError(\"Ingredient not found in the grid.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_ingredient():\n      move_to_ingredient()\n      # Update the grid and position after moving (this is a placeholder as actual update logic might be needed)\n      env.grid = env._cached_features[\"features_global\"]  # Placeholder to simulate update\n      env.pos = (env.pos[0], env.pos[1])  # Placeholder to simulate update\n    actions.extend([4] * count)  # Use the found ingredient 'count' times\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    while not env.satisfies(ingredient_index, goal_index):\n      if env.next_to(ingredient_index):\n        actions.append(2)  # PICKUP action index\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n      else:\n        break\n    while env.satisfies(ingredient_index, goal_index) and count > 0:\n      actions.append(4)  # USE action index\n      count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          actions.append(4)  # USE action index\n          env.inventory[i] -= 1  # Decrease the inventory count by one after using an item\n          break\n      else:\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the item using the primitive items (if any)\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def _find_pickup_action(state, primitive):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if state.grid[state.pos[0] + dx, state.pos[1] + dy, :].any():\n          return env._action_index[(dx, dy)]\n    return None\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Use and craft items based on the recipe.\n  for primitive in required_primitives:\n    count = recipe[primitive]\n    while count > 0:\n      if env._current_state.inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n        count -= 1\n      else:\n        pickup_action = _find_pickup_action(env._current_state, primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook.\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  # Get the recipe for crafting the goal item.\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  actions = []\n\n  # Iterate over each required primitive in the recipe.\n  for primitive in required_primitives:\n    count = recipe[primitive]\n    \n    while count > 0:\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      \n      # If we have the required count of the primitive in our inventory, use it for crafting.\n      while env._current_state.inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n        count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipes = env.world.cookbook.recipes\n  if item not in recipes:\n    raise ValueError(f\"Item {item} is not a valid goal.\")\n  \n  # Extract ingredients and their counts from the recipe\n  recipe = recipes[item]\n  required_items = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n      required_items[env.world.cookbook.index[ingredient]] = count\n  \n  # Initialize the list of actions with USE action to pick up the desired item\n  actions = [4] * len(required_items)  # 4 is the index for USE action in CraftWorld\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = env.state.inventory\n  actions = []\n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env.state.pos\n      grid = env.state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} not found in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = env.state.inventory\n  actions = []\n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env.state.pos\n      grid = env.state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      pickup_actions = pickup_item(env, ingredients[i])\n      actions += pickup_actions\n      if len(pickup_actions) == 0:  # If no more items can be picked up, break the loop\n        break\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_path_to_item(env, start_index):\n    # Use a breadth-first search to find the shortest path to the desired item\n    queue = [(start_index, [])]\n    visited = set()\n    \n    while queue:\n      current_index, path = queue.pop(0)\n      if current_index in visited:\n        continue\n      visited.add(current_index)\n      \n      # Check if the current item is the desired one\n      if current_index == item:\n        return path + [4]  # Append USE action to the path\n      \n      # Add neighboring items to the queue, excluding already visited ones\n      for neighbor in env.world.non_grabbable_indices | {env.world.water_index}:\n        if neighbor not in visited:\n          queue.append((neighbor, path + [4]))  # Append USE action to the current path\n    \n    return None  # If no path is found, return None\n  \n  # Start from the desired item and find a path using BFS\n  start_index = item\n  path = find_path_to_item(env, start_index)\n  \n  if path is None:\n    raise ValueError(\"No path found to craft the desired item.\")\n  \n  return path", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Initialize the list of actions with USE action to pick up the desired item\n  actions = [4] * len(required_items)  # 4 is the index for USE action in CraftWorld\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      action = pickup_item(env, ingredients[i])\n      if action is not None:\n        actions.append(action)\n        env._current_state = env.step(action)[1]  # Update the state after pickup\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n  \n  for i in range(len(ingredients)):\n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    reqs = env.world.cookbook.primitives_for(item)\n    if not reqs:\n      return {}\n    requirements = {item: reqs}\n    for k, v in reqs.items():\n      sub_reqs = get_requirements(k)\n      if sub_reqs:\n        requirements[k] = sub_reqs\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  # Add a penalty for picking up and discarding items that are not directly needed.\n  extra_penalty = env._extra_pickup_penalty\n  adjusted_actions = []\n  for action in actions:\n    if action == env.world.grabble_indices.index:\n      # Check if the item can be picked up and is not required for crafting the final product.\n      current_item = env.scenario._current_state.inventory[item]\n      if current_item > 0:\n        adjusted_actions.append(action)\n    else:\n      adjusted_actions.append(action)\n  \n  # Remove unnecessary actions (e.g., picking up and discarding items not needed for crafting).\n  final_actions = []\n  for action in adjusted_actions:\n    if env.scenario._current_state.inventory[item] > 0 or action != env.world.grabble_indices.index:\n      final_actions.append(action)\n  \n  return final_actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements:\n          requirements[k] = {}\n          indices.append(k)  # Add the required components to indices list to check their requirements recursively.\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key, value in reversed(sorted(requirements.items(), key=lambda x: len(x[1]))):\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  \n  # Add a penalty for picking up and discarding items that are not directly needed.\n  extra_penalty = env._extra_pickup_penalty\n  adjusted_actions = []\n  for action in actions:\n    if action == env.world.grabble_indices.index:\n      current_item = env.scenario._current_state.inventory[item]\n      if current_item > 0:\n        adjusted_actions.append(action)\n      else:\n        # Add penalty for unnecessary pickup and discard actions.\n        adjusted_actions.append(env.world.non_grabbable_indices.index)\n    else:\n      adjusted_actions.append(action)\n  \n  final_actions = []\n  for action in adjusted_actions:\n    if env.scenario._current_state.inventory[item] > 0 or action != env.world.grabble_indices.index:\n      final_actions.append(action)\n  \n  return final_actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize a list to store the actions required to craft the item\n  actions = []\n\n  # Iterate over each ingredient and its count in the recipe\n  for ingredient_index, count in recipe.items():\n    # Find the index of the ingredient in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  goal = env.world.cookbook.index[item]\n  if not isinstance(goal, dict):\n    return []\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over each ingredient in the recipe\n  for ingredient, count in goal.items():\n    ingredient_id = env.world.cookbook.index[ingredient]\n\n    # Find the current inventory of the ingredient\n    inventory = np.zeros(env.world.n_kinds, dtype=int)\n    inventory[ingredient_id] = count\n\n    # Craft the ingredients needed for this recipe step\n    while not env._is_done() and inventory[ingredient_id] > 0:\n      if env.scenario._current_state.inventory[ingredient_id] == 0:\n        actions += find_actions_to_collect(env, ingredient_id)\n      \n      # Move to the ingredient location if not already there\n      if not np.array_equal(env.scenario._current_state.pos, env._get_ingredient_position(ingredient_id)):\n        actions += find_actions_to_move(env, ingredient_id)\n      \n      # Use the ingredient to craft the item (assuming immediate availability and no further requirements)\n      actions.append(4)  # USE action\n      inventory[ingredient_id] -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_position(env, item_idx):\n    pos = env.state.pos\n    grid = env.state.grid\n    for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n      for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n        if grid[x, y, item_idx] > 0:\n          return (x, y)\n    return None\n\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = env.world.cookbook.primitives_for(idx)\n  if not required_items:\n    return []\n  \n  inventory = env.state.inventory\n  missing_items = {item_idx: max(0, count - inventory[item_idx]) for item_idx, count in required_items.items()}\n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in required_items.items():\n      if missing_items[item_idx] > 0:\n        pos = find_item_position(env, item_idx)\n        if pos is None:\n          raise ValueError(\"Item {} not found in the grid.\".format(item_idx))\n        \n        # Move to the position and pick up the item if possible\n        target_pos = (pos[0] - env.state.pos[0], pos[1] - env.state.pos[1])\n        if target_pos == (0, -1): actions.append(env.action_index['up'])\n        elif target_pos == (0, 1): actions.append(env.action_index['down'])\n        elif target_pos == (-1, 0): actions.append(env.action_index['left'])\n        elif target_pos == (1, 0): actions.append(env.action_index['right'])\n        else: continue\n        \n        # Check if the item can be picked up without moving further away\n        grid = env.state.grid\n        pickupable = False\n        for dx in range(-1, 2):\n          for dy in range(-1, 2):\n            if (dx == target_pos[0] and dy == target_pos[1]) or (dx == -target_pos[0] and dy == -target_pos[1]):\n              if grid[env.state.pos[0]+dx, env.state.pos[1]+dy, item_idx] > 0:\n                pickupable = True\n                break\n          if pickupable: break\n        \n        if pickupable: actions.append(env.action_index['pickup'])\n        else: continue\n      \n      # If we have enough items, craft the desired item and update inventory\n      actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the desired item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required primitives for crafting the item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Get the current inventory of items needed for crafting\n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in required_items.items():\n      if count > inventory[item_idx]:\n        # Find the position of the missing item and move towards it\n        pos = env.state.pos\n        grid = env.state.grid\n        found = False\n        for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n          for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n            if grid[x, y, item_idx] > 0:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # If we have enough items, craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence with an initial \"WAIT\" action\n  actions = [4]  # 4 corresponds to the \"USE\" action in CraftWorld\n\n  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Extract the required primitive items and their counts from the recipe\n  primitives_needed = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.parse_fexp(ingredient)\n      primitives_needed[name] = count\n\n  # Craft each primitive item required by the recipe\n  for primitive, count in primitives_needed.items():\n    primitive_index = env.world.cookbook.index[primitive]\n    while not env._is_satisfied(primitive_index):\n      if env.next_to(primitive_index):\n        actions.append(env.grabbable_indices.index(primitive_index))  # Move to the item and grab it\n      else:\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Directions for up, down, left, right\n        current_pos = env._current_state.pos\n        for dx, dy in directions:\n          new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n          if env._is_valid_position(new_pos):\n            actions.append(env._move_to(new_pos))  # Move to the position and grab the item\n            break\n      actions.append(4)  # Use the grabbed item after moving to it\n    # After crafting each primitive, update the inventory count of the used primitive\n    env._current_state.inventory[primitive_index] -= count\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(recipe):\n    required_ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        required_ingredients.append(key)\n        counts.append(count)\n    return required_ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  required_ingredients, counts = get_required_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Pick up ingredients until we have enough for the craft\n  for i in range(len(required_ingredients)):\n    while inventory[required_ingredients[i]] < counts[i]:\n      actions += pickup_item(env, required_ingredients[i])\n    \n  # Craft the item\n  for i in range(len(required_ingredients)):\n    action = use_item(env, required_ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices, ingredient_counts = find_ingredients(recipe)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  for i in range(len(ingredient_indices)):\n    while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n      # If we don't have enough of an ingredient, try to pick up more\n      actions += pickup_item(env, ingredient_indices[i])\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  actions = [4]  # Start with the \"USE\" action\n\n  recipe = env.world.cookbook.recipes[item]\n  primitives_needed = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.parse_fexp(ingredient)\n      primitives_needed[name] = count\n\n  # Find and craft each primitive item required by the recipe\n  for primitive, count in primitives_needed.items():\n    primitive_index = env.world.cookbook.index[primitive]\n    while not env._is_satisfied(primitive_index):\n      if env.next_to(primitive_index):\n        actions.append(env.grabbable_indices.index(primitive_index))  # Move to the item and grab it\n      else:\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Directions for up, down, left, right\n        current_pos = env._current_state.pos\n        for dx, dy in directions:\n          new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n          if env._is_valid_position(new_pos):\n            actions.append(env._move_to(new_pos))  # Move to the position and grab the item\n            break\n      actions.append(4)  # Use the grabbed item after moving to it\n    # After crafting each primitive, update the inventory count of the used primitive\n    env._current_state.inventory[primitive_index] -= count\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, goal):\n    if goal not in recipes:\n      raise ValueError(f\"Item {goal} is not a valid goal.\")\n    \n    recipe = recipes[goal]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  goal_index = item  # Assuming 'item' is the index of the desired output in the cookbook\n  ingredients_needed = get_recipe_ingredients(recipes, goal_index)\n  \n  actions = []\n  for ingredient_index, count in ingredients_needed.items():\n    if env.world.primitives.issubset({ingredient_index}):\n      # If the ingredient is a primitive, use it directly (USE action)\n      actions.append(4)  # USE action index\n    else:\n      # Otherwise, we need to craft it first. This case isn't handled here because we assume all needed items are either primitives or already crafted.\n      raise NotImplementedError(\"Crafting intermediate steps are not supported in this version.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Convert indices to actions based on the recipe requirements\n  actions = [4] * len(required_items)  # Default action is USE (4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _find_pickup_actions(inventory, indices):\n    \"\"\"Helper function to find pickup actions for given inventory and indices.\"\"\"\n    actions = []\n    for index in indices:\n      while env._current_state.inventory[index] > 0:\n        actions.append(4)  # USE action to pick up from inventory\n    return actions\n\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  if not recipe:\n    return []  # If no recipe is found, return an empty list (it's already crafted).\n\n  actions = _find_pickup_actions(env._current_state.inventory, recipe.keys())\n\n  for _ in range(len(recipe)):\n    actions.append(4)  # USE action to use the primitive to craft the item\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  def find_path_to_item(env, start_index):\n    # Use a breadth-first search to find the shortest path to the desired item\n    queue = [(start_index, [])]\n    visited = set()\n    \n    while queue:\n      current_index, path = queue.pop(0)\n      if current_index in visited:\n        continue\n      visited.add(current_index)\n      \n      # Check if the current item is the desired one\n      if current_index == item:\n        return path + [4]  # Append USE action to the path\n      \n      # Add neighboring items to the queue, excluding already visited ones\n      for neighbor in env.world.non_grabbable_indices | {env.world.water_index}:\n        if neighbor not in visited:\n          queue.append((neighbor, path + [4]))  # Append USE action to the current path\n    \n    return None  # If no path is found, return None\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  actions = []\n  for ingredient in required_items:\n    if env.world.inventory[ingredient] > 0:\n      actions.append(4)  # USE action if the ingredient is available\n    else:\n      path = find_path_to_item(env, ingredient)\n      if path is not None:\n        actions.extend(path + [4])  # Extend with the found path and final USE action\n      else:\n        raise ValueError(f\"No way to acquire {ingredient} for crafting.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  def get_actions_for_recipe(required_items):\n    actions = []\n    for item, _ in required_items.items():\n      if item not in env.world.non_grabbable_indices and item != env.world.water_index:\n        actions.append(4)  # USE action (4)\n      else:\n        raise ValueError(f\"Item {item} cannot be picked up.\")\n    return actions\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  actions = get_actions_for_recipe(required_items)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Convert indices to actions based on the recipe requirements\n  inventory = env._current_state.inventory\n  action_sequence = []\n  \n  for ingredient, count in required_items.items():\n    if inventory[ingredient] >= count:\n      action_sequence.extend([4] * count)  # USE actions for each ingredient needed\n    else:\n      path = find_path_to_item(env, ingredient)\n      if path is not None:\n        action_sequence.extend(path)\n  \n  return action_sequence", "occurrence_count": 1}
{"function_body": "  def get_required_primitives(item):\n    recipe = env.world.cookbook.recipes[item]\n    primitives_needed = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        name, arg = env.world.parse_fexp(ingredient)\n        primitives_needed[name] = count\n    return primitives_needed\n\n  def craft_primitive(env, primitive_index):\n    actions = []\n    while not env._is_satisfied(primitive_index):\n      if env.next_to(primitive_index):\n        actions.append(env.grabbable_indices.index(primitive_index))  # Move to the item and grab it\n      else:\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Directions for up, down, left, right\n        current_pos = env._current_state.pos\n        for dx, dy in directions:\n          new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n          if env._is_valid_position(new_pos):\n            actions.append(env._move_to(new_pos))  # Move to the position and grab the item\n            break\n      actions.append(4)  # Use the grabbed item after moving to it\n    return actions\n\n  def craft_primitive_with_inventory_update(env, primitive_index):\n    actions = []\n    while not env._is_satisfied(primitive_index):\n      if env.next_to(primitive_index):\n        actions.append(env.grabbable_indices.index(primitive_index))  # Move to the item and grab it\n      else:\n        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Directions for up, down, left, right\n        current_pos = env._current_state.pos\n        for dx, dy in directions:\n          new_pos = (current_pos[0] + dx, current_pos[1] + dy)\n          if env._is_valid_position(new_pos):\n            actions.append(env._move_to(new_pos))  # Move to the position and grab the item\n            break\n      actions.append(4)  # Use the grabbed item after moving to it\n    return actions\n\n  actions = [4]  # Start with the \"USE\" action\n  required_primitives = get_required_primitives(item)\n  for primitive, count in required_primitives.items():\n    primitive_index = env.world.cookbook.index[primitive]\n    while not env._is_satisfied(primitive_index):\n      actions += craft_primitive_with_inventory_update(env, primitive_index)\n    # After crafting each primitive, update the inventory count of the used primitive\n    env._current_state.inventory[primitive_index] -= count\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_actions_for_item(env, goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    required_primitives = list(recipe.keys())\n    actions = []\n    for primitive in required_primitives:\n      while env._current_state.inventory[primitive] < recipe[primitive]:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      while env._current_state.inventory[primitive] >= recipe[primitive]:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  return get_actions_for_item(env, goal_index)", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Helper function to find the index of a primitive in the inventory or grid\n  def find_primitive_in_inventory_or_grid(primitive):\n    for i in range(len(env._current_state.inventory)):\n      if env._current_state.inventory[i] > 0 and env.world.cookbook.index.get(i) == primitive:\n        return i\n    for y in range(env._current_state.grid.shape[0]):\n      for x in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[y, x] == primitive:\n          return (x, y)\n    return None\n  \n  # Use and craft items based on the recipe.\n  for primitive in required_primitives:\n    count = recipe[primitive]\n    while count > 0:\n      found = find_primitive_in_inventory_or_grid(primitive)\n      if isinstance(found, tuple):\n        # If found is a position, move to that position\n        actions.extend(env._move_to_position(*found))\n        x, y = found\n        while env._current_state.grid[y, x] != primitive:\n          actions.append(4)  # USE action to use the primitive\n          count -= 1\n          if count == 0:\n            break\n      elif found is not None:\n        # If found is an index, move to that index and pick it up\n        actions.extend(env._move_to_index(found))\n        while env._current_state.inventory[found] > 0:\n          actions.append(4)  # USE action to use the primitive\n          count -= 1\n          if count == 0:\n            break\n      else:\n        raise ValueError(\"Primitive {} not found in inventory or grid.\".format(primitive))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def check_if_can_craft(inventory, recipe):\n    for item, _ in recipe.items():\n      if inventory[item] == 0:\n        return False\n    return True\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  while check_if_can_craft(env._current_state.inventory, recipe):\n    craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  actions = []\n  for _, count in required_items.items():\n    if not (env.world.inventory[_,] > 0 or _ in env.world.workshop_indices):\n      path = find_path_to_item(env, _)\n      if path:\n        actions.extend(path)\n      else:\n        raise ValueError(f\"Item {_} cannot be picked up.\")\n    elif env.world.inventory[_,] >= count:\n      for _ in range(count):\n        actions.append(4)  # USE action (4)\n    else:\n      path = find_path_to_item(env, _)\n      if path:\n        actions.extend(path)\n      else:\n        raise ValueError(f\"Item {_} cannot be picked up.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key in reversed(sorted(requirements.keys(), key=lambda x: len(requirements[x]))):\n      value = requirements[key]\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_requirements(item):\n    requirements = {}\n    indices = [item]\n    while len(indices) > 0:\n      current = indices.pop()\n      if current not in requirements:\n        reqs = env.world.cookbook.primitives_for(current)\n        if reqs:\n          requirements[current] = reqs\n        else:\n          continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in requirements[current].items():\n        if k not in requirements and not (env.world.cookbook.primitives_for(k).values()):  # Only add to indices if not already crafted or grabbable.\n          requirements[k] = {}\n          # Add the required components to indices list to check their requirements recursively.\n          indices.append(k)\n    return requirements\n\n  def craft_sequence(item, requirements):\n    actions = []\n    for key in sorted(requirements.keys(), key=lambda x: len(requirements[x])):\n      value = requirements[key]\n      if all(env.world.cookbook.primitives_for(key).values()):\n        continue  # Skip items that are already crafted or can be directly grabbed.\n      for k, v in value.items():\n        actions += [env.world.non_grabbable_indices.index] * v + [env.world.grabble_indices.index]\n    return actions\n\n  requirements = get_requirements(item)\n  actions = craft_sequence(item, requirements)\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the recipe to craft the item\n  recipe = env.world.cookbook.primitives_for(idx)\n  if not recipe:\n    return []\n  \n  # Find all items we need to collect and craft\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  while missing_items:\n    # Pickup or move towards the first missing item\n    for item_idx, count in missing_items.items():\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item if possible\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Find the index of the desired item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the recipe for crafting the item\n  recipe = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it is already crafted or cannot be crafted\n  if not recipe:\n    return []\n  \n  actions = []\n  inventory = env._current_state.inventory\n  \n  # Find the missing items and their counts required for crafting the item\n  missing_items = {k: v - inventory[k] for k, v in recipe.items() if v > inventory[k]}\n  \n  while any(missing_items.values()):\n    # For each missing item, find its position and move towards it if necessary\n    grid = env._current_state.grid\n    pos = env._current_state.pos\n    for item_idx, count in missing_items.items():\n      found = False\n      while count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = find_item(grid, pos, item_idx)\n        if not pos:\n          raise ValueError(\"Item {} not found in the grid.\".format(env.world.cookbook.index.get(item_idx)))\n        \n        # Move to the position and pick up the item if possible\n        actions.append(move_to_and_pickup(env, pos))\n        count -= 1\n    \n    # Craft the desired item\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the recipe to craft the item\n  recipe = env.world.cookbook.primitives_for(idx)\n  if not recipe:\n    return []\n  \n  # Find all items we need to collect and craft\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  while missing_items:\n    # Pickup or move towards the first missing item\n    for item_idx, count in missing_items.items():\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          cell = grid[nx+dx, ny+dy]\n          if np.any(cell == item_idx):\n            # Move to the position and pick up the item if possible\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook using the item name\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting the target item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize a list to store the sequence of actions required to craft the item\n  actions = []\n\n  # Iterate over each ingredient and its count specified in the recipe\n  for ingredient_index, count in recipe.items():\n    # Search through the inventory for the specific ingredient needed\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if the current item matches the required ingredient\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it does, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n  for ingredient_index, count in ingredients:\n    while env.inventory[ingredient_index] > 0 and count > 0:\n      actions.append(4)  # USE action index\n      count -= 1\n      if count == 0:\n        break\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  for ingredient_index, count in get_ingredients(goal_index):\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Initialize actions list with USE (4) for each ingredient\n  actions = [4] * len(required_items)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe_ingredients(recipes, item):\n    if item not in recipes:\n      raise ValueError(f\"Item {item} is not a valid goal.\")\n    \n    recipe = recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and ingredient.isalpha() and ingredient != \"output\":\n        required_items[env.world.cookbook.index[ingredient]] = count\n    return required_items\n  \n  recipes = env.world.cookbook.recipes\n  required_items = get_recipe_ingredients(recipes, item)\n  \n  # Convert indices to actions based on the recipe requirements\n  actions = []\n  for ingredient_index, count in required_items.items():\n    if env.world.inventory[ingredient_index] > 0:\n      actions.extend([4] * count)  # USE action (4)\n    else:\n      path = find_path_to_item(env, ingredient_index)\n      if path:\n        actions.extend(path)\n      else:\n        raise ValueError(f\"Item {ingredient_index} cannot be picked up.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _get_required_counts(env, goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    required_counts = {primitive: count for primitive, count in recipe.items()}\n    return required_counts\n  \n  def get_actions_for_item(env, required_counts):\n    actions = []\n    for primitive, count in required_counts.items():\n      while env._current_state.inventory[primitive] < count:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      while env._current_state.inventory[primitive] >= count:\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  required_counts = _get_required_counts(env, goal_index)\n  return get_actions_for_item(env, required_counts)", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    # Find and use the specified ingredient from the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          actions.extend([4] * count)  # Extend the list with 'USE' actions\n          break\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    # Find and use the specified ingredient from the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n  for ingredient_index, count in ingredients:\n    while env.inventory[ingredient_index] > 0 and count > 0:\n      # Check if the item can be used to craft the goal item\n      if env.world.cookbook.index.get(ingredient_index) == goal_index:\n        actions.append(4)  # USE action index\n        count -= 1\n        if count == 0:\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} cannot be used to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n  for ingredient_index, count in ingredients:\n    while env.inventory[ingredient_index] > 0 and count > 0:\n      actions.append(4)  # USE action index\n      count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = np.array(env._current_state.inventory)\n  actions = []\n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  actions = []\n  for item_idx, count in required_items.items():\n    while env._current_state.inventory[item_idx] < count:\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) in env.grabbable_indices:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation here.\n\n  return []", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    pos = env.pos\n    grid = env.grid\n    neighbors = [(pos[0]-1, pos[1]), (pos[0]+1, pos[1]), (pos[0], pos[1]-1), (pos[0], pos[1]+1)]\n    for neighbor in neighbors:\n      if 0 <= neighbor[0] < grid.shape[0] and 0 <= neighbor[1] < grid.shape[1]:\n        if grid[neighbor[0], neighbor[1], ingredient_index] == 1:\n          return True, neighbor\n    return False, None\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    while not env.satisfies(ingredient_index, goal_index):\n      found, pos = find_ingredient()\n      if found:\n        actions.append(2)  # Move to the found ingredient's position\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n      else:\n        break\n    while env.satisfies(ingredient_index, goal_index) and count > 0:\n      actions.append(4)  # USE action index\n      count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient():\n    pos = env.pos\n    grid = env.grid\n    if pos[0] > 0 and grid[pos[0]-1, pos[1], ingredient_index] == 1:\n      return True\n    elif pos[0] < grid.shape[0]-1 and grid[pos[0]+1, pos[1], ingredient_index] == 1:\n      return True\n    elif pos[1] > 0 and grid[pos[0], pos[1]-1, ingredient_index] == 1:\n      return True\n    elif pos[1] < grid.shape[1]-1 and grid[pos[0], pos[1]+1, ingredient_index] == 1:\n      return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    while not env.satisfies(ingredient_index, goal_index):\n      if find_ingredient():\n        actions.append(2)  # PICKUP action index\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n      else:\n        break\n    while env.satisfies(ingredient_index, goal_index) and count > 0:\n      actions.append(4)  # USE action index\n      count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos_old:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(x[0]) - np.array(env._current_state.pos))):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  # Helper function to find the first available ingredient in inventory that meets the count requirement\n  def get_available_ingredient(inventory, required_indices, required_counts):\n    for i in range(len(required_indices)):\n      if inventory[required_indices[i]] >= required_counts[i]:\n        return required_indices[i]\n    return None\n\n  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices = []\n  ingredient_counts = []\n  for key, count in recipe.items():\n    if isinstance(key, int):\n      ingredient_indices.append(key)\n      ingredient_counts.append(count)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  \n  # Try to pick up more of each required ingredient until we have enough\n  for i in range(len(ingredient_indices)):\n    while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n      actions += pickup_item(env, ingredient_indices[i])\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the sequence of actions to an empty list\n  actions = []\n  \n  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        pos = env._current_state.pos\n        while available_count < count:\n          # Determine the direction to move in to get closer to the item\n          target_pos = env.world.index[name]\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      while not found:\n        for i in range(len(env.inventory)):\n          if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n            ingredients.append((i, count))\n            found = True\n            break\n        else:\n          move_to_ingredient(ingredient_index)\n    return ingredients\n\n  def move_to_ingredient(ingredient_index):\n    if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n      actions.append(0)  # Move up\n    elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n      actions.append(1)  # Move down\n    elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n      actions.append(2)  # Move left\n    elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n      actions.append(3)  # Move right\n    else:\n      raise ValueError(\"Ingredient not found in the grid.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count):\n      move_to_ingredient(ingredient_index)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      found = False\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          ingredients.append((i, count))\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n    return ingredients\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n  for ingredient_index, count in ingredients:\n    while count > 0:\n      if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n        actions.append(0)  # Move up\n        env.pos = (env.pos[0]-1, env.pos[1])\n      elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n        actions.append(1)  # Move down\n        env.pos = (env.pos[0]+1, env.pos[1])\n      elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n        actions.append(2)  # Move left\n        env.pos = (env.pos[0], env.pos[1]-1)\n      elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n        actions.append(3)  # Move right\n        env.pos = (env.pos[0], env.pos[1]+1)\n      else:\n        raise ValueError(\"Ingredient not found in the grid.\")\n      count -= 1\n      actions.extend([4] * count)  # Use the ingredient 'count' times\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          # Determine the direction to move in to get closer to the item\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        while available_count < count:\n          pos = env._current_state.pos\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(x[0]) - np.array(env._current_state.pos))):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        target_pos = env.world.index[name]\n        delta_x, delta_y = target_pos[0] - env._current_state.pos[0], target_pos[1] - env._current_state.pos[1]\n        \n        if delta_x > 0:\n          actions += [3] * (delta_x)  # RIGHT\n        elif delta_x < 0:\n          actions += [2] * (-delta_x)  # LEFT\n        elif delta_y > 0:\n          actions += [1] * (delta_y)  # UP\n        elif delta_y < 0:\n          actions += [0] * (-delta_y)  # DOWN\n        \n        pos = target_pos\n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _find_item(grid, pos, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    return None\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _find_item(grid, pos, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    return None\n\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx in sorted(missing_items, key=lambda x: env._current_state.inventory[x], reverse=True):\n      count = missing_items[item_idx]\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env._current_state.pos\n        grid = env._current_state.grid\n        while count > 0:\n          item_pos = _find_item(grid, pos, item_idx)\n          if not item_pos:\n            raise ValueError(\"Item {} not found in the grid.\".format(item_idx))\n          \n          # Move to the position and pick up the item\n          dx = np.sign(item_pos[0] - pos[0])\n          dy = np.sign(item_pos[1] - pos[1])\n          if dx != 0: actions.append(2 if dx > 0 else 3)  # Move right or left\n          if dy != 0: actions.append(1 if dy < 0 else 0)  # Move up or down\n          \n          # Pickup the item\n          actions.append(4)\n          count -= 1\n      \n    # Craft the desired item and update inventory\n    actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize a list to store the actions required to craft the item\n  actions = []\n\n  # Iterate over each ingredient and its count in the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      # Find the position of the ingredient in the grid\n      pos = np.argwhere(env.grid[:, :, ingredient_index] == 1)\n      if len(pos) > 0:\n        x, y = pos[0]\n        # Determine the best action to move closer to the ingredient\n        dx = x - env.pos[0]\n        dy = y - env.pos[1]\n        if abs(dx) > abs(dy):\n          if dx < 0:\n            actions.append(0)  # Move up\n          else:\n            actions.append(1)  # Move down\n        else:\n          if dy < 0:\n            actions.append(2)  # Move left\n          else:\n            actions.append(3)  # Move right\n      else:\n        raise ValueError(\"Ingredient not found in the grid.\")\n      \n      # Check if we are next to the ingredient now\n      if env.next_to(ingredient_index):\n        found = True\n\n    # Use the ingredient to craft the goal item 'count' times\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # USE action repeated 'count' times\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # USE action index repeated for each item needed\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the item using the primitive items (if any)\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting this item using its primitive components (if applicable)\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  if not recipe:\n    return []\n\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_move_to_item(env, ingredient_index):\n    pos = env.pos\n    while True:\n      if pos[0] > 0 and env.grid[pos[0]-1, pos[1], ingredient_index] == 0:\n        actions.append(1) # UP action index\n        pos = (pos[0]-1, pos[1])\n      elif pos[0] < env.grid.shape[0]-1 and env.grid[pos[0]+1, pos[1], ingredient_index] == 0:\n        actions.append(3) # DOWN action index\n        pos = (pos[0]+1, pos[1])\n      elif pos[1] > 0 and env.grid[pos[0], pos[1]-1, ingredient_index] == 0:\n        actions.append(2) # LEFT action index\n        pos = (pos[0], pos[1]-1)\n      elif pos[1] < env.grid.shape[1]-1 and env.grid[pos[0], pos[1]+1, ingredient_index] == 0:\n        actions.append(4) # RIGHT action index\n        pos = (pos[0], pos[1]+1)\n      else:\n        break\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_move_to_item(env, ingredient_index)\n    if env.inventory[ingredient_index] > 0:\n      actions.append(4) # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_item(env, ingredient_index, count):\n    # Search for the ingredient in the grid and inventory\n    found = False\n    pos = env.pos\n    while not found:\n      if pos[0] > 0 and env.grid[pos[0]-1, pos[1], ingredient_index] == 0:\n        actions.append(1) # UP action index\n        pos = (pos[0]-1, pos[1])\n      elif pos[0] < env.grid.shape[0]-1 and env.grid[pos[0]+1, pos[1], ingredient_index] == 0:\n        actions.append(3) # DOWN action index\n        pos = (pos[0]+1, pos[1])\n      elif pos[1] > 0 and env.grid[pos[0], pos[1]-1, ingredient_index] == 0:\n        actions.append(2) # LEFT action index\n        pos = (pos[0], pos[1]-1)\n      elif pos[1] < env.grid.shape[1]-1 and env.grid[pos[0], pos[1]+1, ingredient_index] == 0:\n        actions.append(4) # RIGHT action index\n        pos = (pos[0], pos[1]+1)\n      else:\n        found = True\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_use_item(env, ingredient_index, count)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def find_and_move_to_item(actions, pos, grid, item_type):\n    for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n      for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n        if grid[x, y, item_type] > 0:\n          actions.append(0)  # DOWN action to move down\n          actions.append(3)  # RIGHT action to move right (or adjust as needed for your specific environment setup)\n          return True\n    raise ValueError(\"Item not found in the grid.\")\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  for primitive, count in recipe.items():\n    while count > inventory[primitive]:\n      found = find_and_move_to_item(actions, env._current_state.pos, env._current_state.grid, primitive)\n      if not found:\n        raise ValueError(\"Item not found in the grid.\")\n    actions.append(4)  # USE action to use the primitive\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      while available_count < count:\n        pos = env._current_state.pos\n        target_pos = None\n        \n        # Determine the position of the ingredient in the grid\n        for dx in range(-1, 2):\n          for dy in range(-1, 2):\n            if (0 <= pos[0] + dx < env._current_state.grid.shape[0] and\n                0 <= pos[1] + dy < env._current_state.grid.shape[1]):\n              cell = env._current_state.grid[pos[0] + dx, pos[1] + dy, index]\n              if cell != 0:\n                target_pos = (pos[0] + dx, pos[1] + dy)\n                break\n          if target_pos is not None:\n            break\n        \n        if target_pos is None:\n          raise ValueError(f\"Ingredient {name} not found in the grid.\")\n        \n        delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n        \n        # Move to the ingredient if necessary\n        while delta_x > 0:\n          actions.append(3)  # RIGHT\n          delta_x -= 1\n        while delta_x < 0:\n          actions.append(2)  # LEFT\n          delta_x += 1\n        while delta_y > 0:\n          actions.append(1)  # UP\n          delta_y -= 1\n        while delta_y < 0:\n          actions.append(0)  # DOWN\n          delta_y += 1\n        \n        pos = target_pos\n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n      actions.extend([4] * count)  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  inventory = env._current_state.inventory\n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  \n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the missing item\n      pos = None\n      found = False\n      for x in range(env.grid.shape[0]):\n        for y in range(env.grid.shape[1]):\n          if env.grid[x, y, item_idx] > 0:\n            pos = (x, y)\n            found = True\n            break\n        if found: break\n      \n      # If the item is not found, raise an error\n      if not pos:\n        raise ValueError(\"Item {} not found in the grid.\".format(item_idx))\n      \n      nx, ny = pos\n      dxys = [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)] # Move actions: stay still and move up, down, left, right", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = env.world.cookbook.primitives_for(idx)\n  actions = []\n\n  for item_idx, count in required_items.items():\n    while env._current_state.inventory[item_idx] < count:\n      # Find the position of the missing item and pick it up\n      pos = None\n      grid = env._current_state.grid\n      nx, ny = env._current_state.pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) in env.grabbable_indices and grid[nx+dx, ny+dy, item_idx] > 0:\n            pos = (nx+dx, ny+dy)\n            found = True\n            break\n        if found: break\n      if not found:\n        raise ValueError(\"Item {} not found in the inventory or grid.\".format(env.world.cookbook.index[item_idx]))\n      \n      # Move to the position and pick up the item\n      while env._current_state.pos != pos:\n        if pos[0] > env._current_state.pos[0]: actions.append(env.action_index['right'])\n        elif pos[0] < env._current_state.pos[0]: actions.append(env.action_index['left'])\n        elif pos[1] > env._current_state.pos[1]: actions.append(env.action_index['up'])\n        else: actions.append(env.action_index['down'])\n      \n      # Use the item if it's in the inventory and needed count is 1\n      if count == 1:\n        actions.append(env.action_index['use'])\n      else:\n        actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize a list to store actions\n  actions = []\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n          found = True\n          break\n      if not found:\n        # If no more instances are found and we haven't used all ingredients, keep searching by picking up new ones\n        for i in range(len(env.inventory)):\n          if env.inventory[i] == 0:\n            actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n            break\n        time.sleep(1)  # Wait a bit to let the inventory update before searching again\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize a list to store actions\n  actions = []\n\n  # Helper function to find and use ingredients\n  def find_and_use_ingredient():\n    nonlocal env, goal_index, recipe\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.append(4)  # USE action index\n        return True\n    return False\n\n  # Iterate over each ingredient and its count from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found and count > 0:\n      if find_and_use_ingredient():\n        count -= 1\n      else:\n        # If no more instances are found and we haven't used all ingredients, keep searching by picking up new ones\n        for i in range(len(env.inventory)):\n          if env.inventory[i] == 0:\n            actions.append(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n            break\n      time.sleep(1)  # Wait a bit to let the inventory update before searching again\n    found = True\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal in the environment's world.cookbook.index\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize a list to store the actions required to craft the item\n  actions = []\n\n  # Helper function to find and move to the ingredient\n  def find_and_move_to_ingredient(env, ingredient_index):\n    pos = np.argwhere(env.grid[:, :, ingredient_index] == 1)\n    if len(pos) > 0:\n      x, y = pos[0]\n      dx = x - env.pos[0]\n      dy = y - env.pos[1]\n      while not (abs(dx) <= 1 and abs(dy) <= 1):\n        if abs(dx) > abs(dy):\n          if dx < 0:\n            actions.append(0)  # Move up\n          else:\n            actions.append(1)  # Move down\n        else:\n          if dy < 0:\n            actions.append(2)  # Move left\n          else:\n            actions.append(3)  # Move right\n        dx = x - env.pos[0]\n        dy = y - env.pos[1]\n      return True\n    return False\n\n  # Iterate over each ingredient and its count in the recipe\n  for ingredient_index, count in recipe.items():\n    found = find_and_move_to_ingredient(env, ingredient_index)\n    if not found:\n      raise ValueError(\"Ingredient not found in the grid.\")\n\n    # Use the ingredient to craft the goal item 'count' times\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, ingredient_index):\n    pos = np.argwhere(env.grid[:, :, ingredient_index] == 1)\n    if len(pos) > 0:\n      x, y = pos[0]\n      dx = x - env.pos[0]\n      dy = y - env.pos[1]\n      if abs(dx) > abs(dy):\n        if dx < 0: return 1  # Move up\n        else: return 0  # Move down\n      else:\n        if dy < 0: return 2  # Move left\n        else: return 3  # Move right\n    else:\n      raise ValueError(\"Ingredient not found in the grid.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize a list to store the actions required to craft the item\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    while count > 0:\n      action = find_ingredient(env, ingredient_index)\n      if action is not None:\n        actions.append(action)\n        # Move to the next position based on the action\n        if action == 0: env.pos = (env.pos[0] - 1, env.pos[1])\n        elif action == 1: env.pos = (env.pos[0] + 1, env.pos[1])\n        elif action == 2: env.pos = (env.pos[0], env.pos[1] - 1)\n        elif action == 3: env.pos = (env.pos[0], env.pos[1] + 1)\n        count -= 1\n      else:\n        raise ValueError(\"Ingredient not found in the grid.\")\n      \n    # Use the ingredient to craft the goal item 'count' times\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos.pos:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      available_count = get_item_count(index)\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          available_count = get_item_count(index)\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Try to pick up all required ingredients first\n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      action = pickup_item(env, ingredients[i])\n      if action is not None:\n        actions.append(action)\n        env._current_state = env.step(action)[1]  # Update the state after pickup\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n  \n  # Use the ingredients to craft the item\n  for i in range(len(ingredients)):\n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_actions_for_item(env, goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    required_primitives = list(recipe.keys())\n    actions = []\n    for primitive in required_primitives:\n      while not enough_to_craft(env._current_state, primitive, recipe[primitive]):\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      while enough_to_craft(env._current_state, primitive, recipe[primitive]):\n        actions.append(4)  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  def enough_to_craft(state, primitive, count):\n    return state.inventory[primitive] >= count\n\n  return get_actions_for_item(env, goal_index)", "occurrence_count": 1}
{"function_body": "  # Your code here\n  \n  return []", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      # Check if the item is already in the inventory\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          actions.extend([4] * count)  # Use the found item 'count' times\n          found = True\n          break\n      else:\n        # If not, find where this ingredient is located in the grid and move to it if possible\n        pos = np.argwhere(env.grid[:, :, ingredient_index] == 1)\n        if len(pos) > 0:\n          row, col = pos[0]\n          # Move towards the found item\n          if env.pos[0] > row and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n            actions.append(0)  # Move up\n          elif env.pos[0] < row and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n            actions.append(1)  # Move down\n          elif env.pos[1] > col and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n            actions.append(2)  # Move left\n          elif env.pos[1] < col and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n            actions.append(3)  # Move right\n        else:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the environment's cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  inventory = env._current_state.inventory\n  \n  # Iterate over each ingredient in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument (if any)\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      # Find how many of this item are available to use for crafting\n      available_count = inventory[index]\n      \n      # Use the necessary number of items from the inventory\n      actions += [4] * min(available_count, count)  # USE action\n      \n      # If not enough items are available, add a sequence to gather more\n      if available_count < count:\n        # Add actions to move to the item and pick it up until we have enough\n        pos = env._current_state.pos\n        while available_count < count:\n          # Determine the direction to move in to get closer to the item\n          target_pos = env.world.index[name]\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        # Once we have enough items, use them for crafting\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        pos = env._current_state.pos\n        while available_count < count:\n          target_pos = env.world.index[name]\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx in sorted(missing_items, key=lambda x: env._current_state.inventory[x]):\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  actions = []\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  while missing_items:\n    for item_idx in sorted(missing_items, key=lambda x: env._current_state.pos[0] - (env._current_state.pos[0] + x[0]) if env._current_state.pos[0] + x[0] < 5 else env._current_state.pos[1] - (env._current_state.pos[1] + x[1])):\n      count = missing_items[item_idx]\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(4)  # USE action to try using what we have\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def find_and_move_to_item(actions, env, item_name):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          actions.append(env.action_index['pickup'])\n          found = True\n          break\n      if found: break\n    if not found:\n      raise ValueError(\"Item {} not found in the grid.\".format(item_name))\n\n  def find_and_craft_items(actions, env, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  find_and_move_to_item(actions, env, item)\n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  def pickup_ingredients(env, ingredients, counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredients)):\n      while inventory[ingredients[i]] < counts[i]:\n        actions += pickup_item(env, ingredients[i])\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n    return actions\n  \n  def use_ingredients(env, ingredients, counts):\n    actions = []\n    for i in range(len(ingredients)):\n      action = use_item(env, ingredients[i], counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredients, counts = find_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredients, counts)\n  actions += use_ingredients(env, ingredients, counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  def pickup_ingredients(ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    return actions\n  \n  def use_ingredients(ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices, ingredient_counts = get_recipe(goal_index)\n  actions = pickup_ingredients(ingredient_indices, ingredient_counts)\n  actions += use_ingredients(ingredient_indices, ingredient_counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(pos):\n    for i in range(3):\n      for j in range(3):\n        if np.array_equal(env._current_state.grid[pos[0]+i, pos[1]+j], env.world.stone_index):\n          return (pos[0]+i, pos[1]+j)\n    return None\n\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  inventory = np.array(env._current_state.inventory)\n  actions = []\n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  inventory = np.array(env._current_state.inventory)\n  actions = []\n  for item_idx, count in required_items.items():\n    while inventory[item_idx] < count:\n      # Find the position of the missing items and move towards them if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      for x in range(max(0, pos[0]-1), min(env.world.WIDTH, pos[0]+2)):\n        for y in range(max(0, pos[1]-1), min(env.world.HEIGHT, pos[1]+2)):\n          if grid[x, y, item_idx] > 0:\n            # Move to the position and pick up the item if possible\n            nx, ny = x, y\n            dx, dy = nx - pos[0], ny - pos[1]\n            if dx < 0: actions.append(env.action_index['left'])\n            elif dx > 0: actions.append(env.action_index['right'])\n            if dy < 0: actions.append(env.action_index['up'])\n            elif dy > 0: actions.append(env.action_index['down'])\n            # Move to the position and pick up the item\n            if grid[nx, ny, item_idx] == env.world.kinds[item_idx]:\n              actions.append(env.action_index['pickup'])\n              inventory[item_idx] += 1\n              break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your improved crafting logic here!\n  return []", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  # Get the required ingredients and their counts from the recipe\n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  # Check if we have all the required ingredients in the inventory\n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  actions = []\n  for kind, count in required_ingredients.items():\n    while inventory[kind] < count:\n      # Find the location of the ingredient in the grid\n      found = False\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(4)  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  def find_and_move_to_item(env, actions, item_idx):\n    grid = env._current_state.grid\n    pos = env._current_state.pos\n    for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n      for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n        if grid[x, y, item_idx] > 0:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['move_up'] if x < pos[0] else (env.action_index['move_down'] if x > pos[0] else (env.action_index['move_left'] if y < pos[1] else env.action_index['move_right'])) )\n          break\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  for primitive, count in recipe.items():\n    while inventory[primitive] > 0 and count > 0:\n      find_and_move_to_item(env, actions, primitive)\n      actions.append(4)  # USE action to use the primitive\n      inventory[primitive] -= count\n      count = 0\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      if not enough_in_inventory(env, ingredients[i], counts[i]):\n        actions += pickup_item(env, ingredients[i])\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  actions = []\n\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = None\n        for pos in env.world.workshop_indices:\n          if env.world.grid[pos][0] == index:\n            target_pos = pos\n            break\n        \n        while available_count < count and target_pos is not None:\n          delta_x, delta_y = target_pos[0] - env._current_state.pos[0], target_pos[1] - env._current_state.pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Check if we have all the required primitives in inventory and craft them accordingly\n  for primitive in required_primitives:\n    while not env._current_state.satisfies(None, primitive):\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      else:\n        break  # If we can't get the required item, stop trying\n\n    # Use the primitive if enough are available in inventory\n    while env._current_state.inventory[primitive] >= recipe[primitive]:\n      actions.append(4)  # USE action to use the primitive\n      env._current_state.inventory[primitive] -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_primitives(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    return list(recipe.keys()) if recipe else []\n\n  def craft_primitive(primitive, required_count):\n    pickup_actions = []\n    while env._current_state.inventory[primitive] < required_count:\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        pickup_actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      else:\n        break  # If we can't get the required item, stop trying\n    return pickup_actions\n\n  def use_primitives(primitive, required_count):\n    actions = []\n    while env._current_state.inventory[primitive] >= required_count:\n      actions.append(4)  # USE action to use the primitive\n      env._current_state.inventory[primitive] -= required_count\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n\n  required_primitives = get_required_primitives(goal_index)\n  actions = []\n\n  for primitive in required_primitives:\n    pickup_actions = craft_primitive(primitive, env.world.cookbook.recipes[goal_index][primitive])\n    actions.extend(pickup_actions)\n    use_actions = use_primitives(primitive, env.world.cookbook.recipes[goal_index][primitive])\n    actions.extend(use_actions)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index for the item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def gather_items(env, name, index, count):\n    inventory = env._current_state.inventory\n    available_count = inventory[index]\n    actions = []\n    \n    if available_count < count:\n      pos = env._current_state.pos\n      while available_count < count:\n        target_pos = env.world.index[name]\n        delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n        \n        if delta_x > 0:\n          actions += [3] * (delta_x)  # RIGHT\n        elif delta_x < 0:\n          actions += [2] * (-delta_x)  # LEFT\n        elif delta_y > 0:\n          actions += [1] * (delta_y)  # UP\n        elif delta_y < 0:\n          actions += [0] * (-delta_y)  # DOWN\n        \n        pos = target_pos\n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n      actions += [4] * count  # USE action\n    \n    return actions\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      actions += gather_items(env, name, index, count)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        pos = env._current_state.pos\n        while available_count < count:\n          target_pos = env.world.index[name]\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3] * (delta_x)  # RIGHT\n          elif delta_x < 0:\n            actions += [2] * (-delta_x)  # LEFT\n          elif delta_y > 0:\n            actions += [1] * (delta_y)  # UP\n          elif delta_y < 0:\n            actions += [0] * (-delta_y)  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the indices for the goal and the required items\n  recipe = env.world.cookbook.recipes[item]\n  required_items = []\n  \n  # Find all the required items by recursively traversing the recipe dictionary\n  def find_required_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        find_required_items(value)\n      elif key == \"_key\":\n        required_items.append(value)\n  \n  # Start the recursive search from the main goal item's recipe\n  find_required_items(recipe)\n\n  # Create a list to store the actions\n  actions = []\n\n  # Initialize the inventory and pick up any required items that are not already in the inventory\n  for req_item in required_items:\n    if env.world.cookbook.index[req_item] not in env._non_grabbable_indices:\n      actions.append(env.world.grabbable_indices.index(env.world.cookbook.index[req_item]))\n  \n  # Craft the item using the required items\n  for req_item in reversed(required_items):\n    if env.world.cookbook.index[req_item] not in env._non_grabbable_indices:\n      actions.append(env.world.grabbable_indices.index(env.world.cookbook.index[req_item]))\n      # Use the required item to craft the goal item\n      actions.append(4)  # Action for using an item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, pos, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    return None\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.cookbook.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        actions += move_to_item(env._current_state.pos, target_pos)\n        \n        while available_count < count:\n          actions += [4]  # USE action\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.cookbook.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n  \n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        actions += move_to_item(env._current_state.pos, target_pos)\n        \n        while available_count < count:\n          actions += [4]  # USE action\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n\n  def find_and_move_to_item(actions, pos, grid, item_type):\n    for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n      for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n        if grid[x, y, item_type] > 0:\n          move = (x - pos[0], y - pos[1])\n          while move != (0, 0):\n            dx, dy = np.sign(move), np.sign(move)\n            actions.append(dx + 2 * dy)  # Map to action indices: DOWN=0, UP=1, LEFT=2, RIGHT=3\n            pos = (pos[0] + dx, pos[1] + dy)\n            move = (x - pos[0], y - pos[1])\n          return True\n    raise ValueError(\"Item not found in the grid.\")\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  for primitive, count in recipe.items():\n    while count > inventory[primitive]:\n      found = find_and_move_to_item(actions, env._current_state.pos, env._current_state.grid, primitive)\n      if not found:\n        raise ValueError(\"Item not found in the grid.\")\n    actions.append(4)  # USE action to use the primitive\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the grid or inventory\n    found = False\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if env.grid[x, y, ingredient_index] == 1:\n          # If this item is available in the grid at (x, y), move to that position and use it\n          while not found:\n            if x > env.pos[0]:\n              actions.append(1)  # Move down\n            elif x < env.pos[0]:\n              actions.append(0)  # Move up\n            elif y > env.pos[1]:\n              actions.append(3)  # Move right\n            elif y < env.pos[1]:\n              actions.append(2)  # Move left\n            found = True\n          break\n      if found:\n        break\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    while count > env.inventory[ingredient_index]:\n      # If the item is not immediately available, try to move towards it\n      found_pos = None\n      for dx in range(-1, 2):\n        for dy in range(-1, 2):\n          if 0 <= env.pos[0] + dx < env.grid.shape[0] and 0 <= env.pos[1] + dy < env.grid.shape[1]:\n            if env.grid[env.pos[0] + dx, env.pos[1] + dy, ingredient_index] == 1:\n              found_pos = (env.pos[0] + dx, env.pos[1] + dy)\n              break\n        if found_pos is not None:\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n      # Move towards the ingredient\n      move = (found_pos[0] - env.pos[0], found_pos[1] - env.pos[1])\n      if move == (-1, 0): actions.append(0)  # UP\n      elif move == (1, 0): actions.append(1)  # DOWN\n      elif move == (0, -1): actions.append(2)  # LEFT\n      elif move == (0, 1): actions.append(3)  # RIGHT\n\n    # Use the found ingredient to craft the item\n    for _ in range(count):\n      actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the goal is achievable\n  cookbook = env.world.cookbook\n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  actions = []\n  for kind, count in required_ingredients.items():\n    while inventory[kind] < count:\n      found = False\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      if not found:\n        return []\n  \n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the cookbook\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  for ingredient, count in recipe.items():\n    kind = ingredient if isinstance(ingredient, int) else env.world.cookbook.index[ingredient]\n    \n    # If the ingredient is not available in sufficient quantity, try to find and pick it up\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for primitive, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[primitive] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items():\n    recipe = env.world.cookbook.recipes[item]\n    required_items = {}\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, str) and '[' in ingredient:\n        name, arg = env.world.cookbook.parse_fexp(ingredient)\n        index = env.world.index[name]\n        required_items[index] = count\n    return required_items\n\n  def get_inventory():\n    inventory = env._current_state.inventory\n    return {i: inventory[i] for i in range(len(inventory)) if inventory[i] > 0}\n\n  def find_item_in_inventory(required_items):\n    inventory = get_inventory()\n    actions = []\n    for index, count in required_items.items():\n      while inventory[index] < count:\n        item_pos = env.world.index.reverse_contents[index]\n        pos = env._current_state.pos\n        delta_x, delta_y = item_pos[0] - pos[0], item_pos[1] - pos[1]\n        \n        if delta_x > 0:\n          actions.append(3)  # RIGHT\n        elif delta_x < 0:\n          actions.append(2)  # LEFT\n        elif delta_y > 0:\n          actions.append(1)  # UP\n        elif delta_y < 0:\n          actions.append(0)  # DOWN\n        \n        pos = item_pos\n        inventory = env._current_state.inventory\n    \n    return actions, required_items\n\n  def use_item(required_items):\n    actions = []\n    for index in required_items:\n      count = required_items[index]\n      actions += [4] * count  # USE action\n    return actions\n\n  required_items = get_required_items()\n  actions, _ = find_item_in_inventory(required_items)\n  actions += use_item(required_items)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_ingredient(ingredient_index):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        return True, 4  # USE action index\n    return False, None\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  actions = []\n  for ingredient_index, count in recipe.items():\n    while count > 0:\n      found, action = find_and_use_ingredient(ingredient_index)\n      if not found:\n        # Attempt to pick up the ingredient if it's not available in inventory\n        env.step(2)  # PICKUP action index for moving right (PICKUP is always towards the agent's current direction)\n      else:\n        actions.append(action)\n        count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  for ingredient, count in recipe.items():\n    kind = ingredient if isinstance(ingredient, int) else env.world.cookbook.index[ingredient]\n    \n    # If the ingredient is not available in sufficient quantity, try to find and pick it up\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  ingredients_needed = {ingredient: count for ingredient, count in recipe.items() if isinstance(ingredient, int)}\n  for kind, count in ingredients_needed.items():\n    while env._current_state.inventory[kind] < count:\n      # Find and pick up the ingredient if it's not available in sufficient quantity\n      found = False\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3] * (delta_x)  # RIGHT\n          elif delta_x < 0:\n            actions += [2] * abs(delta_x)  # LEFT\n          elif delta_y > 0:\n            actions += [1] * delta_y  # UP\n          elif delta_y < 0:\n            actions += [0] * abs(delta_y)  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          actions += move_to_item(pos, target_pos)\n          \n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += move_to_item(pos, target_pos)\n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_item(env, ingredient_index, count):\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if env.grid[x, y, ingredient_index] == 1:\n          # If this item is available at (x, y), move to that position and use it\n          while True:\n            if x > env.pos[0]:\n              actions.append(1)  # Move down\n              env.pos = (x, y)\n            elif x < env.pos[0]:\n              actions.append(0)  # Move up\n              env.pos = (x, y)\n            elif y > env.pos[1]:\n              actions.append(3)  # Move right\n              env.pos = (x, y)\n            elif y < env.pos[1]:\n              actions.append(2)  # Move left\n              env.pos = (x, y)\n            break\n          return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = find_and_use_item(env, ingredient_index, count)\n    while not found:\n      if env.pos[0] < x:\n        actions.append(1)  # Move down\n      elif env.pos[0] > x:\n        actions.append(0)  # Move up\n      elif env.pos[1] < y:\n        actions.append(3)  # Move right\n      elif env.pos[1] > y:\n        actions.append(2)  # Move left\n    actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the grid or inventory\n    found = False\n    while not found:\n      # Check if the ingredient is available at the current position\n      x, y = env.pos\n      if env.grid[x, y, ingredient_index] == 1:\n        for _ in range(count):\n          actions.append(4)  # Use the ingredient to craft the item\n        found = True\n      else:\n        # If not, move towards the closest ingredient\n        if x < env.grid.shape[0] - 1 and env.grid[x + 1, y, ingredient_index] == 1:\n          actions.append(1)  # Move down\n        elif x > 0 and env.grid[x - 1, y, ingredient_index] == 1:\n          actions.append(0)  # Move up\n        elif y < env.grid.shape[1] - 1 and env.grid[x, y + 1, ingredient_index] == 1:\n          actions.append(3)  # Move right\n        elif y > 0 and env.grid[x, y - 1, ingredient_index] == 1:\n          actions.append(2)  # Move left\n      if not found:\n        time.sleep(0.5)  # Wait a bit before checking again\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Start with a fresh inventory and state\n  env.reset()\n  \n  # Initialize the action list\n  actions = []\n\n  # Retrieve the indices for the goal item and its components from the environment's cookbook\n  index = env.world.cookbook.index\n  goal_item_idx = index.get(item)\n  if goal_item_idx is None:\n    raise ValueError(f\"Item '{item}' not found in cookbook.\")\n  \n  # Check if the item has a recipe\n  components = env.world.cookbook.primitives_for(goal_item_idx)\n  if not components:\n    return []  # No recipe, so nothing to craft\n\n  # Craft each component recursively until all are obtained\n  for component in components:\n    while not env._is_done():\n      state = env.observations()['features']\n      available_components = [i for i, count in enumerate(env.state.inventory) if count > 0]\n      # Find the indices of the components needed for crafting\n      component_idx = index.get(component)\n      if component_idx is None:\n        raise ValueError(f\"Component '{component}' not found in cookbook.\")\n      \n      # Check if we have enough of the required component in our inventory\n      while env.state.inventory[component_idx] < 1:\n        # Find a nearby cell that contains the needed component and move to it\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n          x, y = int(env.state.pos[0] + dx), int(env.state.pos[1] + dy)\n          if 0 <= x < env.world.grid.shape[0] and 0 <= y < env.world.grid.shape[1]:\n            cell_content = env.world.grid[x, y, :]\n            for entity in cell_content:\n              if entity == component_idx:\n                action = [dx, dy].index(max([abs(dx), abs(dy)])) + 2  # Move to the closest matching entity\n                actions.append(action)\n                env.step(action)\n                break\n        \n      # Attempt to use the found component if available\n      action = 4  # USE action\n      actions.append(action)\n      env.step(action)\n    \n    # Once we have enough of the required component, craft it\n    while components:\n      for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        x, y = int(env.state.pos[0] + dx), int(env.state.pos[1] + dy)\n        if 0 <= x < env.world.grid.shape[0] and 0 <= y < env.world.grid.shape[1]:\n          cell_content = env.world.grid[x, y, :]\n          for entity in cell_content:\n            if entity == component_idx:\n              action = [dx, dy].index(max([abs(dx), abs(dy)])) + 2  # Move to the closest matching entity\n              actions.append(action)\n              env.step(action)\n              \n      action = 4  # USE action\n      actions.append(action)\n      env.step(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  # Initialize the action list with actions to get all required primitives\n  actions = []\n  inventory = env._current_state.inventory\n\n  for primitive_kind, count in recipe.items():\n    if count > 0:\n      primitive_index = cookbook.index.get(primitive_kind)\n      if primitive_index is None:\n        raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n      \n      # Check how many of the primitive we have in inventory\n      available_count = inventory[primitive_index]\n      \n      # If we don't have enough, try to pick up more or find a way to craft it from what we have\n      while available_count < count:\n        pickup_actions = []  # Actions to pickup the required amount of the primitive\n        for _ in range(count - available_count):\n          if env.world.non_grabbable_indices & set([primitive_index]):\n            break  # Can't pick up, so we can't craft this item\n          pickup_actions.append(env._get_pickup_action(primitive_index))\n        \n        actions.extend(pickup_actions)\n        available_count = inventory[primitive_index]  # Update the count after potential pickup\n      \n      # If we have enough, use the primitive directly in crafting\n      if available_count >= count:\n        for _ in range(count):\n          actions.append(env._get_use_action(primitive_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = get_item_count(index)\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count and not (target_pos == pos).all():\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = get_item_count(index)\n        \n        if available_count >= count:\n          actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(inventory, ingredient_index):\n    for i in range(len(inventory)):\n      if inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        return i\n    return None\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    while count > 0:\n      if (ingredient := find_ingredient(env.inventory, ingredient_index)) is not None:\n        # Use the found ingredient\n        actions.append(4)  # USE action index\n        env.inventory[ingredient] -= 1\n        count -= 1\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(inventory, ingredient_index):\n    for i in range(len(inventory)):\n      if inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if find_ingredient(env.inventory, ingredient_index):\n      for _ in range(count):\n        actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(recipe):\n    required_ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        required_ingredients.append(key)\n        counts.append(count)\n    return required_ingredients, counts\n  \n  def pickup_required_ingredients(env, required_ingredients, counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(required_ingredients)):\n      while inventory[required_ingredients[i]] < counts[i]:\n        actions += pickup_item(env, required_ingredients[i])\n    return actions\n  \n  def use_ingredients(env, required_ingredients, counts):\n    actions = []\n    for i in range(len(required_ingredients)):\n      action = use_item(env, required_ingredients[i], counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return []\n  \n  required_ingredients, counts = get_required_ingredients(recipe)\n  actions = pickup_required_ingredients(env, required_ingredients, counts)\n  actions += use_ingredients(env, required_ingredients, counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = get_item_count(index)\n      \n      if available_count >= count:\n        actions += [4] * count  # USE action\n      else:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if abs(delta_x) > abs(delta_y):\n            actions += [3] if delta_x > 0 else [2]  # RIGHT or LEFT\n          else:\n            actions += [1] if delta_y > 0 else [0]  # UP or DOWN\n          \n          pos = (pos[0] + (1 if actions[-1] in [3, 4] else -1) * (delta_x != 0),\n                 pos[1] + (1 if actions[-1] in [1, 2] else -1) * (delta_y != 0))\n          inventory = env._current_state.inventory\n          available_count = get_item_count(index)\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      recipe = get_recipe(primitive)\n      count = recipe.get(item, 0)\n      if count > 0:\n        while count > 0:\n          actions.append(4)  # USE action to use the primitive to craft the item\n          count -= 1\n  \n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the environment's cookbook index\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredients = [key for key in recipe.keys() if isinstance(key, int)]\n    counts = [value for value in recipe.values()]\n    return ingredients, counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        if not next_to(env, ingredient_indices[i]):\n          actions += move_to(env, ingredient_indices[i])\n        actions.append(pickup_item(env, ingredient_indices[i]))\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices, ingredient_counts = get_recipe(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices, ingredient_counts)\n  actions += use_ingredients(env, ingredient_indices, ingredient_counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the cookbook.\n  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  # Craft items based on the recipe.\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(4)  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  # Get the required ingredients and their counts from the recipe\n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  # Check if we have all the required ingredients in the inventory\n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  actions = []\n  for kind, count in required_ingredients.items():\n    while inventory[kind] < count:\n      # Find the location of the ingredient in the grid\n      found = False\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the specified item from the cookbook\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  for ingredient, count in recipe.items():\n    kind = ingredient if isinstance(ingredient, int) else env.world.cookbook.index[ingredient]\n    \n    # If the ingredient is not available in sufficient quantity, try to find and pick it up\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  def find_and_craft(actions, inventory, recipe):\n    for primitive in recipe:\n      if inventory[primitive] > 0:\n        while inventory[primitive] >= recipe[primitive]:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          inventory[primitive] -= recipe[primitive]\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  find_and_craft(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} not found in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          actions.append(env.action_index['use'])  # USE action to use the primitive\n          count -= inventory[primitive]\n          inventory[primitive] = 0\n  \n  def collect_primitives(actions, inventory, recipe):\n    for primitive in recipe:\n      if inventory[primitive] < recipe[primitive]:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  collect_primitives(actions, env._current_state.inventory, recipe)\n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Check inventory and get the missing items\n  actions = []\n  for item_idx, count in required_items.items():\n    while env._current_state.inventory[item_idx] < count:\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            env._current_state.inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  for item_idx, count in recipe.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use(count, ingredient_index):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count, ingredient_index):\n      # If the item is not immediately available, try to move towards it\n      if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n        actions.append(0)  # Move up\n      elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n        actions.append(1)  # Move down\n      elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n        actions.append(2)  # Move left\n      elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n        actions.append(3)  # Move right\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use(item_index, count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == item_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(ingredient_index, count):\n      # If the item is not immediately available, try to move towards it\n      if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n        actions.append(0)  # Move up\n      elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n        actions.append(1)  # Move down\n      elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n        actions.append(2)  # Move left\n      elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n        actions.append(3)  # Move right\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    found = False\n    # Find where this ingredient is located in the inventory\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n            break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, kind, count):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          pos = (x, y)\n          dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n          yield dir\n\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  ingredients_needed = {ingredient: count for ingredient, count in recipe.items() if isinstance(ingredient, int)}\n  for kind, count in ingredients_needed.items():\n    while env._current_state.inventory[kind] < count:\n      # Find and pick up the ingredient if it's not available in sufficient quantity\n      found = False\n      for dir in find_ingredient(env, kind, count):\n        actions.append(dir)\n        if env._current_state.step(dir) == (\"use\", None):\n          found = True\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n\n  def find_item_in_inventory(env, index):\n    inventory = env._current_state.inventory\n    available_count = inventory[index]\n    if available_count > 0:\n      return True\n    return False\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      while not find_item_in_inventory(env, index):\n        pos = env._current_state.pos\n        target_pos = get_item_index(name)\n        actions += move_to_item(pos, target_pos)\n        \n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n      for _ in range(count):\n        actions += [4]  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation here!\n  \n  return []", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no ingredient is found, we need to find a way to get it\n        pass\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  \n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) in missing_items:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[item_idx] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  \n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[item_idx] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n      else:\n        # Move to the nearest location containing this ingredient\n        if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n          actions.append(0)  # Move up\n        elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n          actions.append(1)  # Move down\n        elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n          actions.append(2)  # Move left\n        elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n          actions.append(3)  # Move right\n        else:\n          raise ValueError(\"Ingredient not found in the grid.\")\n      found = True\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for crafting the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over each ingredient and its count required by the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      # Check if the ingredient is available in the inventory or can be picked up from the grid\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          found = True\n          break\n      # If not found, move towards the ingredient using available actions (UP, DOWN, LEFT, RIGHT)\n      if not found:\n        if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n          actions.append(0)  # Move up\n        elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n          actions.append(1)  # Move down\n        elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n          actions.append(2)  # Move left\n        elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n          actions.append(3)  # Move right\n        else:\n          raise ValueError(\"Ingredient not found in the grid.\")\n      # If found, use the ingredient to craft the item (USE action)\n      for _ in range(count):\n        actions.append(4)  # USE action index\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_count(index):\n    inventory = env._current_state.inventory\n    return inventory[index]\n  \n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = get_item_count(index)\n      \n      if available_count >= count:\n        actions += [4] * count  # USE action\n      else:\n        target_pos = env.world.index[name]\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0 and get_item_count(index) > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0 and get_item_count(index) > 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0 and get_item_count(index) > 0:\n            actions += [1]  # UP\n          elif delta_y < 0 and get_item_count(index) > 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = get_item_count(index)\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the inventory\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0:\n        # Check if this item can be used to craft the goal item\n        if env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          for _ in range(count):\n            actions.append(4)  # USE action index\n          break\n        if not found:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item in the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Retrieve the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  actions = []\n\n  # Iterate over required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        # If the ingredient is found in inventory, add 'USE' actions accordingly\n        for _ in range(count):\n          actions.append(4)  # USE action index\n        break\n      else:\n        found = True\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  inventory = env._current_state.inventory\n  \n  while missing_items:\n    # Find the position of each missing item and move towards it if necessary\n    for item_idx, count in list(missing_items.items()):\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item if possible\n            pickupable = env.world.non_grabbable_indices.isdisjoint({item_pos})\n            if pickupable:\n              actions.append(env.action_index['pickup'])\n              inventory[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n      \n      # If we picked up all required items, craft the desired item\n      if len(missing_items) == 0:\n        actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          return (x, y)\n    return None\n\n  def craft_ingredient(kind):\n    pos = find_ingredient(kind)\n    if not pos:\n      return False\n    dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n    while True:\n      actions = [dir] if env._current_state.step(dir) != (\"use\", None) else []\n      if not actions:\n        break\n    return True\n\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  # Get the required ingredients and their counts from the recipe\n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  # Check if we have all the required ingredients in the inventory\n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  actions = []\n  for kind in required_ingredients:\n    while inventory[kind] < required_ingredients[kind]:\n      if not craft_ingredient(kind):\n        return []\n    actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n  \n  def find_item_in_inventory(env, index):\n    inventory = env._current_state.inventory\n    available_count = inventory[index]\n    if available_count > 0:\n      return True\n    return False\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      while not find_item_in_inventory(env, index):\n        pos = env._current_state.pos\n        target_pos = get_item_index(name)\n        actions += move_to_item(pos, target_pos)\n        \n        inventory = env._current_state.inventory\n        available_count = inventory[index]\n      \n      for _ in range(count):\n        actions += [4]  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n  positions = get_item_positions(env._current_state.grid)\n\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(x[0]) - np.array(env._current_state.pos))):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_grid(pos, grid):\n    for i in range(3):\n      for j in range(3):\n        if grid[pos[0]+i-1, pos[1]+j-1] == item:\n          return (pos[0]+i-1, pos[1]+j-1)\n    return None\n\n  # Find the index of the desired item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n      raise ValueError(\"Item {} not found in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not recipe:\n      return []\n  \n  actions = []\n  \n  while any(env._current_state.inventory[item_idx] < count for item_idx, count in recipe.items()):\n    # Check inventory and get the missing items\n    inventory = env._current_state.inventory\n    for item_idx, count in recipe.items():\n      if inventory[item_idx] < count:\n        # Find the position of the item and move towards it if necessary\n        pos = find_item_in_grid(env._current_state.pos, env._current_state.grid)\n        if not pos:\n          raise ValueError(\"Item {} not found in the grid.\".format(item_idx))\n        \n        # Move to the position and pick up the item\n        actions.append(env.action_index['pickup'])\n  \n  # Craft the desired item and update inventory\n  for _ in range(len(recipe)):\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Retrieve the recipe for crafting this item\n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  actions = []\n  \n  inventory = env._current_state.inventory\n  needed_items = {item_idx: count for item_idx, count in required_items.items() if inventory[item_idx] < count}\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not needed_items:\n    return []\n  \n  while any(needed_items.values()):\n    for item_idx, count in needed_items.items():\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env._current_state.pos\n        grid = env._current_state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              needed_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          return (x, y)\n    return None\n\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Check the inventory for each ingredient required by the recipe\n  required_ingredients = {kind: count for kind, count in recipe.items() if isinstance(kind, int)}\n  available_ingredients = {kind: env._current_state.inventory[kind] for kind in required_ingredients}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if any(available_ingredients[kind] < required_ingredients[kind] for kind in required_ingredients):\n    return []\n  \n  actions = []\n  for kind, count in required_ingredients.items():\n    while env._current_state.inventory[kind] < count:\n      pos = find_ingredient(env, kind)\n      if pos is None:\n        return []\n      dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n      actions.append(dir)\n      if env._current_state.step(dir) == (\"use\", None):\n        break\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use(count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count):\n      # If the item is not immediately available, try to move towards it\n      if env.pos[0] > 0 and np.any(env.grid[env.pos[0]-1, env.pos[1], :] == ingredient_index):\n        actions.append(0)  # Move up\n      elif env.pos[0] < env.grid.shape[0]-1 and np.any(env.grid[env.pos[0]+1, env.pos[1], :] == ingredient_index):\n        actions.append(1)  # Move down\n      elif env.pos[1] > 0 and np.any(env.grid[env.pos[0], env.pos[1]-1, :] == ingredient_index):\n        actions.append(2)  # Move left\n      elif env.pos[1] < env.grid.shape[1]-1 and np.any(env.grid[env.pos[0], env.pos[1]+1, :] == ingredient_index):\n        actions.append(3)  # Move right\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the list to store actions\n  actions = []\n  \n  # Check if the goal is achievable\n  recipe = env.world.cookbook.primitives_for(item)\n  if not recipe:\n    raise ValueError(\"The item cannot be crafted.\")\n  \n  # Collect required resources for crafting\n  resource_counts = {k: v for k, v in recipe.items() if k != \"_key\"}\n  \n  # Inventory of the agent\n  inventory = env._current_state.inventory\n  \n  # Check what's available and collect them\n  for resource, count in resource_counts.items():\n    while count > 0:\n      found_count = min(count, np.sum(inventory[resource]))\n      if found_count <= 0:\n        break\n      actions.append(env.world.cookbook.index.get(resource))\n      inventory[resource] -= 1\n      count -= found_count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the given item\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  ingredients_needed = {ingredient: count for ingredient, count in recipe.items() if isinstance(ingredient, int)}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(ingredients_needed) != len(recipe):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  for kind, count in ingredients_needed.items():\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, kind] == 1:\n            # Move to the ingredient location and pick it up\n            pos = (x, y)\n            dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n            actions.append(dir)\n            if env._current_state.step(dir) == (\"use\", None):\n              found = True\n              break\n        if found:\n          break\n      \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n  \n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        actions += move_to_item(env._current_state.pos, target_pos)\n        \n        while available_count < count:\n          actions += [4]  # USE action\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, ingredient):\n    index = env.world.index[ingredient]\n    pos = None\n    for workshop in env.world.workshop_indices:\n      if env.world.grid[workshop][0] == index:\n        pos = workshop\n        break\n    return pos\n\n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        pos = env._current_state.pos\n        while available_count < count:\n          target_pos = find_ingredient(env, ingredient)\n          if not target_pos:\n            break\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3]  # RIGHT\n          elif delta_x < 0:\n            actions += [2]  # LEFT\n          elif delta_y > 0:\n            actions += [1]  # UP\n          elif delta_y < 0:\n            actions += [0]  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = env.world.index[name]\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      actions += [4] * min(available_count, count)  # USE action\n      \n      if available_count < count:\n        pos = env._current_state.pos\n        while available_count < count:\n          target_pos = None\n          for workshop in env.world.workshop_indices:\n            if env.world.grid[workshop][0] == index:\n              target_pos = workshop\n              break\n          \n          if target_pos is not None:\n            delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n            \n            if delta_x > 0:\n              actions += [3]  # RIGHT\n            elif delta_x < 0:\n              actions += [2]  # LEFT\n            elif delta_y > 0:\n              actions += [1]  # UP\n            elif delta_y < 0:\n              actions += [0]  # DOWN\n            \n            pos = target_pos\n            inventory = env._current_state.inventory\n            available_count = inventory[index]\n          \n          if available_count >= count:\n            break\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        actions += move_to_item(env._current_state.pos, (index, 0))\n        \n        while available_count < count:\n          actions += [4]  # USE action\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.cookbook.index[name]\n\n  recipe = env.world.cookbook.recipes[item]\n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        pos = env._current_state.pos\n        \n        while available_count < count:\n          delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n          \n          if delta_x > 0:\n            actions += [3] * (delta_x)  # RIGHT\n          elif delta_x < 0:\n            actions += [2] * abs(delta_x)  # LEFT\n          elif delta_y > 0:\n            actions += [1] * delta_y  # UP\n          elif delta_y < 0:\n            actions += [0] * abs(delta_y)  # DOWN\n          \n          pos = target_pos\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        if available_count >= count:\n          actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(primitive))  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while inventory[primitive] >= count:\n        actions.append(4)  # USE action to use the primitive to craft the item\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          pos = (x, y)\n          dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n          yield dir\n  \n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  ingredients_needed = {ingredient: count for ingredient, count in recipe.items() if isinstance(ingredient, int)}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(ingredients_needed) != len(recipe):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  for kind, count in ingredients_needed.items():\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for dir in find_ingredient(env, kind):\n        actions.append(dir)\n        if env._current_state.step(dir) == (\"use\", None):\n          found = True\n          break\n        \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(env, kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          pos = (x, y)\n          dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n          yield dir\n\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(\"Item {} has no recipe.\".format(item))\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Check the inventory for each ingredient required by the recipe\n  ingredients_needed = {ingredient: count for ingredient, count in recipe.items() if isinstance(ingredient, int)}\n  \n  # If not all ingredients are available, return an empty list (no action to craft)\n  if len(ingredients_needed) != len(recipe):\n    return []\n  \n  # Craft the item by performing the necessary actions for each ingredient required in the recipe\n  for kind, count in ingredients_needed.items():\n    while env._current_state.inventory[kind] < count:\n      found = False\n      \n      # Search the grid for the ingredient\n      for dir in find_ingredient(env, kind):\n        actions.append(dir)\n        if env._current_state.step(dir) == (\"use\", None):\n          found = True\n          break\n        \n      # If the ingredient was not found in the grid, return an empty list (no action to craft)\n      if not found:\n        return []\n  \n  # Craft the item by performing the use action for each ingredient required in the recipe\n  actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Define the actions needed to find and use the recipe for crafting an item.\n  def find_ingredient(kind):\n    for x in range(env._current_state.grid.shape[0]):\n      for y in range(env._current_state.grid.shape[1]):\n        if env._current_state.grid[x, y, kind] == 1:\n          return (x, y)\n    return None\n\n  def craft_ingredient(kind):\n    pos = find_ingredient(kind)\n    if not pos:\n      return False\n    dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n    while True:\n      actions = [dir] if env._current_state.step(dir) != (\"use\", None) else []\n      if not actions:\n        break\n    return True\n\n  # Get the recipe for the desired item.\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  # Get the required ingredients and their counts from the recipe.\n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  # Check if we have all the required ingredients in the inventory.\n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  # If not all ingredients are available, return an empty list (no action to craft).\n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  actions = []\n  for kind in required_ingredients:\n    while inventory[kind] < required_ingredients[kind]:\n      if not craft_ingredient(kind):\n        return []\n    actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Define the directions for movement and use actions\n  dir_actions = {0: 'down', 1: 'up', 2: 'left', 3: 'right', 4: 'use'}\n  \n  def get_ingredient_pos(kind):\n    grid = env._current_state.grid\n    for x in range(grid.shape[0]):\n      for y in range(grid.shape[1]):\n        if grid[x, y, kind] == 1:\n          return (x, y)\n    return None\n\n  def craft_ingredient(kind):\n    pos = get_ingredient_pos(kind)\n    if not pos:\n      return False\n    dir = np.argmax([pos == (x + dx, y + dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]) - 1\n    while True:\n      action = dir_actions[dir]\n      if env._current_state.step(action) != (\"use\", None):\n        break\n    return True\n\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  recipe = cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item {item} has no recipe.\")\n  \n  required_ingredients = {}\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, int):\n      required_ingredients[ingredient] = count\n  \n  inventory = env._current_state.inventory\n  available_ingredients = {kind: inventory[kind] for kind in required_ingredients if inventory[kind] >= required_ingredients[kind]}\n  \n  if len(available_ingredients) != len(required_ingredients):\n    return []\n  \n  actions = []\n  for kind in required_ingredients:\n    while inventory[kind] < required_ingredients[kind]:\n      if not craft_ingredient(kind):\n        return []\n    actions.append(4)  # Use action to craft the desired item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory that are needed for crafting.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up from inventory\n      actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  # If no recipe is found, return an empty list (it's already crafted).\n  if not recipe:\n    return []\n\n  actions = []\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    inventory = env._current_state.inventory\n    \n    # Find all instances of the primitive in the inventory that are needed for crafting.\n    indices = np.where(inventory[primitive] > 0)[0]\n    \n    # For each instance found, perform a pickup action if necessary.\n    for index in indices:\n      actions.append(4)  # USE action to pick up the primitive from the inventory\n      \n    # After picking up all required instances, perform a craft action for each count.\n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    return ingredient_indices\n  \n  def pickup_ingredients(env, ingredient_indices):\n    actions = []\n    inventory = env._current_state.inventory\n    for index in ingredient_indices:\n      while inventory[index] < recipe[index]:\n        action = pickup_item(env, index)\n        if action is not None:\n          actions.append(action)\n          env._current_state = env.step(action)[1]  # Update the state after pickup\n    return actions\n  \n  def use_ingredients(env, ingredient_indices):\n    actions = []\n    for index in ingredient_indices:\n      action = use_item(env, index, recipe[index])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices)\n  actions += use_ingredients(env, ingredient_indices)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Try to pick up all required ingredients first\n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      actions += pickup_item(env, ingredients[i])\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # If there's no recipe, return an empty list (not possible in a well-defined environment)\n  if not recipe:\n    return []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      # Check if the item is already in the inventory\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          actions.extend([4] * count)  # Use the found item 'count' times\n          found = True\n          break\n      else:\n        # If not, find where this ingredient is located in the grid and move to it if possible\n        pos = np.argwhere(env.grid[:, :, ingredient_index] == 1)\n        if len(pos) > 0:\n          row, col = pos[0]\n          # Move towards the found item\n          if env.pos[0] > row and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n            actions.append(0)  # Move up\n          elif env.pos[0] < row and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n            actions.append(1)  # Move down\n          elif env.pos[1] > col and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n            actions.append(2)  # Move left\n          elif env.pos[1] < col and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n            actions.append(3)  # Move right\n        else:\n          raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_grid(env, grid, kind):\n    for y in range(grid.shape[0]):\n      for x in range(grid.shape[1]):\n        if grid[y, x] == kind:\n          return (x, y)\n    raise ValueError(\"Item not found in the grid.\")\n\n  def move_to_item(env, item_pos):\n    pos = env._current_state.pos\n    actions = []\n    while pos != item_pos:\n      dx = np.sign(item_pos[0] - pos[0])\n      dy = np.sign(item_pos[1] - pos[1])\n      if dx > 0 and env._is_free((pos[0]+dx, pos[1])):\n        actions.append(env.action_index['right'])\n        pos = (pos[0]+dx, pos[1])\n      elif dx < 0 and env._is_free((pos[0]-dx, pos[1])):\n        actions.append(env.action_index['left'])\n        pos = (pos[0]-dx, pos[1])\n      if dy > 0 and env._is_free((pos[0], pos[1]+dy)):\n        actions.append(env.action_index['down'])\n        pos = (pos[0], pos[1]+dy)\n      elif dy < 0 and env._is_free((pos[0], pos[1]-dy)):\n        actions.append(env.action_index['up'])\n        pos = (pos[0], pos[1]-dy)\n    return actions, pos\n\n  # Find the index of the item in the cookbook\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  # Iterate over the required primitives and their counts in the recipe.\n  for primitive, count in recipe.items():\n    while inventory[primitive] < count:\n      # Find the position of the item in the grid\n      grid = env._current_state.grid\n      item_pos = find_item_in_grid(env, grid, primitive)\n      \n      # Move to the item if necessary\n      actions_to_item, _ = move_to_item(env, item_pos)\n      actions.extend(actions_to_item)\n      \n      # Perform a pickup action (USE for now, as it is assumed that we need to pick up from the grid)\n      actions.append(4)  # USE action to pick up from the grid\n    \n    # Craft the desired item and update inventory\n    actions.append(4)  # USE action to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item_in_grid(env, grid, pos, target_kind):\n    for dx in range(-1, 2):\n      for dy in range(-1, 2):\n        if (pos[0]+dx, pos[1]+dy) == item_pos:\n          return True\n    return False\n\n  def find_item_in_inventory(env, inventory, target_kind):\n    indices = np.where(inventory == target_kind)[0]\n    if len(indices) > 0:\n      return int(indices[0])  # Assuming we can pick up the first found instance\n    return None\n  \n  def find_pickup_action(env, index):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    for dx in range(-1, 2):\n      for dy in range(-1, 2):\n        if (pos[0]+dx, pos[1]+dy) == item_pos:\n          return env.action_index['pickup']\n    raise ValueError(\"Item not found in the grid.\")\n  \n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env._current_state.inventory\n  \n  for primitive, count in recipe.items():\n    indices = np.where(inventory[primitive] > 0)[0]\n    for index in indices:\n      pickup_action = find_pickup_action(env, index)\n      actions.append(pickup_action)\n    \n    for _ in range(count):\n      actions.append(4)  # USE action to use the primitive to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the goal is valid\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item from the cookbook\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the cookbook\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  # Initialize the action list with actions to get all required primitives\n  actions = []\n  inventory = env._current_state.inventory\n\n  for primitive_kind, count in recipe.items():\n    if count > 0:\n      primitive_index = cookbook.index.get(primitive_kind)\n      if primitive_index is None:\n        raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n      \n      # Check how many of the primitive we have in inventory\n      available_count = inventory[primitive_index]\n      \n      # If we don't have enough, try to pick up more or find a way to craft it from what we have\n      while available_count < count:\n        pickup_actions = []  # Actions to pickup the required amount of the primitive\n        for _ in range(count - available_count):\n          if env.world.non_grabbable_indices & set([primitive_index]):\n            break  # Can't pick up, so we can't craft this item\n          pickup_actions.append(env._get_pickup_action(primitive_index))\n        \n        actions.extend(pickup_actions)\n        available_count = inventory[primitive_index]  # Update the count after potential pickup\n      \n      # If we have enough, use the primitive directly in crafting\n      if available_count >= count:\n        for _ in range(count):\n          actions.append(env._get_use_action(primitive_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  # Initialize the action list with actions to get all required primitives\n  actions = []\n  inventory = env._current_state.inventory\n\n  for primitive_kind, count in recipe.items():\n    if count > 0:\n      primitive_index = cookbook.index.get(primitive_kind)\n      if primitive_index is None:\n        raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n      \n      # Check how many of the primitive we have in inventory\n      available_count = inventory[primitive_index]\n      \n      # If we don't have enough, try to pick up more or find a way to craft it from what we have\n      while available_count < count:\n        pickup_actions = []  # Actions to pickup the required amount of the primitive\n        for _ in range(count - available_count):\n          if env.world.non_grabbable_indices & set([primitive_index]):\n            break  # Can't pick up, so we can't craft this item\n          pickup_actions.append(env._get_pickup_action(primitive_index))\n        \n        actions.extend(pickup_actions)\n        available_count = inventory[primitive_index]  # Update the count after potential pickup\n      \n      # If we have enough, use the primitive directly in crafting\n      if available_count >= count:\n        for _ in range(count):\n          actions.append(env._get_use_action(primitive_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use(count):\n    for i in range(len(env.inventory)):\n      if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n        actions.extend([4] * count)  # Use the found item 'count' times\n        return True\n    return False\n\n  def move_to_ingredient():\n    if env.pos[0] > 0 and env.grid[env.pos[0]-1, env.pos[1], ingredient_index] == 1:\n      actions.append(0)  # Move up\n    elif env.pos[0] < env.grid.shape[0]-1 and env.grid[env.pos[0]+1, env.pos[1], ingredient_index] == 1:\n      actions.append(1)  # Move down\n    elif env.pos[1] > 0 and env.grid[env.pos[0], env.pos[1]-1, ingredient_index] == 1:\n      actions.append(2)  # Move left\n    elif env.pos[1] < env.grid.shape[1]-1 and env.grid[env.pos[0], env.pos[1]+1, ingredient_index] == 1:\n      actions.append(3)  # Move right\n    else:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  for ingredient_index, count in recipe.items():\n    while not find_and_use(count):\n      move_to_ingredient()\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Check inventory for each required ingredient\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(env, item_index):\n    grid = env._current_state.grid\n    pos = env._current_state.pos\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy, item_index] > 0:\n          return (pos[0]+dx, pos[1]+dy)\n    raise ValueError(\"Item not found in the grid.\")\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  for primitive, count in recipe.items():\n    while inventory[primitive] > 0 and count > 0:\n      item_pos = find_and_move_to_item(env, primitive)\n      actions.append(4)  # USE action to use the primitive\n      inventory[primitive] -= 1\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(actions, pos, grid):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0] + dx, pos[1] + dy] == item:\n          actions.append(env.action_index['move_right'])\n          return True\n    return False\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  while any(count > 0 for count in recipe.values() if inventory[primitive] > 0):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    found = find_and_move_to_item(actions, pos, grid)\n    if not found:\n      raise ValueError(\"Item not found in the inventory.\")\n    actions.append(env.action_index['pickup'])\n    \n  craft_items(actions, inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Prioritize collecting items that are directly next to the agent\n  for ingredient_index in sorted(ingredients, key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - get_item_position(env._current_state.grid, x)), reverse=True):\n    item_position = get_item_position(env._current_state.grid, ingredient_index)\n    if item_position is not None:\n      move_to(item_position)\n      pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Prioritize collecting items that are directly next to the agent\n  for ingredient_index in ingredients:\n    target_pos = get_item_position(env._current_state.grid, ingredient_index)\n    if target_pos is not None:\n      move_to(target_pos)\n      pickup()\n\n  # If all required items are collected, craft the item\n  if all(env._current_state.inventory[ingredient] >= count for ingredient, count in ingredients.items()):\n    target_pos = get_item_position(env._current_state.grid, goal_item_idx)\n    if target_pos is not None:\n      move_to(target_pos)\n      actions.append(env_factory.USE)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] > 0:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          env.inventory[ingredient_index] -= 1  # Decrease the count of the ingredient in the inventory\n          found = True\n          break\n        if i == len(env.grabbable_indices) - 1:\n          actions.append(i)  # If not found, use the action to try again later\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_recipe(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredients, counts = [], []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  def pickup_missing_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices, ingredient_counts = find_recipe(goal_index)\n  actions = pickup_missing_ingredients(env, ingredient_indices, ingredient_counts)\n  actions += use_ingredients(env, ingredient_indices, ingredient_counts)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_index(name):\n    return env.world.index[name]\n\n  def move_to_item(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * delta_x  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * abs(delta_x)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * delta_y  # UP\n    elif delta_y < 0:\n      actions += [0] * abs(delta_y)  # DOWN\n    \n    return actions\n\n  def use_item_at_pos(pos, target_pos):\n    delta_x, delta_y = target_pos[0] - pos[0], target_pos[1] - pos[1]\n    \n    actions = []\n    if delta_x > 0:\n      actions += [3] * (delta_x - 1)  # RIGHT\n    elif delta_x < 0:\n      actions += [2] * (abs(delta_x) - 1)  # LEFT\n    elif delta_y > 0:\n      actions += [1] * (delta_y - 1)  # UP\n    elif delta_y < 0:\n      actions += [0] * (abs(delta_y) - 1)  # DOWN\n    \n    return actions\n\n  recipe = env.world.cookbook.recipes[item]\n  \n  actions = []\n  \n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      name, arg = env.world.cookbook.parse_fexp(ingredient)\n      index = get_item_index(name)\n      \n      inventory = env._current_state.inventory\n      available_count = inventory[index]\n      \n      if available_count < count:\n        target_pos = get_item_index(name)\n        actions += move_to_item(env._current_state.pos, target_pos)\n        \n        while available_count < count:\n          actions += use_item_at_pos(env._current_state.pos, target_pos)  # USE action at the target position\n          inventory = env._current_state.inventory\n          available_count = inventory[index]\n        \n        actions += [4] * count  # USE action\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    found = False\n    while not found:\n      # Check if this item is available in the inventory\n      for i in range(len(env.inventory)):\n        if env.inventory[i] > 0 and env.world.cookbook.index.get(i) == ingredient_index:\n          # If it can, add 'USE' actions for each count of the ingredient found\n          actions.append(4)  # USE action index\n          break\n      if not found:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in inventory to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    inventory_count = 0\n    while inventory_count < count:\n      # Check the grid to find the ingredients\n      found = False\n      for i in range(env.grid.shape[0]):\n        for j in range(env.grid.shape[1]):\n          if env.grid[i, j, ingredient_index] == 1:\n            # If the item is found on the grid, move to it and use it\n            pos = (i, j)\n            if pos[0] < env.pos[0]:\n              actions.append(0)  # Move up\n            elif pos[0] > env.pos[0]:\n              actions.append(1)  # Move down\n            elif pos[1] < env.pos[1]:\n              actions.append(2)  # Move left\n            elif pos[1] > env.pos[1]:\n              actions.append(3)  # Move right\n            else:\n              raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n            inventory_count += 1\n            if inventory_count < count:\n              actions.append(4)  # USE action index\n            break\n        if found:\n          break\n      else:\n        raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_pickup_actions(target_index, count):\n    pickup_actions = []\n    available_count = env._current_state.inventory[target_index]\n    while available_count < count:\n      if target_index in env.world.non_grabbable_indices:\n        break  # Can't pick up, so we can't craft this item\n      pickup_actions.append(env._get_pickup_action(target_index))\n      available_count = env._current_state.inventory[target_index]  # Update the count after potential pickup\n    return pickup_actions\n\n  def get_use_actions(target_index, count):\n    use_actions = []\n    for _ in range(count):\n      use_actions.append(env._get_use_action(target_index))\n    return use_actions\n\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  # Initialize the action list with actions to get all required primitives\n  actions = []\n  inventory = env._current_state.inventory\n\n  for primitive_kind, count in recipe.items():\n    if count > 0:\n      primitive_index = cookbook.index.get(primitive_kind)\n      if primitive_index is None:\n        raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n      \n      # Check how many of the primitive we have in inventory\n      available_count = inventory[primitive_index]\n      \n      # If we don't have enough, try to pick up more or find a way to craft it from what we have\n      pickup_actions = get_pickup_actions(primitive_index, count)\n      actions.extend(pickup_actions)\n\n      # Use the primitive directly in crafting if possible\n      use_actions = get_use_actions(primitive_index, count)\n      actions.extend(use_actions)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Define a helper function to check if we have enough inventory for crafting\n  def has_enough_inventory(required_count):\n    return env._current_state.inventory >= required_count\n\n  # Define a helper function to craft an item using available primitives\n  def craft_item(goal_index, recipe):\n    actions = []\n    inventory = env._current_state.inventory\n\n    for primitive_kind, count in recipe.items():\n      if count > 0:\n        primitive_index = cookbook.index.get(primitive_kind)\n        if primitive_index is None:\n          raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n        \n        # Check how many of the primitive we have in inventory\n        available_count = inventory[primitive_index]\n        \n        # If we don't have enough, try to pick up more or find a way to craft it from what we have\n        while available_count < count:\n          pickup_actions = []  # Actions to pickup the required amount of the primitive\n          for _ in range(count - available_count):\n            if env.world.non_grabbable_indices & set([primitive_index]):\n              break  # Can't pick up, so we can't craft this item\n            pickup_actions.append(env._get_pickup_action(primitive_index))\n          \n          actions.extend(pickup_actions)\n          available_count = inventory[primitive_index]  # Update the count after potential pickup\n        \n        # If we have enough, use the primitive directly in crafting\n        if available_count >= count:\n          for _ in range(count):\n            actions.append(env._get_use_action(primitive_index))\n    \n    return actions\n\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  actions = craft_item(goal_index, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    # Find where this ingredient is located in the grid\n    found = False\n    for x in range(env.grid.shape[0]):\n      for y in range(env.grid.shape[1]):\n        if env.grid[x, y, ingredient_index] == 1:\n          # If it's found, add actions to move and pick up the item\n          dx = x - env.pos[0]\n          dy = y - env.pos[1]\n          while not (dx == 0 and dy == 0) or count > 0:\n            if dx < 0:\n              actions.append(2)  # PICKUP action index\n              dx += 1\n            elif dx > 0:\n              actions.append(3)  # DROP action index\n              dx -= 1\n            elif dy < 0:\n              actions.append(0)  # MOVE_DOWN action index\n              dy += 1\n            elif dy > 0:\n              actions.append(1)  # MOVE_UP action index\n              dy -= 1\n          count -= 1\n          break\n      if found:\n        break\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in the grid to craft item {item}.\")\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  def find_and_use_ingredient(ingredient_index, count):\n    while not env.satisfies(ingredient_index, goal_index) and count > 0:\n      if env.next_to(ingredient_index):\n        actions.append(4)  # USE action index\n        count -= 1\n      else:\n        break\n\n  # Iterate over the required ingredients and their counts from the recipe\n  for ingredient_index, count in recipe.items():\n    find_and_use_ingredient(ingredient_index, count)\n\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n\n    while count > 0:\n      found = False\n      # Try to find the ingredient without repeating the last action unless it's possible to craft another item immediately\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n          actions.append(i)\n          count -= 1\n          found = True\n          break\n      # If no suitable action was found, try to find any available ingredient\n      if not found:\n        for i in range(len(env.grabbable_indices)):\n          if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n            actions.append(i)\n            count -= 1\n            break\n      # If no available ingredient was found, raise an error\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            # Find the closest grabbable item to pick up and use it for crafting\n            pos = env._current_state.pos\n            dists = [(idx, ((x - pos[0]) ** 2 + (y - pos[1]) ** 2) ** 0.5) for idx, x, y in zip(env.world.grabbable_indices, *np.where(env._current_state.grid == required_item))]\n            dists = sorted(dists, key=lambda x: x[1])\n            if dists:\n              closest_idx = dists[0][0]\n              actions.append(closest_idx)\n              actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def has_enough_inventory(required_count):\n    return env._current_state.inventory >= required_count\n\n  # Define a helper function to craft an item using available primitives\n  def craft_item(goal_index, recipe):\n    actions = []\n    inventory = env._current_state.inventory\n\n    for primitive_kind, count in recipe.items():\n      if count > 0:\n        primitive_index = cookbook.index.get(primitive_kind)\n        if primitive_index is None:\n          raise ValueError(f\"Primitive {primitive_kind} not found in cookbook.\")\n        \n        # Check how many of the primitive we have in inventory\n        available_count = inventory[primitive_index]\n        \n        # If we don't have enough, try to pick up more or find a way to craft it from what we have\n        while available_count < count:\n          pickup_actions = []  # Actions to pickup the required amount of the primitive\n          for _ in range(count - available_count):\n            if env.world.non_grabbable_indices & set([primitive_index]):\n              break  # Can't pick up, so we can't craft this item\n            pickup_actions.append(env._get_pickup_action(primitive_index))\n          \n          actions.extend(pickup_actions)\n          available_count = inventory[primitive_index]  # Update the count after potential pickup\n        \n        # If we have enough, use the primitive directly in crafting\n        if available_count >= count:\n          for _ in range(count):\n            actions.append(env._get_use_action(primitive_index))\n    \n    return actions\n\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  actions = craft_item(goal_index, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def has_enough_inventory(required_count):\n    inventory = env._current_state.inventory\n    return all(inventory[i] >= required_count for i in required_count.keys())\n\n  # Define a helper function to craft an item using available primitives\n  def craft_item(goal_index, recipe):\n    actions = []\n\n    while not has_enough_inventory(recipe):\n      # Find the primitive with the least count that we need more of\n      min_required = float('inf')\n      for primitive_kind, count in recipe.items():\n        if count > 0:\n          primitive_index = cookbook.index.get(primitive_kind)\n          available_count = env._current_state.inventory[primitive_index]\n          if available_count < count and available_count < min_required:\n            min_required = available_count\n            target_primitive = primitive_kind\n      \n      # If we can't find a primitive to pickup, break the loop (shouldn't happen with proper recipe)\n      if min_required == float('inf'):\n        break\n\n      # Pickup actions for the target primitive\n      while env._current_state.inventory[cookbook.index.get(target_primitive)] < recipe[target_primitive]:\n        actions.append(env._get_pickup_action(cookbook.index.get(target_primitive)))\n    \n    # Craft the item using the available primitives\n    for primitive_kind, count in recipe.items():\n      if count > 0:\n        while env._current_state.inventory[cookbook.index.get(primitive_kind)] < count:\n          actions.append(env._get_use_action(cookbook.index.get(primitive_kind)))\n    \n    return actions\n\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n\n  # Get the recipe for the desired item\n  recipe = cookbook.primitives_for(goal_index)\n  if not recipe:\n    return []  # No recipe found, so nothing to do\n\n  actions = craft_item(goal_index, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Check inventory for each required ingredient\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your implementation here\n\n  return []", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    return ingredient_indices\n  \n  def pickup_ingredients(env, ingredient_indices):\n    actions = []\n    inventory = env._current_state.inventory\n    for index in ingredient_indices:\n      while inventory[index] < recipe[index]:\n        if can_pickup_item(env, index):\n          actions.append(0)  # PICKUP action\n        else:\n          break\n        time.sleep(1)  # Simulate delay in picking up items\n    return actions\n  \n  def use_ingredients(env, ingredient_indices):\n    actions = []\n    for index in ingredient_indices:\n      if can_use_item(env, index):\n        actions.append(4)  # USE action\n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices)\n  actions += use_ingredients(env, ingredient_indices)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    return ingredient_indices\n  \n  def pickup_ingredients(env, ingredient_indices):\n    actions = []\n    inventory = env._current_state.inventory\n    for index in ingredient_indices:\n      while inventory[index] < recipe[index]:\n        action = use_item(env, index)\n        if action is not None:\n          actions.append(action)\n    return actions\n  \n  def craft_ingredients(env, ingredient_indices):\n    actions = []\n    for index in ingredient_indices:\n      action = use_item(env, index)\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the recipe for the desired item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  ingredient_indices = find_required_ingredients(goal_index)\n  actions = pickup_ingredients(env, ingredient_indices)\n  actions += craft_ingredients(env, ingredient_indices)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Extract the ingredient indices and counts from the recipe\n  ingredients = [(ingredient_index, count) for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  while len(ingredients) > 0:\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredients[0][0]] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        ingredients.pop(0)  # Remove the used ingredient from the list\n        break\n    else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  actions = []\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_item_indices(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_item_indices(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(env.world.grabbable_indices.index(required_item))\n    return required_items\n  \n  # Get the list of indices for items needed to craft the desired item\n  required_item_indices = get_required_item_indices(item)\n  \n  actions = []\n  for index in required_item_indices:\n    actions.append(index)\n    if env._current_state.inventory[index] == 0:\n      actions.append(env.world.grabbable_indices.index(index))\n    actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_move_to_item(env, item_index):\n    index = env.world.cookbook.index\n    item_idx = index.get(item)\n    if item_idx is None:\n      raise ValueError(f\"Item '{item}' not found in cookbook.\")\n    \n    while True:\n      state = env.observations()['features']\n      available_components = [i for i, count in enumerate(env.state.inventory) if count > 0]\n      \n      # Find the indices of the components needed for crafting\n      component_idx = index.get(item_index)\n      if component_idx is None:\n        raise ValueError(f\"Component '{item_index}' not found in cookbook.\")\n      \n      # Check if we have enough of the required component in our inventory\n      while env.state.inventory[component_idx] < 1:\n        # Find a nearby cell that contains the needed component and move to it\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n          x, y = int(env.state.pos[0] + dx), int(env.state.pos[1] + dy)\n          if 0 <= x < env.world.grid.shape[0] and 0 <= y < env.world.grid.shape[1]:\n            cell_content = env.world.grid[x, y, :]\n            for entity in cell_content:\n              if entity == component_idx:\n                action = [dx, dy].index(max([abs(dx), abs(dy)])) + 2  # Move to the closest matching entity\n                env.step(action)\n                break\n        \n      # Attempt to use the found component if available\n      env.step(4)  # USE action\n      time.sleep(0.1)\n      \n      state_after_use = env.observations()['features']\n      if np.any(state_after_use != state):\n        break  # If the grid has changed after using, we have successfully crafted the item\n  \n  actions = []\n  index = env.world.cookbook.index\n  goal_item_idx = index.get(item)\n  if goal_item_idx is None:\n    raise ValueError(f\"Item '{item}' not found in cookbook.\")\n  \n  # Check if the item has a recipe\n  components = env.world.cookbook.primitives_for(goal_item_idx)\n  if not components:\n    return []  # No recipe, so nothing to craft\n\n  # Craft each component recursively until all are obtained\n  for component in components:\n    find_and_move_to_item(env, component)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_move_to_component(env, component_idx):\n    index = env.world.cookbook.index\n    while not env._is_done() and env.state.inventory[component_idx] < 1:\n      state = env.observations()['features']\n      available_components = [i for i, count in enumerate(env.state.inventory) if count > 0]\n      \n      # Find the indices of the components needed for crafting\n      component_idx = index.get(component)\n      if component_idx is None:\n        raise ValueError(f\"Component '{component}' not found in cookbook.\")\n      \n      # Check if we have enough of the required component in our inventory\n      while env.state.inventory[component_idx] < 1:\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n          x, y = int(env.state.pos[0] + dx), int(env.state.pos[1] + dy)\n          if 0 <= x < env.world.grid.shape[0] and 0 <= y < env.world.grid.shape[1]:\n            cell_content = env.world.grid[x, y, :]\n            for entity in cell_content:\n              if entity == component_idx:\n                action = [dx, dy].index(max([abs(dx), abs(dy)])) + 2  # Move to the closest matching entity\n                env.step(action)\n                break\n        else:\n          raise ValueError(f\"Component '{component}' not found in the environment.\")\n      \n      action = 4  # USE action\n      env.step(action)\n  \n  def craft_components(env, components):\n    for component in components:\n      find_and_move_to_component(env, component)\n      while not env._is_done() and env.state.inventory[component] < 1:\n        action = 4  # USE action\n        env.step(action)\n  \n  # Retrieve the indices for the goal item and its components from the environment's cookbook\n  index = env.world.cookbook.index\n  goal_item_idx = index.get(item)\n  if goal_item_idx is None:\n    raise ValueError(f\"Item '{item}' not found in cookbook.\")\n  \n  # Check if the item has a recipe\n  components = env.world.cookbook.primitives_for(goal_item_idx)\n  if not components:\n    return []  # No recipe, so nothing to craft\n\n  # Craft each component recursively until all are obtained\n  craft_components(env, components)\n  \n  return []", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(recipe):\n    required_ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        required_ingredients.append(key)\n        counts.append(count)\n    return required_ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  required_ingredients, counts = get_required_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Try to pick up ingredients until we have enough for the craft\n  for i in range(len(required_ingredients)):\n    while inventory[required_ingredients[i]] < counts[i]:\n      actions += pickup_item(env, required_ingredients[i])\n    \n  # Craft the item\n  for i in range(len(required_ingredients)):\n    action = use_item(env, required_ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_ingredients(recipe):\n    required_ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        required_ingredients.append(key)\n        counts.append(count)\n    return required_ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  required_ingredients, counts = get_required_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Check and pickup ingredients that are missing in the inventory\n  for i in range(len(required_ingredients)):\n    while inventory[required_ingredients[i]] < counts[i]:\n      actions += pickup_item(env, required_ingredients[i])\n    \n  # Craft the item using available ingredients\n  for ingredient_index, count in zip(required_ingredients, counts):\n    for _ in range(count):\n      action = use_item(env, ingredient_index)\n      if action is not None:\n        actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      recipe = get_recipe(primitive)\n      while inventory[primitive] > 0 and any(inventory[key] > 0 for key in recipe.keys() if key != \"_key\"):\n        actions.append(4)  # USE action to use the primitive to craft the item\n  \n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[(env._current_state.pos)])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_state = env._current_state\n    if target_pos[0] > current_state.pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_state.pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_state.pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_state.pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(ingredient_index):\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        return [i]\n    raise ValueError(\"Ingredient not found in inventory.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  ingredients = [(ingredient_index, count) for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n  \n  actions = [action for ingredient in ingredients for action in get_ingredient_actions(ingredient[0])]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(env, item_pos):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['move'])\n          found = True\n          break\n      if found: break\n    if not found:\n      raise ValueError(\"Item not found in the grid.\")\n\n  recipe = get_recipe(item)\n  if not recipe:\n    return []  # If no recipe, do nothing\n  \n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  for primitive, count in recipe.items():\n    while inventory[primitive] > 0 and count > 0:\n      actions.append(4)  # USE action to use the primitive\n      inventory[primitive] -= 1\n      count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(recipe, actions):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  recipe = get_recipe(item)\n  actions = []\n  craft_items(recipe, actions)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(recipe, actions):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          item_index = env.world.grabbable_indices.index(required_item)\n          actions.append(item_index)\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            actions.append(item_index)\n            actions.append(4)  # Action for using the item to craft something\n  \n  recipe = get_recipe(item)\n  actions = []\n  craft_items(recipe, actions)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            # Find the best position to pick up and craft the item\n            for x in range(env.world.WIDTH):\n              for y in range(env.world.HEIGHT):\n                pos = (x, y)\n                state = env._current_state\n                if not state.grid[pos][required_item] and state.inventory[required_item] == 0:\n                  actions.append(env.world.grabbable_indices.index(required_item))\n                  actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Retrieve the recipe for this goal index\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Extract only the ingredient indices and their counts from the recipe\n  ingredients = [(ingredient_index, count) for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n\n  # Initialize an empty list to store actions corresponding to grabbing ingredients\n  actions = []\n\n  # For each ingredient required by the recipe, find its index in grabbable entities and add the action to actions list\n  for ingredient_index, count in ingredients:\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Append the action corresponding to the grabbable index of the ingredient\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(ingredient_index):\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        return [i]\n    raise ValueError(\"Ingredient not found in inventory.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    actions += get_ingredient_actions(ingredient_index)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(recipe, actions):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices and env._current_state.inventory[required_item] == 0:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  recipe = get_recipe(item)\n  actions = []\n  craft_items(recipe, actions)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while inventory[primitive] > 0 and env._current_state.next_to(primitive):\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(primitive))  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while inventory[primitive] >= count and env._current_state.next_to(primitive):\n        actions.append(4)  # USE action to use the primitive to craft the item\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n\n  actions = []\n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = {z: np.where(env._current_state.grid[:, :, z] == item) for z in range(env._current_state.grid.shape[-1]) if np.any(env._current_state.grid[:, :, z] == item)}\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = None\n      for z, pos in positions.items():\n        if (env._current_state.pos) == pos:\n          move_to(pos)\n          pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def find_action_for_ingredient(ingredient_index):\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        return i\n    raise ValueError(\"Ingredient not found in inventory.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  ingredients = [(ingredient_index, count) for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n  \n  actions = [find_action_for_ingredient(ingredient[0]) for ingredient in ingredients]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  def craft_with_inventory(env):\n    # Get the recipe for the desired item\n    goal_index = env.world.cookbook.index.get(item)\n    if goal_index is None:\n      raise ValueError(\"Item not found in cookbook\")\n    \n    ingredient_indices, ingredient_counts = find_required_ingredients(goal_index)\n    actions = pickup_ingredients(env, ingredient_indices, ingredient_counts)\n    actions += use_ingredients(env, ingredient_indices, ingredient_counts)\n    return actions\n  \n  def craft_with_pickup(env):\n    # Craft the item by trying to pick up all required ingredients first\n    actions = []\n    inventory = env._current_state.inventory\n    goal_index = env.world.cookbook.index.get(item)\n    if goal_index is None:\n      raise ValueError(\"Item not found in cookbook\")\n    \n    ingredient_indices, ingredient_counts = find_required_ingredients(goal_index)\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    \n    # Use the ingredients to craft the item\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # First try to craft the item using the inventory directly\n  actions = []\n  try:\n    actions = craft_with_inventory(env)\n  except ValueError:\n    pass  # If item not found in inventory, move on to pickup and craft\n  \n  if not actions:\n    # Try to pick up all required ingredients first\n    actions = craft_with_pickup(env)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the necessary variables and data structures\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Implement the crafting logic here\n  # This function should return a list of actions to craft the item\n  # You can use the environment's methods and attributes to assist with this process\n  \n  return []", "occurrence_count": 1}
{"function_body": "  # Find the index of the goal item in the environment's cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    # Check if the component is a primitive (not an environment entity)\n    if component < len(env.non_grabbable_indices):\n      # Find the index of the component in the environment's non-grabbable indices\n      component_index = list(env.non_grabbable_indices).index(component)\n      \n      # Add actions to pick up and use the component until the required count is reached\n      for _ in range(count):\n        if not env.next_to(component_index):\n          direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n          actions.append(direction)\n        actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the environment's cookbook index\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n\n  # Get the recipe for the goal item from the environment's world recipes\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    inventory_indices = [i for i in range(len(env.grabbable_indices)) if env.inventory[i] > 0]\n    \n    for i in inventory_indices:\n      actions.append(i)  # Use the action corresponding to the ingredient index\n      break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the desired item from the cookbook's index\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n\n  # Retrieve the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Check and pick up each ingredient that is needed\n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      actions += pickup_item(env, ingredients[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your improved algorithm goes here!\n  return []", "occurrence_count": 1}
{"function_body": "  # Find the recipe for the desired item\n  def find_recipe(item):\n    recipes = env.world.cookbook.recipes\n    if item in recipes:\n      return recipes[item]\n    raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n  \n  # Craft items recursively based on the recipe\n  def craft_recursive(recipe):\n    actions = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        actions.extend(craft_recursive(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Add the action to grab the item and then use it for crafting\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n    return actions\n  \n  recipe = find_recipe(item)\n  return craft_recursive(recipe)", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence to perform the desired crafting task\n  actions = []\n  \n  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    if component not in env.non_grabbable_indices:\n      continue  # Skip non-primitive components\n    \n    # Find the index of the component in the environment's non-grabbable indices\n    component_index = list(env.non_grabbable_indices).index(component)\n    \n    # Add actions to pick up and use the component until the required count is reached\n    for _ in range(count):\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _get_required_counts(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    return {k: v for k, v in recipe.items()} if recipe else {}\n  \n  def get_actions_for_item(env, required_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    grid = env._current_state.grid\n    \n    for primitive, count in required_counts.items():\n      while inventory[primitive] < count:\n        pickup_action = env._find_pickup_action(primitive)\n        if pickup_action is not None:\n          actions.append(pickup_action)  # Move to the item and pick it up if necessary\n      \n      for _ in range(count):\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n    \n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  required_counts = _get_required_counts(goal_index)\n  return get_actions_for_item(env, required_counts)", "occurrence_count": 1}
{"function_body": "  def _get_required_counts(goal_index):\n    recipe = env.world.cookbook.primitives_for(goal_index)\n    required_counts = {primitive: count for primitive, count in recipe.items()}\n    return required_counts\n  \n  def get_actions_for_item(required_counts):\n    actions = []\n    for primitive, count in required_counts.items():\n      while env._current_state.inventory[primitive] < count:\n        # Find the position of the item and move towards it if necessary\n        pos = env._current_state.pos\n        grid = env._current_state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              env._current_state.inventory[primitive] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n      while env._current_state.inventory[primitive] >= count:\n        actions.append(env.action_index['use'])  # USE action to use the primitive\n        env._current_state.inventory[primitive] -= 1\n    return actions\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  required_counts = _get_required_counts(goal_index)\n  return get_actions_for_item(required_counts)", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append((required_item, recipe[key]))\n    return required_items\n  \n  # Get all the items needed to craft the desired item along with their counts\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    item_index, count = required_item\n    while env._current_state.inventory[item_index] < count and count > 0:\n      if item_index not in env._non_grabbable_indices:\n        actions.append(env.world.grabbable_indices.index(item_index))\n        actions.append(4)  # Action for using the item to craft something\n        count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} not found in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          pickup_action = env._find_pickup_action(primitive)\n          if pickup_action is not None:\n            actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n            inventory[primitive] -= 1\n            count -= 1\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def _find_pickup_actions(inventory, indices):\n    \"\"\"Helper function to find pickup actions for given inventory and indices.\"\"\"\n    actions = []\n    for index in indices:\n      while inventory[index] > 0:\n        if env.world.non_grabbable_indices.contains(index):\n          # Move towards the item until it's within reach, then pick it up.\n          pos = env._current_state.pos\n          dx, dy = index - pos\n          if abs(dx) > 1 or abs(dy) > 1:\n            continue\n        actions.append(4)  # USE action to pick up from inventory\n    return actions\n\n  cookbook = env.world.cookbook\n  recipe = cookbook.primitives_for(item)\n\n  if not recipe:\n    return []  # If no recipe is found, return an empty list (it's already crafted).\n\n  actions = _find_pickup_actions(env._current_state.inventory, recipe.keys())\n\n  for _ in range(len(recipe)):\n    actions.append(4)  # USE action to use the primitive to craft the item\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      inventory = env._current_state.inventory\n      # Check inventory before taking action to avoid unnecessary actions\n      while inventory[required_item] > 0:\n        actions.append(env.world.grabbable_indices.index(required_item))\n        actions.append(4)  # Action for using the item to craft something\n        inventory = env._current_state.step(4).inventory  # Update inventory after use\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  actions = []\n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_pos:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[item_idx] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes[item]\n    required_items = []\n    \n    # Recursively find all the required items by traversing the recipe dictionary\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_items.append(value)\n    \n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n\n  # Initialize the actions list and pick up any required items that are not already in the inventory\n  actions = []\n  for req_item in required_items:\n    if env.world.cookbook.index[req_item] not in env._non_grabbable_indices:\n      actions.append(env.world.grabbable_indices.index(env.world.cookbook.index[req_item]))\n  \n  # Craft the item using the required items\n  for req_item in reversed(required_items):\n    if env.world.cookbook.index[req_item] not in env._non_grabbable_indices:\n      actions.append(env.world.grabbable_indices.index(env.world.cookbook.index[req_item]))\n      # Use the required item to craft the goal item\n      actions.append(4)  # Action for using an item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index for the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence with a no-op (do nothing)\n  actions = [4]  # 4 corresponds to \"USE\" in some environments\n\n  # Check if the goal is achievable directly from the environment's cookbook\n  recipe = env.world.cookbook.recipes.get(item, {})\n  ingredients = {k: v for k, v in recipe.items() if isinstance(v, int)}\n\n  # If there are no direct ingredients needed, return the initial action\n  if not ingredients:\n    return actions\n\n  # Find and add necessary actions to craft the item\n  while any(ingredient < 0 for ingredient in ingredients.values()):\n    for ingredient_index, count in ingredients.items():\n      if count > 0 and env.world.cookbook.primitives_for(ingredient_index).get(item, None) is not None:\n        actions.append(4)  # USE to craft the item if possible\n        break\n      elif count < 0:\n        # If we have more of an ingredient than needed, we don't need to take any action for this ingredient now\n        ingredients[ingredient_index] = max(0, count + recipe.get(ingredient_index, 0))\n    else:\n      # If no direct craftable item is found, try to find a primitive that can be used directly\n      for ingredient_index in ingredients:\n        if env.world.cookbook.primitives_for(ingredient_index).get(item, None) is not None:\n          actions.append(4)  # USE to craft the item if possible\n          break\n\n    # Update the required counts based on what was actually crafted or used\n    for ingredient_index in ingredients:\n      if env.world.cookbook.primitives_for(ingredient_index).get(item, None) is not None:\n        ingredients[ingredient_index] = max(0, ingredients[ingredient_index] - 1)\n      else:\n        # If the ingredient is exactly what we need and there's only one left in inventory, use it\n        if env.world.non_grabbable_indices != set() and ingredient_index not in env.world.non_grabbable_indices:\n          actions.append(4)  # USE to craft the item if possible\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: abs(x[0][0]-env._current_state.pos[0]) + abs(x[0][1]-env._current_state.pos[1])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n  \n  actions = []\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  required_primitives = list(recipe.keys())\n\n  # Sort the primitives based on their availability and required amount for crafting\n  inventory = env._current_state.inventory\n  sorted_required_primitives = sorted(required_primitives, key=lambda x: (inventory[x] / recipe[x], -inventory[x]))\n\n  # Craft each primitive in the order of their availability and requirement\n  for primitive in sorted_required_primitives:\n    while not env._current_state.satisfies(None, primitive):\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      else:\n        break  # If we can't get the required item, stop trying\n\n    while env._current_state.inventory[primitive] >= recipe[primitive]:\n      actions.append(4)  # USE action to use the primitive\n      env._current_state.inventory[primitive] -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_positions(grid):\n    positions = {}\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        positions[(pos[0][0], pos[1][0])] = z\n    return positions\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = get_item_positions(env._current_state.grid)\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(x[0]) - np.array(env._current_state.pos))):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[(env._current_state.pos)])\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredients = {k: v for k, v in recipe.items() if k != \"_key\"}\n    return ingredients\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n\n  for ingredient_index, count in ingredients.items():\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n    \n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  def craft_recursive(env, goal_index):\n    ingredients, counts = find_required_ingredients(goal_index)\n    if not ingredients:\n      return []\n    \n    # Pickup all required ingredients\n    pickup_actions = pickup_ingredients(env, ingredients, counts)\n    for action in pickup_actions:\n      env.step(action, num_steps=1)  # Perform the action and update the state\n    \n    # Craft each ingredient one by one (recursive crafting)\n    use_actions = use_ingredients(env, ingredients, counts)\n    for action in use_actions:\n      env.step(action, num_steps=1)  # Perform the action and update the state\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  craft_recursive(env, goal_index)\n  return []", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      # Check inventory before taking action to avoid unnecessary actions\n      inventory = env._current_state.inventory\n      if inventory[required_item] == 0:\n        # Find the index of the item in the grabbable indices list\n        required_item_index = env.world.grabbable_indices.index(required_item)\n        actions.append(required_item_index)\n      else:\n        # If the item is already in inventory, use it to craft something\n        actions.append(env.world.grabbable_indices.index(required_item))\n        actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes.get(item)\n  if not recipe:\n    raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n  \n  actions = []\n  inventory = env._current_state.inventory\n\n  # Iterate over the required items and their counts in the recipe\n  for key, value in recipe.items():\n    if isinstance(value, dict) and \"_key\" not in key:\n      count = value\n      required_item = env.world.cookbook.index[key]\n      \n      # If we already have the required item, no need to take any action for it\n      if inventory[required_item] > 0:\n        continue\n      \n      # Find where the required item is in the grid and move towards it\n      target_pos = None\n      for y in range(env._current_state.grid.shape[1]):\n        for x in range(env._current_state.grid.shape[0]):\n          if env._current_state.grid[x, y, required_item] > 0:\n            target_pos = (x, y)\n            break\n        if target_pos is not None:\n          break\n      \n      # If the item is not in the grid, it's unreachable and we skip this recipe step\n      if target_pos is None:\n        continue\n      \n      # Move towards the required item\n      start_pos = env._current_state.pos\n      while start_pos != target_pos:\n        if start_pos[0] < target_pos[0]:  # Move right\n          actions.append(0)  # Action for moving down\n          start_pos = (start_pos[0] + 1, start_pos[1])\n        elif start_pos[0] > target_pos[0]:  # Move left\n          actions.append(1)  # Action for moving up\n          start_pos = (start_pos[0] - 1, start_pos[1])\n        elif start_pos[1] < target_pos[1]:  # Move down\n          actions.append(2)  # Action for moving left\n          start_pos = (start_pos[0], start_pos[1] + 1)\n        elif start_pos[1] > target_pos[1]:  # Move up\n          actions.append(3)  # Action for moving right\n          start_pos = (start_pos[0], start_pos[1] - 1)\n      \n      # Use the item to craft if possible\n      if env._current_state.inventory[required_item] > 0:\n        actions.append(4)  # Action for using the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_component_actions(component_index):\n    if not env.next_to(component_index):\n      direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n      return [direction, 4]  # Use action to pick up the component\n    else:\n      return [4]  # Already next to the component, use it directly\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for component, count in recipe.items():\n    if component == \"_key\":\n      continue\n    \n    component_index = list(env.non_grabbable_indices).index(component)\n    actions.extend(get_component_actions(component_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def find_item(grid, pos, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    return None\n  \n  actions = []\n  recipe = get_recipe(item)\n  missing_items = {k: v for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  while missing_items:\n    item_pos = find_item(env._current_state.grid, env._current_state.pos, next(iter(missing_items)))\n    if not item_pos:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Move to the position and pick up the item\n    while env._current_state.pos != item_pos[:2]:\n      move = np.array(item_pos[:2]) - np.array(env._current_state.pos)\n      if move[0] > 0: actions.append(0)  # DOWN\n      elif move[0] < 0: actions.append(1)  # UP\n      elif move[1] > 0: actions.append(3)  # RIGHT\n      else: actions.append(2)  # LEFT\n    \n    # Pick up the item\n    if env._current_state.pos == item_pos[:2]:\n      actions.append(4)  # USE to pick up\n  \n    # Craft the desired item\n    craft_items(actions, env._current_state.inventory, recipe)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def move_to_item(pos, grid, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    raise ValueError(\"Item not found in the grid.\")\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  pos = env._current_state.pos\n  grid = env._current_state.grid\n\n  for primitive in recipe:\n    item_pos = move_to_item(pos, grid, primitive)\n    actions.append(0) if item_pos[0] > pos[0] else (actions.append(1) if item_pos[0] < pos[0] else None)\n    actions.append(2) if item_pos[1] > pos[1] else (actions.append(3) if item_pos[1] < pos[1] else None)\n    pos = item_pos\n  \n  craft_items(actions, inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  actions = []\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Create a function to find the index of an item in grabbable indices\n  def get_grabbable_index(item_index):\n    for i, idx in enumerate(env.grabbable_indices):\n      if idx == item_index:\n        return i\n    raise ValueError(\"Item not found in grabbable indices.\")\n  \n  # Iterate through the recipe and add actions to craft the ingredients\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    while env.inventory[ingredient_index] > 0:\n      action_index = get_grabbable_index(ingredient_index)\n      actions.append(action_index)\n      break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_items.append(env.world.cookbook.index[value])\n    return required_items\n  \n  def craft_items(item, actions):\n    if item in env._non_grabbable_indices:\n      return []\n    \n    recipe = env.world.cookbook.recipes.get(item)\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices and env._current_state.inventory[required_item] == 0:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n  \n  required_items = get_required_items(item)\n  actions = []\n  for item in required_items:\n    if item not in env._non_grabbable_indices and env._current_state.inventory[item] == 0:\n      actions.append(env.world.grabbable_indices.index(item))\n      actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(recipe, actions):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check if the item is grabbable and not already in inventory\n        if required_item not in env._non_grabbable_indices:\n          if required_item not in env._current_state.inventory:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  recipe = get_recipe(item)\n  actions = []\n  craft_items(recipe, actions)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} not found in cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] < count:\n        actions.append(0 if env._current_state.pos == (env.world.workshop_indices[0], 0) else 2) # Move to the workshop if not already there\n        pickup_action = -1\n        for action in [0, 1, 2, 3]:  # Check all possible actions to find a pickup action\n          env._current_state.step(action)\n          if env._current_state.next_to(primitive):\n            pickup_action = action\n            break\n        if pickup_action == -1:\n          return actions  # If no pickup action found, stop trying to craft the item\n        actions.append(pickup_action)\n        inventory[primitive] += 1\n      actions.append(4)  # USE action to use the primitive\n      inventory[primitive] -= count\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  craft_items(actions, env._current_state.inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_primitives(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    return {k: v for k, v in recipe.items() if v > 0}\n\n  def craft_primitive(action_list, inventory, primitive, required_count):\n    while inventory[primitive] < required_count:\n      pickup_action = env._find_pickup_action(primitive)\n      if pickup_action is not None:\n        action_list.append(pickup_action)  # Move to the primitive and pick it up if necessary\n      else:\n        break  # If we can't get the required item, stop trying\n    return action_list\n\n  def use_primitives(actions, inventory, recipe):\n    for primitive in recipe.keys():\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item {} not found in cookbook.\".format(item))\n\n  required_primitives = get_required_primitives(goal_index)\n  actions = []\n\n  for primitive, count in required_primitives.items():\n    actions = craft_primitive(actions, env._current_state.inventory, primitive, count)\n    actions = use_primitives(actions, env._current_state.inventory, {primitive: count})\n\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  cookbook = env.world.cookbook\n  idx = cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = get_recipe(idx)\n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  # Get the current inventory of items needed for crafting\n  inventory = env._current_state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      if count > 0:\n        # Check the position of the item and move towards it if necessary\n        pos = env._current_state.pos\n        grid = env._current_state.grid\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            cell_item = grid[pos[0]+dx, pos[1]+dy, :]\n            if np.any(cell_item == item_idx):\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # If we have enough items, craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n    for item_idx in required_items.keys():\n      missing_items[item_idx] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, stop searching for this ingredient\n        break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices, ingredient_counts = find_ingredients(recipe)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  for i in range(len(ingredient_indices)):\n    while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n      actions += pickup_item(env, ingredient_indices[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  \n  # Get the recipe for the desired item\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  # Check if there are any recipes that can produce this item\n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  # Get the indices of all required ingredients for this recipe\n  ingredient_indices, ingredient_counts = find_ingredients(recipe)\n  \n  # Check the inventory to see if we have all required ingredients\n  inventory = env._current_state.inventory\n  while not all(inventory[i] >= c for i, c in zip(ingredient_indices, ingredient_counts)):\n    # If we don't have enough of an ingredient, try to pick up more\n    missing_count = min(c - inventory[i] for i, c in zip(ingredient_indices, ingredient_counts))\n    actions += [pickup_item(env, i) for i in ingredient_indices if inventory[i] < c][:missing_count]\n  \n  # Now craft the item using the recipe\n  for i in range(len(ingredient_indices)):\n    action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n    if action is not None:\n      actions.append(action)\n    \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredients = []\n    for ingredient_index, count in recipe.items():\n      if ingredient_index == \"_key\":\n        continue\n      ingredients.append((ingredient_index, count))\n    return ingredients\n\n  def find_and_use_ingredients(ingredients):\n    actions = []\n    for ingredient_index, _ in ingredients:\n      found = False\n      while not found:\n        for i in range(len(env.grabbable_indices)):\n          if env.inventory[ingredient_index] > 0:\n            actions.append(i)  # Use the action corresponding to the ingredient index\n            break\n        else:\n          # If no more ingredients can be used, break out of the loop\n          found = True\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  ingredients = get_ingredients(goal_index)\n  actions = find_and_use_ingredients(ingredients)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check inventory before taking action to avoid unnecessary actions\n        inventory = env._current_state.inventory\n        if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          # Check if the action is valid before adding it to the list\n          state = env._current_state\n          pos = state.pos\n          dir = state.dir\n          grid = state.grid\n          if not state.next_to(required_item):\n            actions.pop()  # Remove the grab action if next to is false\n            continue\n          actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check inventory before taking action to avoid unnecessary actions\n        inventory = env._current_state.inventory\n        if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n        elif inventory[required_item] > 0 and required_item not in env._non_grabbable_indices:\n          if np.any([env._current_state.grid[x, y, required_item] == 1 for x in range(env._WIDTH) for y in range(env._HEIGHT)]):\n            actions.append(4)  # Action for using the item to craft something\n          else:\n            actions.append(env.world.grabbable_indices.index(required_item))\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  actions = []\n  \n  for component, count in recipe.items():\n    if component < len(env.non_grabbable_indices):\n      component_index = list(env.non_grabbable_indices).index(component)\n      \n      # If not next to the component, move closer\n      while not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      \n      # Use action to pick up the component\n      actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Implement the crafting logic here\n  # This function should return a list of actions to craft the item\n  # You can use the environment's methods and attributes to assist with this process\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n  \n  for component, count in recipe.items():\n    if component < len(env.non_grabbable_indices):\n      component_index = list(env.non_grabbable_indices).index(component)\n      for _ in range(count):\n        if not env.next_to(component_index):\n          direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n          actions.append(direction)\n        actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(env.action_index['use'])  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def find_and_move_to_item(actions, pos, grid, item_type):\n    for x in range(max(0, pos[0]-1), min(env.world.width, pos[0]+2)):\n      for y in range(max(0, pos[1]-1), min(env.world.height, pos[1]+2)):\n        if grid[x, y, item_type] > 0:\n          actions.append(env.action_index['move'])  # DOWN action to move down\n          actions.append(env.action_index['right'])  # RIGHT action to move right (or adjust as needed for your specific environment setup)\n          return True\n    raise ValueError(\"Item not found in the grid.\")\n\n  recipe = get_recipe(item)\n  if not recipe:\n    return []  # If no recipe, do nothing\n  \n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  for primitive, count in recipe.items():\n    while inventory[primitive] < count:\n      found = find_and_move_to_item(actions, env._current_state.pos, env._current_state.grid, primitive)\n      if not found:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, raise an error indicating that the item cannot be crafted\n        raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  actions = []\n  ingredients = [(ingredient_index, count) for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n\n  # Check each ingredient and find the corresponding action\n  for ingredient_index, _ in ingredients:\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(ingredient_index):\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        return [i]\n    raise ValueError(\"Ingredient not found in inventory.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    actions.extend(get_ingredient_actions(ingredient_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices and env._current_state.inventory[required_item] > 0:\n      # Check inventory before taking action to avoid unnecessary actions\n      while env._current_state.inventory[required_item] > 0:\n        if required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          actions.append(4)  # Action for using the item to craft something\n          env._current_state = env._current_state.step(4)  # Update state after use\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      inventory = env._current_state.inventory\n      # Check inventory before taking action to avoid unnecessary actions\n      while inventory[required_item] > 0 and len(actions) % 2 == 0:  # Ensure even number of actions for grabbing\n        actions.append(env.world.grabbable_indices.index(required_item))\n        actions.append(4)  # Action for using the item to craft something\n        inventory = env._current_state.step(4).inventory  # Update inventory after use\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and env.grid[env.pos].any():\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    while env.inventory[ingredient_index] > 0:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, break out of the loop\n        found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(ingredient_index):\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        return [i]\n    raise ValueError(\"Ingredient not found in inventory.\")\n\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    actions += get_ingredient_actions(ingredient_index) * count\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_item_indices(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_item_indices(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(env.world.grabbable_indices.index(required_item))\n    return required_items\n  \n  # Get the list of indices for items needed to craft the desired item\n  required_item_indices = get_required_item_indices(item)\n  \n  actions = []\n  inventory = env._current_state.inventory\n  grid = env._current_state.grid\n  pos = env._current_state.pos\n  \n  for index in required_item_indices:\n    while inventory[index] == 0 and np.any(np.array([env.world.grabbable_indices.index(x) for x in get_required_item_indices(index)])):\n      # Find the closest grabbable item to craft the required item\n      distances = []\n      for i in env.world.grabbable_indices:\n        if inventory[i] > 0 or np.any([env.world.grabbable_indices.index(x) for x in get_required_item_indices(i)]):\n          continue\n        dist = np.sqrt((pos[0]-i[0])**2 + (pos[1]-i[1])**2)\n        distances.append((dist, i))\n      if not distances:\n        break  # If no more grabbable items are available, stop the loop\n      closest_index = min(distances)[1]\n      actions.append(closest_index)\n      pos = closest_index\n    \n    actions.append(index)\n    if inventory[index] == 0:\n      # Use the item to craft something\n      actions.append(env.world.grabbable_indices.index(index))\n    actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_item_indices(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_item_indices(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(env.world.grabbable_indices.index(required_item))\n    return required_items\n  \n  # Get the list of indices for items needed to craft the desired item\n  required_item_indices = get_required_item_indices(item)\n  \n  actions = []\n  inventory = env._current_state.inventory\n  grid = env._current_state.grid\n  \n  # Check if we have enough of each required item in the inventory or on the grid\n  for index in required_item_indices:\n    count = inventory[index]\n    while count < 1 and not np.any(grid[:, :, index] > 0):\n      actions.append(env.world.grabbable_indices.index(index))\n      count += 1\n    actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  # Check and pickup the necessary items first\n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      action = pickup_item(env, ingredients[i])\n      if action is not None:\n        actions.append(action)\n        env._current_state = env.step(action)[1]  # Update the state after pickup\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n  \n  # Use the ingredients to craft the item\n  for i in range(len(ingredients)):\n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_item(grid, pos, item_idx):\n    # Implement a function to find the position of the item in the grid\n    pass\n  \n  def move_to_and_pickup(env, pos):\n    # Implement a function to move to the position and pickup the item if possible\n    pass\n\n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  recipe = env.world.cookbook.primitives_for(idx)\n  if not recipe:\n    return []\n\n  actions = []\n  inventory = env._current_state.inventory\n  missing_items = {k: v - inventory[k] for k, v in recipe.items() if v > inventory[k]}\n\n  while any(missing_items.values()):\n    # Find the position of each missing item and move towards it if necessary\n    grid = env._current_state.grid\n    pos = env._current_state.pos\n    for item_idx, count in missing_items.items():\n      while count > 0:\n        found = False\n        # Find the position of the item and move towards it if necessary\n        pos = find_item(grid, pos, item_idx)\n        if not pos:\n          raise ValueError(\"Item {} not found in the grid.\".format(env.world.cookbook.index.get(item_idx)))\n        \n        # Move to the position and pick up the item if possible\n        actions.append(move_to_and_pickup(env, pos))\n        count -= 1\n    \n    # Craft the desired item\n    actions.append(4)  # USE action for crafting\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  inventory = env._current_state.inventory\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices and inventory[required_item] <= 0:\n      # Find the closest grabbable item to use for crafting\n      distances = [(idx, np.linalg.norm(np.array(env._current_state.pos) - np.array([x, y]))) \n                   for idx, (x, y) in enumerate(env.grabbable_indices.contents) if env.grid[x, y, required_item] > 0]\n      if distances:\n        closest_idx = min(distances, key=lambda x: x[1])[0]\n        actions.append(closest_idx)\n        actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    while count > 0:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          count -= 1\n          found = True\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n    \n    while count > 0:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          count -= 1\n          found = True\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_indices(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    return [ingredient_index for ingredient_index in recipe if ingredient_index != \"_key\"]\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  ingredient_indices = get_ingredient_indices(goal_index)\n  \n  actions = []\n  for ingredient_index in ingredient_indices:\n    action_index = env.grabbable_indices.index(ingredient_index)\n    if env.inventory[ingredient_index] > 0:\n      actions.append(action_index)\n    else:\n      # If the inventory does not contain the ingredient, try to find it in the grid\n      for pos in np.ndindex(env.grid.shape[:2]):\n        if env.grid[pos][ingredient_index] > 0:\n          actions.append(action_index)\n          break\n  \n  return actions", "occurrence_count": 1}
{"function_body": "# Add your custom crafting logic here.\n  # Example: Craft the item by finding its recipe and necessary components in the environment's inventory.\n  \n  return []", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  actions = []\n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) in env.grabbable_indices:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[k] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  actions = []\n  while any(missing_items.values()):\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) in env.grabbable_indices and grid[nx+dx, ny+dy, :] != 0:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[item_idx] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while np.any(inventory[primitive] > 0):\n        actions.append(4)  # USE action to use the primitive\n        index = env._find_pickup_action(primitive)\n        if index is not None:\n          actions.append(index)  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while count > 0 and np.any(inventory[primitive] > 0):\n        actions.append(4)  # USE action to use the primitive to craft the item\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def find_and_use_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      while np.any(inventory[primitive] > 0):\n        actions.append(4)  # USE action to use the primitive to craft the item\n        inventory[primitive] -= 1\n  \n  def find_and_use_all_items(actions, inventory):\n    for i in range(len(inventory)):\n      while inventory[i] > 0:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(i))  # Find the actual pickup action based on index\n  \n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  find_and_use_craft_items(actions, env._current_state.inventory, required_primitives)\n  find_and_use_all_items(actions, env._current_state.inventory)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_actions_for_ingredients(ingredients):\n    actions = []\n    for ingredient_index in ingredients:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)\n          found = True\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  ingredients = [ingredient_index for ingredient_index, count in recipe.items() if ingredient_index != \"_key\"]\n  \n  actions = find_actions_for_ingredients(ingredients)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_actions_for_ingredients(ingredient_indices):\n    actions = []\n    for ingredient_index in ingredient_indices:\n      found = False\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)\n          found = True\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in inventory.\")\n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  ingredients = [ingredient_index for ingredient_index in recipe.keys() if ingredient_index != \"_key\"]\n  \n  actions = find_actions_for_ingredients(ingredients)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Implement the logic for crafting the given item using the environment and its world configuration.\n  # You can access the environment's state via env.scenario._current_state.features() if needed.\n  \n  return []", "occurrence_count": 1}
{"function_body": "  def get_component_indices():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.primitives_for(goal)\n    component_indices = []\n    for component, count in recipe.items():\n      if component < len(env.non_grabbable_indices):\n        component_index = list(env.non_grabbable_indices).index(component)\n        for _ in range(count):\n          if not env.next_to(component_index):\n            direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n            component_indices.append((component_index, direction))\n    return component_indices\n  \n  def get_actions():\n    actions = []\n    for component_index, direction in get_component_indices():\n      if not env.next_to(component_index):\n        while not env.next_to(component_index):\n          direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n          actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n    return actions\n  \n  return get_actions()", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if ingredient_index != \"_key\"]\n    \n    actions = []\n    for ingredient_index in ingredient_indices:\n      action_index = env.grabbable_indices.index(ingredient_index)\n      actions.append(action_index)\n    \n    return actions\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  ingredient_actions = get_ingredient_actions(goal_index)\n  return ingredient_actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_actions(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredient_indices = [ingredient_index for ingredient_index in recipe if ingredient_index != \"_key\"]\n    return [env.grabbable_indices.index(i) for i in ingredient_indices]\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n  \n  actions = get_ingredient_actions(goal_index)\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          while inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n            inventory = env._current_state.inventory\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return []\n    \n    ingredient_indices = [key for key in recipe.keys() if isinstance(key, int)]\n    counts = [recipe[idx] for idx in ingredient_indices]\n    return list(zip(ingredient_indices, counts))\n  \n  def pickup_required_items(env, ingredients):\n    actions = []\n    inventory = env._current_state.inventory\n    for index, count in ingredients:\n      while inventory[index] < count:\n        actions += pickup_item(env, index)\n    return actions\n  \n  def use_ingredients(env, ingredients):\n    actions = []\n    for index, count in ingredients:\n      action = use_item(env, index, count)\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  # Get the goal index from the item name\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = get_recipe(goal_index)\n  actions = pickup_required_items(env, recipe)\n  actions += use_ingredients(env, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) in env.grabbable_indices:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not missing_items:\n    return []\n  \n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) in env.grabbable_indices:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid):\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        return (pos[0][0], pos[1][0]), z\n    return None, -1\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  for ingredient_index, count in ingredients.items():\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos, _ = get_item_position(env._current_state.grid)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if env._current_state.inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n      # Find the index of the grabbable item\n      idx = env.world.grabbable_indices.index(required_item)\n      actions.append(idx)\n      actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          env.inventory[ingredient_index] -= 1  # Decrease the count of the ingredient in the inventory\n          found = True\n          break\n        if i == len(env.grabbable_indices) - 1:\n          actions.append(i)  # If not found, use the action to try again later\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Check if the ingredient is already in the inventory\n    if env.inventory[ingredient_index] > 0:\n      actions.append(env.grabbable_indices.index(ingredient_index))  # Use the action corresponding to the ingredient index\n    else:\n      # Find the position of the ingredient in the grid and pick it up\n      found = False\n      for y in range(env.grid.shape[1]):\n        for x in range(env.grid.shape[0]):\n          if env.grid[x, y, ingredient_index] > 0:\n            actions.append(env.grabbable_indices.index(ingredient_index))  # Use the action corresponding to the ingredient index\n            found = True\n            break\n        if found:\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in grid.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_component_actions(component_index):\n    if not env.next_to(component_index):\n      direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n      return [direction, 4]  # Use action to pick up the component\n    else:\n      return [4]  # Already next to the component, use it directly\n\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n\n  for component, count in recipe.items():\n    if component == \"_key\":\n      continue\n    \n    component_index = list(env.non_grabbable_indices).index(component)\n    actions.extend([get_component_actions(component_index)])\n  \n  return [action for sublist in actions for action in sublist]", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredients = {k: v for k, v in recipe.items() if k != \"_key\"}\n    return ingredients\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n\n  for ingredient_index, count in ingredients.items():\n    while env.inventory[ingredient_index] <= 0:\n      # Find the next grabbable item that matches the ingredient and add its action to actions\n      for i in range(len(env.grabbable_indices)):\n        if env.grid[env.grabbable_indices[i]] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n    \n    # After finding a matching grabbable item, decrease its count in inventory by one\n    env.inventory[ingredient_index] -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    ingredients = {k: v for k, v in recipe.items() if k != \"_key\"}\n    return ingredients\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  actions = []\n  ingredients = get_ingredients(goal_index)\n\n  for ingredient_index, count in ingredients.items():\n    while env.inventory[ingredient_index] <= 0:\n      # If the inventory does not have enough of the ingredient, find a grabbable item to use\n      for i in range(len(env.grabbable_indices)):\n        if env.grid[tuple(env.pos)][env.grabbable_indices[i]] > 0:\n          actions.append(i)  # Use the action corresponding to the grabbable index\n          break\n      else:\n        raise ValueError(\"No more ingredients can be used and no more grabbable items found.\")\n    \n    actions.append(ingredient_index)  # Use the action corresponding to the ingredient index\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Implement the improved crafting logic here.\n  # You can use the methods provided in the CraftLab class and other utility functions if needed.\n  return []", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item_index = env.world.cookbook.index[value]\n        if required_item_index not in env._non_grabbable_indices:\n          # Find the closest grabbable item to pick up and use it for crafting\n          pos = env._current_state.pos\n          dists = [(idx, ((x - pos[0]) ** 2 + (y - pos[1]) ** 2) ** 0.5) for idx, x, y in zip(env.world.grabbable_indices, *np.where(env._current_state.grid == required_item_index))]\n          dists = sorted(dists, key=lambda x: x[1])\n          if dists:\n            closest_idx = dists[0][0]\n            actions.append(closest_idx)\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n\n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n  \n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Find the closest grabbable item to pick up and use it for crafting\n          pos = env._current_state.pos\n          dists = [(idx, ((x - pos[0]) ** 2 + (y - pos[1]) ** 2) ** 0.5) for idx, x, y in zip(env.world.grabbable_indices, *np.where(env._current_state.grid == required_item))]\n          dists = sorted(dists, key=lambda x: x[1])\n          if dists:\n            closest_idx = dists[0][0]\n            actions.append(closest_idx)\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            # Find the position of the item in the grid\n            pos = None\n            for i in range(env.grid.shape[0]):\n              for j in range(env.grid.shape[1]):\n                if env.grid[i, j, required_item] != 0:\n                  pos = (i, j)\n                  break\n              if pos is not None:\n                break\n            # Move to the item position and pick it up\n            if pos is not None:\n              x, y = pos\n              if x < env._current_state.pos[0]:\n                actions.append(1)  # UP\n              elif x > env._current_state.pos[0]:\n                actions.append(0)  # DOWN\n              elif y < env._current_state.pos[1]:\n                actions.append(2)  # LEFT\n              elif y > env._current_state.pos[1]:\n                actions.append(3)  # RIGHT\n            actions.append(4)  # USE to pick up the item\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          inventory = env._current_state.inventory\n          if inventory[required_item] == 0:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  # Start crafting from the top-level goal item down to its components\n  craft_items(recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  while any(missing_items.values()):\n    for item_idx, count in required_items.items():\n      if count > 0 and inventory[item_idx] < count:\n        # Find the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  required_items = env.world.cookbook.primitives_for(idx)\n  \n  # If no recipe, return an empty list as it cannot be crafted\n  if not required_items:\n    return []\n  \n  inventory = env.state.inventory\n  missing_items = {}\n  for item_idx, count in required_items.items():\n    if inventory[item_idx] < count:\n      raise ValueError(f\"Not enough {item_idx} to craft the desired item.\")\n    else:\n      missing_items[item_idx] = count - inventory[item_idx]\n  \n  # If we have all items, return an empty list as it is already crafted\n  if not missing_items:\n    return []\n  \n  actions = []\n  \n  while any(missing_items.values()):\n    for item_idx, count in required_items.items():\n      if count > 0:\n        # Find the position of the item and move towards it if necessary\n        pos = env.state.pos\n        grid = env.state.grid\n        nx, ny = pos\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            if (nx+dx, ny+dy) == item_pos:\n              # Move to the position and pick up the item\n              actions.append(env.action_index['pickup'])\n              missing_items[item_idx] -= 1\n              found = True\n              break\n          if found: break\n        else:\n          raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(item, actions):\n    recipe = get_recipe(item)\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        # Check inventory before taking action to avoid unnecessary actions\n        inventory = env._current_state.inventory\n        if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n          actions.append(env.world.grabbable_indices.index(required_item))\n          # Use the item to craft something\n          actions.append(4)\n  \n  actions = []\n  craft_items(item, actions)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Helper function to find the closest item of a certain type\n  def get_closest_item(pos, grid, kind):\n    indices = np.argwhere(grid == kind)\n    if len(indices) == 0:\n      return None\n    distances = np.sqrt((indices[:, 0] - pos[0])**2 + (indices[:, 1] - pos[1])**2)\n    closest_index = indices[np.argmin(distances)]\n    return closest_index\n  \n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    if component == \"_key\":  # Skip the key ingredient as it's not a physical item\n      continue\n    \n    # Find the index of the component in the environment's non-grabbable indices\n    component_index = list(env.non_grabbable_indices).index(component)\n    \n    # Add actions to pick up and use the component until the required count is reached\n    for _ in range(count):\n      closest = get_closest_item(env.pos, env.grid, component_index)\n      if closest is None:\n        raise ValueError(f\"Component {component} not found in grid.\")\n      \n      # Move towards the closest item\n      move_actions = []\n      while env.pos != tuple(closest):\n        diff = np.array(env.pos) - np.array(closest)\n        if diff[0] > 0:\n          move_actions.append(1)  # Move up\n        elif diff[0] < 0:\n          move_actions.append(3)  # Move down\n        elif diff[1] > 0:\n          move_actions.append(2)  # Move left\n        elif diff[1] < 0:\n          move_actions.append(0)  # Move right\n      \n      actions.extend(move_actions)\n      \n      # Use the item to pick up the component if it's not already in the inventory\n      if env.inventory[component_index] == 0:\n        actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Retrieve the recipe for the desired item\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  # Get the index and required primitives to craft the item\n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_components():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.primitives_for(goal)\n    components = []\n    for component, count in recipe.items():\n      if component < len(env.non_grabbable_indices):\n        comp_index = list(env.non_grabbable_indices).index(component)\n        for _ in range(count):\n          if not env.next_to(comp_index):\n            components.append((comp_index, env._get_closest_direction(env.pos, env.grid[env.pos] == comp_index)))\n    return components\n  \n  def make_actions():\n    actions = []\n    for component_index, direction in find_components():\n      if not env.next_to(component_index):\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n    return actions\n  \n  return make_actions()", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the environment's cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Get the recipe for crafting the desired item\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Iterate over each component and its count in the recipe\n  for component, count in recipe.items():\n    if component == \"_key\":  # Skip the key ingredient as it's not a physical item\n      continue\n    \n    # Find the index of the component in the environment's non-grabbable indices\n    component_index = list(env.non_grabbable_indices).index(component)\n    \n    # Add actions to pick up and use the component until the required count is reached\n    for _ in range(count):\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired item in the environment's cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Sort the recipe by count (descending) to prioritize crafting items with fewer prerequisites\n  sorted_recipe = dict(sorted(recipe.items(), key=lambda x: len(env.world.cookbook.primitives_for(x[0]).keys())))\n  \n  for component, _ in sorted_recipe.items():\n    if component == \"_key\":  # Skip the key ingredient as it's not a physical item\n      continue\n    \n    # Find the index of the component in the environment's non-grabbable indices\n    component_index = list(env.non_grabbable_indices).index(component)\n    \n    # Add actions to pick up and use the component until the required count is reached\n    while env.inventory[component] < recipe[component]:\n      if not env.next_to(component_index):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n        actions.append(direction)\n      actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize the action sequence with a placeholder for the goal item (item to be crafted).\n  actions = [4] if env.world.cookbook.index.get(item) is not None else []\n  \n  # If the goal item exists in the cookbook, proceed with crafting it.\n  if actions:\n    # Get the recipe for the item from the cookbook.\n    recipe = env.world.cookbook.primitives_for(env.world.cookbook.index[item])\n    \n    # Find all ingredients required by the recipe.\n    ingredients = []\n    for ingredient, count in recipe.items():\n      if isinstance(ingredient, int):  # Ensure it's an integer index (not a key).\n        ingredients.extend([env.world.cookbook.index.get(k) for k in env.world.cookbook.recipes[ingredient].keys()])\n    \n    # Filter out non-existent ingredient indices and duplicates.\n    ingredients = list(set(filter(lambda x: x is not None, ingredients)))\n    \n    # For each required ingredient, find its recipe (if any) and add the actions to pick it up and use it in crafting.\n    for ingredient_index in ingredients:\n      if ingredient_index is not None:\n        ingredient_recipe = env.world.cookbook.primitives_for(ingredient_index)\n        while ingredient_recipe:  # While there are more recipes to follow (nested ingredients).\n          next_ingredient, _ = list(ingredient_recipe.items())[0]  # Get the first ingredient in the recipe.\n          if isinstance(next_ingredient, int):  # Ensure it's an integer index (not a key).\n            action = env.world.cookbook.index.get(next_ingredient)\n            if action is not None:\n              actions.append(action)  # Add the action to pick up the ingredient.\n              ingredient_recipe = env.world.cookbook.primitives_for(next_ingredient)  # Update the recipe for the next step.\n          else:\n            break  # If not an integer, stop following this recipe chain.\n    \n    # Reverse the list to reflect the correct order of actions (from initial to final).\n    actions = actions[::-1]\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n  \n  def move_to_item(pos, grid, target):\n    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]\n    for dx, dy in directions:\n      if grid[pos[0]+dx, pos[1]+dy] == target:\n        return (pos[0]+dx, pos[1]+dy)\n    raise ValueError(\"Item not found in the grid.\")\n  \n  def find_and_move(actions, pos, grid, target):\n    while True:\n      pos = move_to_item(pos, grid, target)\n      actions.append(0 if pos[0] < env._current_state.pos[0] else (1 if pos[0] > env._current_state.pos[0] else None))\n      actions.append(2 if pos[1] < env._current_state.pos[1] else (3 if pos[1] > env._current_state.pos[1] else None))\n  \n  def move_to_craft(actions, inventory, recipe):\n    for primitive in recipe:\n      while inventory[primitive] > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  pos = env._current_state.pos\n  grid = env._current_state.grid\n  \n  for primitive in recipe:\n    find_and_move(actions, pos, grid, primitive)\n  \n  move_to_craft(actions, inventory, recipe)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n\n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        actions.append(4)  # USE action to use the primitive\n        inventory[primitive] -= 1\n        count -= 1\n\n  def move_to_item(pos, grid, target):\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if grid[pos[0]+dx, pos[1]+dy] == target:\n          return (pos[0]+dx, pos[1]+dy)\n    raise ValueError(\"Item not found in the grid.\")\n\n  def find_items(grid, items):\n    item_positions = {}\n    for item in items:\n      for x in range(env.world.n_kinds):\n        for y in range(env.world.n_kinds):\n          if grid[x, y] == item:\n            item_positions[(x, y)] = True\n    return list(item_positions.keys())\n\n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  pos = env._current_state.pos\n  grid = env._current_state.grid\n\n  item_positions = find_items(grid, [env.world.cookbook.index[item]])\n  for item_pos in item_positions:\n    while not (pos == item_pos and inventory[recipe[0]] > 0):\n      if pos[0] < item_pos[0]: actions.append(1)  # UP\n      elif pos[0] > item_pos[0]: actions.append(0)  # DOWN\n      elif pos[1] < item_pos[1]: actions.append(3)  # RIGHT\n      elif pos[1] > item_pos[1]: actions.append(2)  # LEFT\n    actions.append(4)  # USE action to use the primitive\n    inventory[recipe[0]] -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the recipe for the desired item from the cookbook\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Iterate over the ingredients in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument using a regular expression\n      _, arg = parse_fexp(ingredient)\n      # Find the index of the ingredient in the environment's cookbook\n      ingredient_index = env.world.cookbook.index[arg]\n      \n      # Check if the ingredient is available in the inventory\n      while count > 0 and env._current_state.inventory[ingredient_index] > 0:\n        # If so, use one unit of the ingredient by adding the corresponding action to the list\n        actions.append(USE)\n        # Decrease the count of the ingredient in the inventory and the required count\n        env._current_state.inventory[ingredient_index] -= 1\n        count -= 1\n      \n      # If not enough ingredients are available, try to pick them up from the grid if possible\n      while count > 0:\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            x = env._current_state.pos[0] + dx\n            y = env._current_state.pos[1] + dy\n            if 0 <= x < env._current_state.grid.shape[0] and 0 <= y < env._current_state.grid.shape[1]:\n              cell = env._current_state.grid[x, y, :]\n              for i in range(env.world.n_kinds):\n                if cell[i] == ingredient_index and i not in env.non_grabbable_indices:\n                  actions.append(MOVE_TO(x, y))\n                  env._current_state.pos = (x, y)\n                  found = True\n                  break\n              if found:\n                break\n        # If the ingredient is found and picked up, add a pickup action to the list\n        if not found:\n          actions.append(USE)\n          count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, raise an error indicating not enough inventory\n        raise ValueError(\"Not enough items in inventory to craft the desired item.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, find a free grabbable item and use it\n        for i in range(len(env.grabbable_indices)):\n          if env.grid[i] == 0:  # Assuming 0 means the cell is empty or non-grabbable\n            actions.append(i)  # Use the action corresponding to an empty grabbable index\n            break\n      found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n        env.step(actions[-1], num_steps=1)  # Perform the action and update the state\n    return actions\n  \n  def use_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    for i in range(len(ingredient_indices)):\n      while env._current_state.inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        action = pickup_item(env, ingredient_indices[i])\n        if action is not None:\n          actions.append(action)\n        inventory = env._current_state.inventory  # Update the inventory after pickup\n      action = use_item(env, ingredient_indices[i], ingredient_counts[i])\n      if action is not None:\n        actions.append(action)\n    return actions\n  \n  def craft_recursive(env, goal_index):\n    ingredients, counts = find_required_ingredients(goal_index)\n    if not ingredients:\n      return []\n    \n    # Pickup all required ingredients\n    for i in range(len(ingredients)):\n      while env._current_state.inventory[ingredients[i]] < counts[i]:\n        actions = pickup_item(env, ingredients[i])\n        if len(actions) > 0:\n          env.step(actions[-1], num_steps=1)  # Perform the action and update the state\n    \n    # Craft each ingredient one by one (recursive crafting)\n    for i in range(len(ingredients)):\n      craft_recursive(env, ingredients[i])\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  craft_recursive(env, goal_index)\n  return []", "occurrence_count": 1}
{"function_body": "  def find_required_ingredients(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index)\n    if not recipe:\n      return [], []\n    \n    ingredient_indices = []\n    ingredient_counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredient_indices.append(key)\n        ingredient_counts.append(count)\n    return ingredient_indices, ingredient_counts\n  \n  def pickup_ingredients(env, ingredient_indices, ingredient_counts):\n    actions = []\n    inventory = env._current_state.inventory\n    for i in range(len(ingredient_indices)):\n      while inventory[ingredient_indices[i]] < ingredient_counts[i]:\n        actions += pickup_item(env, ingredient_indices[i])\n        # Perform the action and update the state\n        env.step(actions[-1], num_steps=1)\n    return actions\n  \n  def craft_recursive(env, goal_index):\n    ingredients, counts = find_required_ingredients(goal_index)\n    if not ingredients:\n      return []\n    \n    # Pickup all required ingredients\n    actions = pickup_ingredients(env, ingredients, counts)\n    \n    # Craft each ingredient one by one (recursive crafting)\n    for i in range(len(ingredients)):\n      craft_recursive(env, ingredients[i])\n  \n  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  craft_recursive(env, goal_index)\n  return []", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v - env._current_state.inventory[k] for k, v in recipe.items() if v > env._current_state.inventory[k]}\n  \n  # If no recipe or we have all items, return an empty list as it is already crafted or cannot be crafted\n  if not recipe or not any(missing_items.values()):\n    return []\n  \n  actions = []\n  while missing_items:\n    for item_idx, count in missing_items.items():\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(4)  # USE action to move and pickup the item\n            missing_items[item_idx] -= 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(4)  # USE action to craft the item\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the recipe for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  actions = []\n  inventory = np.array(env._current_state.inventory)\n\n  # Find and pick up all required items from the grid or inventory\n  for item_idx, count in recipe.items():\n    while inventory[item_idx] < count:\n      # Check if the item is next to the agent\n      found = False\n      pos = env._current_state.pos\n      nx, ny = pos\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = env.world.cookbook.primitives_for(idx)\n  actions = []\n  inventory = np.array(env._current_state.inventory)\n  \n  # Check if we have enough of each primitive in our inventory to craft the desired item\n  for item_idx, count in recipe.items():\n    while inventory[item_idx] < count:\n      # Find the position of the item and move towards it if necessary\n      pos = env._current_state.pos\n      grid = env._current_state.grid\n      nx, ny = pos\n      found = False\n      for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n          if (nx+dx, ny+dy) == item_pos:\n            # Move to the position and pick up the item\n            actions.append(env.action_index['pickup'])\n            inventory[item_idx] += 1\n            found = True\n            break\n        if found: break\n      else:\n        raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index and required primitives to craft the item\n  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Check if the cookbook is empty or not initialized\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  # Get the index and required primitives to craft the item\n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    cookbook = env.world.cookbook\n    goal_index = cookbook.index.get(item)\n    if goal_index is None:\n      raise ValueError(\"Item not found in cookbook\")\n    return cookbook.recipes.get(goal_index)\n  \n  def find_ingredients(recipe):\n    ingredients = []\n    counts = []\n    for key, count in recipe.items():\n      if isinstance(key, int):\n        ingredients.append(key)\n        counts.append(count)\n    return ingredients, counts\n  \n  actions = []\n  cookbook = env.world.cookbook\n  goal_index = cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook\")\n  \n  recipe = cookbook.recipes.get(goal_index)\n  if not recipe:\n    return actions\n  \n  ingredients, counts = find_ingredients(recipe)\n  inventory = env._current_state.inventory\n  \n  for i in range(len(ingredients)):\n    while inventory[ingredients[i]] < counts[i]:\n      # Try to pick up the ingredient if not enough in inventory\n      actions += pickup_item(env, ingredients[i])\n      inventory = env._current_state.inventory  # Update the inventory after pickup\n    \n    action = use_item(env, ingredients[i], counts[i])\n    if action is not None:\n      actions.append(action)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize an empty list to store actions\n  actions = []\n  \n  # Find the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate over the ingredients in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument using a regular expression\n      _, arg = parse_fexp(ingredient)\n      # Find the index of the ingredient in the environment's cookbook\n      ingredient_index = env.world.cookbook.index[arg]\n      \n      # Check if the ingredient is available in the inventory\n      while count > 0 and env._current_state.inventory[ingredient_index] > 0:\n        # If so, use one unit of the ingredient by adding the corresponding action to the list\n        actions.append(USE)\n        # Decrease the count of the ingredient in the inventory and the required count\n        env._current_state.inventory[ingredient_index] -= 1\n        count -= 1\n      \n      # If not enough ingredients are available, try to pick them up from the grid if possible\n      while count > 0:\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            x = env._current_state.pos[0] + dx\n            y = env._current_state.pos[1] + dy\n            if 0 <= x < env._current_state.grid.shape[0] and 0 <= y < env._current_state.grid.shape[1]:\n              cell = env._current_state.grid[x, y, :]\n              for i in range(env.world.n_kinds):\n                if cell[i] == ingredient_index and i not in env.non_grabbable_indices:\n                  actions.append(MOVE_TO(x, y))\n                  env._current_state.pos = (x, y)\n                  found = True\n                  break\n              if found:\n                break\n        # If the ingredient is found and picked up, add a pickup action to the list\n        if not found:\n          actions.append(USE)\n          count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the recipe for the desired item\n  recipe = env.world.cookbook.recipes[item]\n  \n  # Iterate over the ingredients in the recipe\n  for ingredient, count in recipe.items():\n    if isinstance(ingredient, str) and '[' in ingredient:\n      # Parse the ingredient name and argument using a regular expression\n      _, arg = parse_fexp(ingredient)\n      # Find the index of the ingredient in the environment's cookbook\n      ingredient_index = env.world.cookbook.index[arg]\n      \n      # Check if the ingredient is available in the inventory\n      while count > 0 and env._current_state.inventory[ingredient_index] > 0:\n        # If so, use one unit of the ingredient by adding the corresponding action to the list\n        actions.append(USE)\n        # Decrease the count of the ingredient in the inventory and the required count\n        env._current_state.inventory[ingredient_index] -= 1\n        count -= 1\n      \n      # If not enough ingredients are available, try to pick them up from the grid if possible\n      while count > 0:\n        found = False\n        for dx in [-1, 0, 1]:\n          for dy in [-1, 0, 1]:\n            x = env._current_state.pos[0] + dx\n            y = env._current_state.pos[1] + dy\n            if 0 <= x < env._current_state.grid.shape[0] and 0 <= y < env._current_state.grid.shape[1]:\n              cell = env._current_state.grid[x, y, :]\n              for i in range(env.world.n_kinds):\n                if cell[i] == ingredient_index and i not in env.non_grabbable_indices:\n                  actions.append(MOVE_TO(x, y))\n                  env._current_state.pos = (x, y)\n                  found = True\n                  break\n              if found:\n                break\n        # If the ingredient is found and picked up, add a pickup action to the list\n        if not found:\n          actions.append(USE)\n          count -= 1\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      while len(indices) > 0:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(indices[0]))  # Find the actual pickup action based on index\n        inventory[primitive] -= 1\n        indices = np.where(inventory[primitive] > 0)[0]  # Update indices after using one\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while count > 0:\n        actions.append(4)  # USE action to use the primitive to craft the item\n        count -= 1\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  recipe = get_recipe(item)\n  if not recipe:\n    raise ValueError(\"No recipe found for the given item.\")\n  \n  required_primitives = list(recipe.keys())\n  inventory = env._current_state.inventory\n  \n  actions = []\n  \n  def use_and_pickup_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      while count > 0:\n        if inventory[primitive] > 0:\n          actions.append(4)  # USE action to use the primitive\n          actions.append(env._find_pickup_action(env.world.cookbook.index[primitive]))  # Find the actual pickup action based on index\n          inventory[primitive] -= 1\n          count -= 1\n        else:\n          break\n  \n  use_and_pickup_items(actions, inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the desired goal from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  # Pickup ingredients needed for the craft\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - get_item_position(env._current_state.grid, x[0])), reverse=True):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      target_pos = get_item_position(env._current_state.grid, ingredient_index)\n      if target_pos is not None:\n        move_to(target_pos)\n        pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Check if the ingredient is already in the inventory\n    if env.inventory[ingredient_index] > 0:\n      actions.append(env.grabbable_indices.get(ingredient_index))  # Use the action corresponding to the ingredient index\n    else:\n      # Find the position of the ingredient in the grid and pick it up\n      found = False\n      for y in range(env.grid.shape[1]):\n        for x in range(env.grid.shape[0]):\n          if env.grid[x, y, ingredient_index] > 0:\n            actions.append(env.grabbable_indices.get(ingredient_index))  # Use the action corresponding to the ingredient index\n            found = True\n            break\n        if found:\n          break\n      if not found:\n        raise ValueError(\"Ingredient not found in grid.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item from the cookbook\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item from the cookbook\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory or grid\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n    \n    if not found:\n      raise ValueError(\"Ingredient not found in inventory or grid.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_ingredient_indices(goal_index):\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    return [ingredient_index for ingredient_index in recipe if ingredient_index != \"_key\"]\n\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index in get_ingredient_indices(goal_index):\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook using the item name\n  goal_index = env.world.cookbook.index.get(item)\n  \n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item from the recipes dictionary\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the grabbable indices list\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name\n  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the ingredients in the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    recipe = env.world.cookbook.primitives_for(goal)\n    if not recipe:\n      return {}\n    return recipe\n  \n  idx = env.world.cookbook.index.get(item)\n  if idx is None:\n    raise ValueError(\"Item {} is not in the cookbook.\".format(item))\n  \n  # Get the required items for crafting this item\n  recipe = get_recipe(idx)\n  missing_items = {k: v for k, v in recipe.items() if env._current_state.inventory[k] < v}\n  \n  actions = []\n  while missing_items:\n    # Find the position of the item and move towards it if necessary\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) in env.grabbable_indices:\n          # Move to the position and pick up the item\n          actions.append(env.action_index['pickup'])\n          missing_items[next(iter(missing_items))] -= 1\n          found = True\n          break\n      if found: break\n    else:\n      raise ValueError(\"Item not found in the grid.\")\n    \n    # Craft the desired item and update inventory\n    actions.append(env.action_index['craft'])\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(goal):\n    cookbook = env.world.cookbook\n    idx = cookbook.index.get(goal)\n    if idx is None:\n      raise ValueError(\"Item {} not found in the cookbook.\".format(item))\n    return cookbook.primitives_for(idx)\n  \n  def craft_items(actions, inventory, recipe):\n    for primitive, count in recipe.items():\n      while inventory[primitive] > 0 and count > 0:\n        if inventory[primitive] >= count:\n          actions.append(4)  # USE action to use the primitive\n          inventory[primitive] -= count\n          count = 0\n        else:\n          pickup_action = env._find_pickup_action(primitive)\n          if pickup_action is not None:\n            actions.append(pickup_action)  # Move to the primitive and pick it up if necessary\n            inventory[primitive] -= 1\n            count -= 1\n  \n  def find_and_move_to_item(actions, env, item_idx):\n    pos = env._current_state.pos\n    grid = env._current_state.grid\n    nx, ny = pos\n    found = False\n    for dx in [-1, 0, 1]:\n      for dy in [-1, 0, 1]:\n        if (nx+dx, ny+dy) == item_idx:\n          actions.append(env._find_pickup_action(item_idx))  # Move to the position and pick it up\n          found = True\n          break\n      if found: break\n    if not found:\n      raise ValueError(\"Item {} not found in the grid.\".format(item_idx))\n  \n  actions = []\n  recipe = get_recipe(item)\n  if not recipe:\n    return actions  # If no recipe, do nothing\n  \n  inventory = env._current_state.inventory\n  missing_items = {k: v for k, v in recipe.items() if inventory[k] < v}\n  \n  while missing_items:\n    for item_idx, count in missing_items.items():\n      find_and_move_to_item(actions, env, item_idx)\n    \n    # Craft the desired item and update inventory\n    actions.append(4)  # USE action to use the primitive\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index and recipe from the cookbook\n  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  actions = []\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(ingredient_index):\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        return i\n    raise ValueError(f\"Ingredient {ingredient_index} not found in inventory\")\n\n  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  actions = []\n  \n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n    \n    ingredient_index = find_ingredient(ingredient_index)\n    actions.append(env.world.grabbable_indices.index(ingredient_index))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0 and not (actions and actions[-1] == i):\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        for i in range(len(env.grabbable_indices)):\n          if env.grid[i] == 0:  # Assuming 0 means the cell is empty or non-grabbable\n            actions.append(i)  # Use the action corresponding to an empty grabbable index\n            break\n      found = True\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  actions = []\n\n  # Helper function to find and use ingredients\n  def use_ingredient(ingredient_index):\n    found = False\n    while not found:\n      for i in range(len(env.grabbable_indices)):\n        if env.inventory[ingredient_index] > 0:\n          actions.append(i)  # Use the action corresponding to the ingredient index\n          break\n      else:\n        # If no more ingredients can be used, find a free grabbable item and use it\n        for i in range(len(env.grabbable_indices)):\n          if env.grid[i] == 0:  # Assuming 0 means the cell is empty or non-grabbable\n            actions.append(i)  # Use the action corresponding to an empty grabbable index\n            break\n      found = True\n\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    while count > 0:\n      use_ingredient(ingredient_index)\n      count -= 1\n\n  return actions", "occurrence_count": 1}
{"function_body": "  # Your improved crafting logic here\n  return []", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid):\n    for z in range(grid.shape[-1]):\n      pos = np.where(grid[:, :, z] == item)\n      if pos[0].size > 0:\n        return (pos[0][0], pos[1][0])\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(ingredient_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  while any(env._current_state.inventory[idx] < count for idx, count in ingredients.items()):\n    target_pos = get_item_position(env._current_state.grid)\n    if target_pos is not None:\n      move_to(target_pos)\n      pickup()\n  return actions", "occurrence_count": 1}
{"function_body": "  def get_component_indices():\n    goal = env.world.cookbook.index.get(item)\n    if goal is None:\n      raise ValueError(f\"Item {item} not found in cookbook.\")\n    \n    recipe = env.world.cookbook.primitives_for(goal)\n    component_indices = []\n    for component, count in recipe.items():\n      if component < len(env.non_grabbable_indices):\n        component_index = list(env.non_grabbable_indices).index(component)\n        for _ in range(count):\n          if not env.next_to(component_index):\n            direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n            component_indices.append((component_index, direction))\n    return component_indices\n  \n  def get_actions():\n    actions = []\n    for component_index, direction in get_component_indices():\n      if not env.next_to(component_index):\n        actions.append(direction)\n      while not env.next_to(component_index):\n        actions.append(4)  # Use action to pick up the component\n    return actions\n  \n  return get_actions()", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  actions = []\n  \n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n    \n    # Find the first available instance of the ingredient\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices[i])\n        found = True\n        break\n    \n    # If the ingredient was not found, raise an error (or handle it as needed)\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_ingredient(ingredient_index):\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        return i\n    raise ValueError(f\"Ingredient {ingredient_index} not found in inventory\")\n\n  def craft_required_items():\n    required_items = []\n    goal_index = env.world.cookbook.index[item]\n    recipe = env.world.cookbook.recipes.get(goal_index, {})\n    \n    for ingredient_index, count in recipe.items():\n      if ingredient_index == \"_key\":\n        continue\n      \n      ingredient_index = find_ingredient(ingredient_index)\n      required_items.append((ingredient_index, count))\n    \n    return required_items\n\n  required_items = craft_required_items()\n  \n  actions = []\n  for item, count in required_items:\n    for _ in range(count):\n      actions.append(env.world.grabbable_indices.index(item))\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  actions = []\n  \n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue\n    \n    # Check the inventory for the required ingredients and use them directly if possible\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices[i])\n        found = True\n        break\n    \n    # If the ingredient was not found, raise an error (or handle it as needed)\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name.\n  goal_index = env.world.cookbook.index[item]\n  \n  # Retrieve the recipe for this goal.\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  # Initialize an empty list to store actions.\n  actions = []\n  \n  # Iterate over each ingredient in the recipe.\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself.\n    \n    # Find the first available instance of the ingredient in the inventory.\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(i)  # Append the action to pick up the ingredient.\n        found = True\n        break\n    \n    # If the ingredient was not found, raise an error (or handle it as needed).\n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      inventory = env._current_state.inventory\n      # Check inventory before taking action to avoid unnecessary actions\n      while inventory[required_item] > 0 and np.any(env._current_state.grid[:, :, required_item] == 0):\n        if np.any(env._current_state.grid[:, :, required_item] > 0):\n          # If the item is in the grid but not picked up, pick it up first before crafting\n          actions.append(env.world.grabbable_indices.index(required_item))\n        else:\n          actions.append(4)  # Action for using the item to craft something\n        inventory = env._current_state.step(4).inventory  # Update inventory after use\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if required_item not in env._non_grabbable_indices:\n      inventory = env._current_state.inventory\n      # Check inventory before taking action to avoid unnecessary actions\n      while inventory[required_item] > 0:\n        actions.append(env.world.grabbable_indices.index(required_item))\n        actions.append(4)  # Action for using the item to craft something\n        env._current_state = env._current_state.step(4)  # Update state after use\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  # Get the recipe for the desired item\n  recipe = get_recipe(item)\n  \n  actions = []\n\n  def craft_items(recipe, inventory):\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, inventory)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          # Check inventory before taking action to avoid unnecessary actions\n          if inventory[required_item] == 0 and required_item not in env._non_grabbable_indices:\n            actions.append(env.world.grabbable_indices.index(required_item))\n            actions.append(4)  # Action for using the item to craft something\n  \n  inventory = env._current_state.inventory\n\n  def find_and_craft(recipe, inventory):\n    if all(env.world.cookbook.index[key] in inventory and inventory[env.world.cookbook.index[key]] > 0 for key in recipe):\n      craft_items(recipe, inventory)\n  \n  # Start crafting from the top-level goal item down to its components\n  find_and_craft(recipe, inventory)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes[item]\n    required_items = []\n    \n    # Recursively find all the required items by traversing the recipe dictionary\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_items.append(value)\n    \n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n\n  # Initialize the actions list and pick up any required items that are not already in the inventory\n  actions = []\n  for req_item in reversed(required_items):\n    if env.world.cookbook.index[req_item] not in env._non_grabbable_indices:\n      # Find where to place the item in the grid\n      pos = None\n      for x in range(env._current_state.grid.shape[0]):\n        for y in range(env._current_state.grid.shape[1]):\n          if env._current_state.grid[x, y, env.world.cookbook.index[req_item]] != 0:\n            pos = (x, y)\n            break\n        if pos is not None:\n          break\n      if pos is not None:\n        actions.append(env.world.grabbable_indices.index(env.world.cookbook.index[req_item]))\n        # Move to the position of the required item\n        move_actions = []\n        start_pos = env._current_state.pos\n        end_pos = pos\n        if start_pos[0] < end_pos[0]:\n          move_actions.append(0)  # DOWN\n        elif start_pos[0] > end_pos[0]:\n          move_actions.append(1)  # UP\n        elif start_pos[1] < end_pos[1]:\n          move_actions.append(2)  # RIGHT\n        elif start_pos[1] > end_pos[1]:\n          move_actions.append(3)  # LEFT\n        actions.extend(move_actions)\n      else:\n        raise ValueError(\"Required item not found in the grid.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_and_use_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      indices = np.where(inventory[primitive] > 0)[0]\n      for index in indices:\n        actions.append(4)  # USE action to use the primitive\n        actions.append(env._find_pickup_action(index))  # Find the actual pickup action based on index\n  \n  def find_and_craft_items(actions, inventory, required_primitives):\n    for primitive in required_primitives:\n      count = recipe[primitive]\n      for _ in range(count):\n        actions.append(4)  # USE action to use the primitive\n  \n  def get_recipe(goal):\n    return env.world.cookbook.primitives_for(goal)\n\n  actions = []\n  recipe = get_recipe(item)\n  required_primitives = list(recipe.keys())\n  \n  find_and_use_items(actions, env._current_state.inventory, required_primitives)\n  find_and_craft_items(actions, env._current_state.inventory, required_primitives)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the index of the goal item\n  goal_index = env.world.cookbook.index.get(item)\n\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(\"Item not found in cookbook.\")\n\n  # Get the recipe for the goal item\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n\n  # Initialize an empty list to store actions\n  actions = []\n\n  # Iterate over the ingredients and their counts in the recipe\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which indicates the main output of the recipe\n\n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.grabbable_indices)):\n      if env.inventory[ingredient_index] > 0:\n        actions.append(i)  # Use the action corresponding to the ingredient index\n        break\n\n    if not found:\n      raise ValueError(\"Ingredient not found in inventory.\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def get_required_items(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    \n    required_items = []\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        required_items.extend(get_required_items(value))\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          required_items.append(required_item)\n    return required_items\n  \n  # Get all the items needed to craft the desired item\n  required_items = get_required_items(item)\n  \n  actions = []\n  for required_item in required_items:\n    if env._current_state.inventory[required_item] > 0 and required_item not in env._non_grabbable_indices:\n      item_index = env.world.grabbable_indices.index(required_item)\n      actions.append(item_index)\n      # Check inventory before taking action to avoid unnecessary actions\n      if env._current_state.inventory[required_item] == 1:\n        actions.append(4)  # Action for using the item to craft something\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  def find_recipe(item):\n    recipe = env.world.cookbook.recipes.get(item)\n    if not recipe:\n      raise ValueError(f\"Item '{item}' does not have a crafting recipe.\")\n    return recipe\n  \n  def craft_items(recipe, actions):\n    inventory = env._current_state.inventory\n    for key, value in recipe.items():\n      if isinstance(value, dict) and \"_key\" not in key:\n        craft_items(value, actions)\n      elif key == \"_key\":\n        required_item = env.world.cookbook.index[value]\n        if required_item not in env._non_grabbable_indices:\n          item_index = env.world.grabbable_indices.index(required_item)\n          actions.append(item_index)\n          # Check inventory before taking action to avoid unnecessary actions\n          if inventory[required_item] == 0:\n            actions.append(item_index)\n            actions.append(4)  # Action for using the item to craft something\n  \n  recipe = find_recipe(item)\n  actions = []\n  craft_items(recipe, actions)\n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  # Initialize an empty list to store actions\n  actions = []\n  \n  # Get the necessary components and their counts from the environment's cookbook\n  recipe = env.world.cookbook.primitives_for(goal_index)\n  \n  # Helper function to get component index and count\n  def get_component_info(env, component):\n    component_index = list(env.non_grabbable_indices).index(component)\n    return component_index, recipe[component]\n\n  # Iterate over each component in the recipe\n  for component, count in recipe.items():\n    if component < len(env.non_grabbable_indices):\n      component_index, required_count = get_component_info(env, component)\n      \n      # Add actions to pick up and use the component until the required count is reached\n      for _ in range(required_count):\n        if not env.next_to(component_index):\n          direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component_index)\n          actions.append(direction)\n        actions.append(4)  # Use action to pick up the component\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  goal_index = env.world.cookbook.index.get(item)\n  if goal_index is None:\n    raise ValueError(f\"Item {item} not found in cookbook.\")\n  \n  recipe = env.world.cookbook.primitives_for(goal_index)\n  actions = []\n  for component, count in recipe.items():\n    # Find the position of the component in the grid\n    if component < len(env.non_grabbable_indices):\n      component_pos = np.argwhere(env.grid == component)[0]\n      \n      # Move to the closest cell containing the component\n      while not env.next_to(component):\n        direction = env._get_closest_direction(env.pos, env.grid[env.pos] == component)\n        actions.append(direction)\n    \n    # Use action to pick up the component\n    actions.append(4)\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Get the goal index from the cookbook based on the item name\n  goal_index = env.world.cookbook.index[item]\n  \n  # Retrieve the recipe for this goal\n  recipe = env.world.cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and env.world.cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the ingredients in the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  cookbook = env.world.cookbook\n  if not cookbook:\n    raise ValueError(\"Cookbook is empty.\")\n  \n  goal_index = cookbook.index[item]\n  recipe = cookbook.recipes.get(goal_index, {})\n  \n  # Initialize the action list\n  actions = []\n  \n  # Iterate over the recipe to determine the sequence of actions needed\n  for ingredient_index, count in recipe.items():\n    if ingredient_index == \"_key\":\n      continue  # Skip the key which is a placeholder for the output itself\n    \n    # Find the position of the ingredient in the inventory\n    found = False\n    for i in range(len(env.world.grabbable_indices)):\n      if env.world.inventory[i] > 0 and cookbook.index[i] == ingredient_index:\n        actions.append(env.world.grabbable_indices.index(i))  # Append the action to pick up the ingredient\n        found = True\n        break\n    \n    if not found:\n      raise ValueError(f\"Ingredient {ingredient_index} not found in inventory for crafting item {item}\")\n  \n  return actions", "occurrence_count": 1}
{"function_body": "  # Your improved logic here!\n  return []", "occurrence_count": 1}
{"function_body": "  def get_item_position(grid, item_index):\n    for z in range(grid.shape[-1]):\n      if np.any(grid[:, :, z] == item_index):\n        return np.where(grid[:, :, z] == item_index)\n    return None\n\n  def move_to(target_pos):\n    current_pos = env._current_state.pos\n    if target_pos[0] > current_pos[0]:\n      actions.append(env_factory.DOWN)\n    elif target_pos[0] < current_pos[0]:\n      actions.append(env_factory.UP)\n    elif target_pos[1] > current_pos[1]:\n      actions.append(env_factory.RIGHT)\n    elif target_pos[1] < current_pos[1]:\n      actions.append(env_factory.LEFT)\n\n  def pickup():\n    if env._current_state.next_to(item_index):\n      actions.append(env_factory.USE)\n\n  goal_item_idx = env.world.cookbook.index[item]\n  recipe = env.world.cookbook.recipes.get(goal_item_idx, {})\n\n  ingredients = {}\n  for key, count in recipe.items():\n    if isinstance(key, int) and key not in env.world.non_grabbable_indices:\n      ingredient_index = key\n      ingredients[ingredient_index] = count\n\n  actions = []\n\n  positions = {}\n  for z in range(env._current_state.grid.shape[-1]):\n    pos = np.where(env._current_state.grid[:, :, z] == item)\n    if pos[0].size > 0:\n      positions[(pos[0][0], pos[1][0])] = z\n\n  for ingredient_index, count in sorted(ingredients.items(), key=lambda x: np.linalg.norm(np.array(env._current_state.pos) - x[0])):\n    while not env._current_state.inventory[ingredient_index] >= count:\n      if (env._current_state.pos) in positions:\n        move_to(positions[env._current_state.pos])\n        pickup()\n  return actions", "occurrence_count": 1}
