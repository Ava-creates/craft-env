{"timestamp": "2025-06-25T09:43:52.497020", "function_name": "craft", "function_body": "  def heuristic(state, goal_item):\n    # Heuristic function: number of missing items needed to craft the goal\n    primitives = env.world.cookbook.primitives_for(goal_item)\n    current_inventory = state.inventory.copy()\n    \n    for ingredient, count in primitives.items():\n      if current_inventory[ingredient] < count:\n        return (count - current_inventory[ingredient]) * 10\n    \n    return 0\n\n  def astar(start_state, goal_item):\n    from heapq import heappush, heappop\n    from collections import defaultdict\n\n    open_set = []\n    heappush(open_set, (0, start_state, []))", "island_id": 6, "scores": {"3": -1}}
{"timestamp": "2025-06-25T09:43:54.142561", "function_name": "craft", "function_body": "  def heuristic(state, goal_item):\n    # Simple Manhattan distance based heuristic to estimate the remaining steps\n    goal_count = state.inventory[goal_item]\n    if goal_count > 0:\n      return 0\n    else:\n      # Estimate based on the number of primitives needed\n      primitives_needed = env.world.cookbook.primitives_for(goal_item)\n      current_inventory = {idx: count for idx, count in enumerate(state.inventory)}\n      total_distance = sum(abs(current_inventory.get(idx, 0) - count) for idx, count in primitives_needed.items())\n      return total_distance\n\n  def astar(start_state, goal_item):\n    from heapq import heappush, heappop\n    from collections import defaultdict\n\n    open_set = []\n    heappush(open_set, (0 + heuristic(start_state, goal_item), start_state, []))\n    came_from = {}\n    g_score = defaultdict(lambda: float('inf'))\n    g_score[start_state] = 0\n    f_score = defaultdict(lambda: float('inf'))\n    f_score[start_state] = heuristic(start_state, goal_item)\n    \n    while open_set:\n      _, current_state, actions_taken = heappop(open_set)\n\n      if current_state.satisfies(None, goal_item):\n        return reconstruct_path(came_from, current_state, actions_taken)\n      \n      for action in range(env.world.n_actions):\n        reward, next_state = current_state.step(action)\n        tentative_g_score = g_score[current_state] + 1\n        \n        if tentative_g_score < g_score[next_state]:\n          came_from[next_state] = (current_state, action)\n          g_score[next_state] = tentative_g_score\n          f_score[next_state] = tentative_g_score + heuristic(next_state, goal_item)\n          heappush(open_set, (f_score[next_state], next_state, actions_taken + [action]))\n    \n    return None  # Return None if no path is found\n\n  def reconstruct_path(came_from, current_state, actions_taken):\n    total_path = []\n    while current_state in came_from:\n      prev_state, action = came_from[current_state]\n      actions_taken.insert(0, action)\n      current_state = prev_state\n    return actions_taken\n\n  start_state = env._current_state\n  action_sequence = astar(start_state, item)\n\n  if action_sequence is None:\n    raise ValueError(f\"No crafting sequence found for goal {item}.\")\n  \n  return action_sequence", "island_id": 6, "scores": {"3": -1}}
{"timestamp": "2025-06-25T09:44:48.146209", "function_name": "craft", "function_body": "  def get_neighbors(state):\n    neighbors = []\n    # Prioritize actions that interact with the environment (USE) over movement\n    for action in [4] + list(range(4)):\n      reward, next_state = state.step(action)\n      if reward >= 0:  # Only consider valid moves\n        neighbors.append((next_state, action))\n    return neighbors\n\n  def bfs(start_state, goal_item):\n    from collections import deque\n\n    queue = deque([(start_state, [])])\n    visited_states = set()\n    \n    while queue:\n      current_state, actions_taken = queue.popleft()\n\n      if current_state.satisfies(None, goal_item):\n        return actions_taken\n      \n      for next_state, action in get_neighbors(current_state):\n        state_tuple = (tuple(next_state.grid.flatten()), tuple(next_state.pos), next_state.dir, tuple(next_state.inventory))\n        \n        if state_tuple not in visited_states:\n          queue.append((next_state, actions_taken + [action]))\n          visited_states.add(state_tuple)\n    \n    return None  # Return None if no path is found\n\n  start_state = env._current_state\n  action_sequence = bfs(start_state, item)\n\n  if action_sequence is None:\n    raise ValueError(f\"No crafting sequence found for goal {item}.\")\n  \n  return action_sequence", "island_id": 7, "scores": {"3": 1.5}}
{"timestamp": "2025-06-25T09:44:49.971557", "function_name": "craft", "function_body": "  def heuristic(state, goal_item):\n    # Simple heuristic: Manhattan distance to any needed primitive in the environment\n    if state.satisfies(None, goal_item):\n      return 0\n    \n    primitives_needed = env.world.cookbook.primitives_for(goal_item)\n    \n    min_dist = float('inf')\n    for i_kind, count in primitives_needed.items():\n      if count > state.inventory[i_kind]:\n        # Find the closest cell with the needed primitive\n        positions = np.argwhere(state.grid[:, :, i_kind] > 0)\n        if len(positions) > 0:\n          agent_pos = np.array(state.pos)\n          distances = np.sum(np.abs(positions - agent_pos), axis=1)", "island_id": 7, "scores": {"3": -1}}
