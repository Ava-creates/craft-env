{"timestamp": "2025-06-03T13:00:23.512104", "function_name": "move", "function_body": "  return -1", "island_id": null, "scores": {"UP": 0.0, "DOWN": 0.0, "LEFT": 0.0, "RIGHT": 0.0}}
{"timestamp": "2025-06-03T13:00:55.304552", "function_name": "move", "function_body": "  if dir == \"up\":\n    return 1\n  elif dir == \"down\":\n    return 0\n  elif dir == \"left\":\n    return 2\n  elif dir == \"right\":\n    return 3", "island_id": 8, "scores": {"UP": 0.0, "DOWN": 0.0, "LEFT": 0.0, "RIGHT": 0.0}}
{"timestamp": "2025-06-03T13:01:01.850915", "function_name": "move", "function_body": "  actions = {'UP': 1, 'DOWN': 0, 'LEFT': 2, 'RIGHT': 3}\n\n  # Get the current state and position\n  current_state = env._current_state\n  current_pos = current_state.pos\n\n  # Calculate target position based on direction\n  if dir == 'UP':\n    new_pos = (current_pos[0], current_pos[1] - 1)\n  elif dir == 'DOWN':\n    new_pos = (current_pos[0], current_pos[1] + 1)\n  elif dir == 'LEFT':\n    new_pos = (current_pos[0] - 1, current_pos[1])\n  elif dir == 'RIGHT':\n    new_pos = (current_pos[0] + 1, current_pos[1])\n\n  # Check if the target position is within grid bounds and passable\n  grid_shape = env.scenario.world.cookbook.n_kinds\n  if (new_pos[0] >= 0 and new_pos[0] < grid_shape and \n      new_pos[1] >= 0 and new_pos[1] < grid_shape):\n    return actions[dir]\n  \n  # Return no-op action if move is invalid\n  return -1", "island_id": 8, "scores": {"UP": 1.0, "DOWN": 1.0, "LEFT": 1.0, "RIGHT": 1.0}}
{"timestamp": "2025-06-03T13:01:13.540166", "function_name": "move", "function_body": "  mapping = {\"up\": 1,\n             \"down\": 0,\n             \"left\": 2,\n             \"right\": 3}\n\n  if dir not in mapping.keys():\n    raise ValueError(\"Invalid Direction\")\n\n  return mapping[dir]", "island_id": 1, "scores": {"UP": -1, "DOWN": -1, "LEFT": -1, "RIGHT": -1}}
{"timestamp": "2025-06-03T13:01:20.454650", "function_name": "move", "function_body": "  if dir == \"UP\":\n    return 1\n  elif dir == \"DOWN\":\n    return 0\n  elif dir == \"LEFT\":\n    return 2\n  elif dir == \"RIGHT\":\n    return 3", "island_id": 1, "scores": {"UP": 1.0, "DOWN": 1.0, "LEFT": 1.0, "RIGHT": 1.0}}
{"timestamp": "2025-06-03T13:01:35.163519", "function_name": "move", "function_body": "  action_map = {\n      'DOWN': 0,\n      'UP': 1,\n      'LEFT': 2,\n      'RIGHT': 3\n  }\n  \n  if dir not in action_map:\n    raise ValueError(f\"Invalid direction: {dir}\")\n\n  return action_map[dir]", "island_id": 4, "scores": {"UP": 1.0, "DOWN": 1.0, "LEFT": 1.0, "RIGHT": 1.0}}
{"timestamp": "2025-06-03T13:01:41.440734", "function_name": "move", "function_body": "  # Map the string directions to their corresponding integer values\n  DIRECTION_MAP = {\n      'down': 0,\n      'up': 1,\n      'left': 2,\n      'right': 3,\n      'use': 4\n  }\n\n  if dir not in DIRECTION_MAP:\n    raise ValueError(f\"Invalid direction: {dir}\")\n  \n  return DIRECTION_MAP[dir]", "island_id": 4, "scores": {"UP": -1, "DOWN": -1, "LEFT": -1, "RIGHT": -1}}
{"timestamp": "2025-06-03T13:02:22.267107", "function_name": "move", "function_body": "  actions = {'UP': 1, 'DOWN': 0, 'LEFT': 2, 'RIGHT': 3}\n\n  # Get the current state and position\n  current_state = env._current_state\n  current_pos = current_state.pos\n\n  # Calculate target position based on direction\n  if dir == 'UP':\n    new_pos = (current_pos[0], current_pos[1] - 1)\n  elif dir == 'DOWN':\n    new_pos = (current_pos[0], current_pos[1] + 1)\n  elif dir == 'LEFT':\n    new_pos = (current_pos[0] - 1, current_pos[1])\n  elif dir == 'RIGHT':\n    new_pos = (current_pos[0] + 1, current_pos[1])\n\n  # Check if the target position is within grid bounds and not a non-grabbable entity\n  grid_shape = env.scenario.world.cookbook.n_kinds\n  if (new_pos[0] >= 0 and new_pos[0] < grid_shape and \n      new_pos[1] >= 0 and new_pos[1] < grid_shape):\n    target_index = np.argmax(env._current_state.grid[new_pos], axis=-1)\n    if target_index not in env.scenario.world.non_grabbable_indices:\n      return actions[dir]\n  \n  # Return no-op action if move is invalid\n  return -1", "island_id": 8, "scores": {"UP": 1.0, "DOWN": 1.0, "LEFT": 1.0, "RIGHT": 1.0}}
{"timestamp": "2025-06-03T13:02:28.463613", "function_name": "move", "function_body": "  actions = {'UP': 1, 'DOWN': 0, 'LEFT': 2, 'RIGHT': 3}\n\n  # Get the current state and position\n  current_state = env._current_state\n  current_pos = current_state.pos\n\n  # Calculate target position based on direction\n  if dir == 'UP':\n    new_pos = (current_pos[0], current_pos[1] - 1)\n  elif dir == 'DOWN':\n    new_pos = (current_pos[0], current_pos[1] + 1)\n  elif dir == 'LEFT':\n    new_pos = (current_pos[0] - 1, current_pos[1])\n  elif dir == 'RIGHT':\n    new_pos = (current_pos[0] + 1, current_pos[1])\n\n  # Check if the target position is within grid bounds\n  grid_shape = env.scenario.world.cookbook.n_kinds\n  if (new_pos[0] >= 0 and new_pos[0] < grid_shape and \n      new_pos[1] >= 0 and new_pos[1] < grid_shape):\n    \n    # Check if the target position is passable (not an obstacle)\n    cookbook = env.scenario.world.cookbook\n    kind_index_at_new_pos = np.argmax(current_state.grid[new_pos[0], new_pos[1]])\n    if kind_index_at_new_pos not in cookbook.non_grabbable_indices:\n      return actions[dir]\n  \n  # Return no-op action if move is invalid or target position is an obstacle\n  return -1", "island_id": 8, "scores": {"UP": -1, "DOWN": -1, "LEFT": -1, "RIGHT": -1}}
{"timestamp": "2025-06-03T13:02:44.410603", "function_name": "move", "function_body": "  N_ACTIONS = {\n      'DOWN': 0,\n      'UP': 1,\n      'LEFT': 2,\n      'RIGHT': 3\n  }\n  \n  if dir not in N_ACTIONS:\n    raise ValueError(f\"Invalid direction: {dir}\")\n\n  return N_ACTIONS[dir]", "island_id": 4, "scores": {"UP": 1.0, "DOWN": 1.0, "LEFT": 1.0, "RIGHT": 1.0}}
